<!DOCTYPE html>
<html>
<head lang="ko_KR">

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="Developer KimChanJung's Blog" />
    <link rel="alternate" hreflang="ko-kr" href="https://kimchanjung.github.io/" />
    <link rel="alternate" hreflang="x-default" href="https://kimchanjung.github.io/" />
    <link rel="shortcut icon" href="https://kimchanjung.github.io/assets/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://kimchanjung.github.io/search/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="mogomezwai" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="Developer KimChanJung's Blog" />
    <meta property="og:url" content="https://kimchanjung.github.io/search/" />
    <meta property="og:image" content="https://kimchanjung.github.io/assets/images/new-blog-cover.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/mogomezwai" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="Developer KimChanJung's Blog" />
    <meta name="twitter:url" content="https://kimchanjung.github.io/" />
    <meta name="twitter:image" content="https://kimchanjung.github.io/assets/images/new-blog-cover.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="mogomezwai" />
    <meta name="twitter:site" content="@mogomezwai" />
    <meta name="twitter:creator" content="@mogomezwai" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "mogomezwai",
        "logo": "https://kimchanjung.github.io/assets/images/mogomezwai-logo.png"
    },
    "url": "https://kimchanjung.github.io/search/",
    "image": {
        "@type": "ImageObject",
        "url": "https://kimchanjung.github.io/assets/images/new-blog-cover.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://kimchanjung.github.io/search/"
    },
    "description": "Developer KimChanJung's Blog"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />
    <meta name="naver-site-verification" content="f1cd735caec0d9f78c0108426288fb40e725f65f" />

</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="/"><img src="/assets/images/mogomezwai-logo.png" alt="mogomezwai" /></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-resume" role="menuitem"><a href="/resume/">Resume</a></li>
    <li class="nav-projects" role="menuitem"><a href="/tag/projects/">Projects</a></li>
    <li class="nav-tech" role="menuitem"><a href="/tag/tech/">Tech</a></li>
    <li class="nav-programming" role="menuitem"><a href="/tag/programming/">Programming</a></li>
    <li class="nav-design-pattern" role="menuitem"><a href="/tag/design-pattern/">Design Pattern</a></li>
    <li class="nav-algorithm" role="menuitem"><a href="/tag/algorithm/">Algorithm</a></li>
    <li class="nav-etc" role="menuitem"><a href="/tag/etc/">Etc</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
                <a class="social-link social-link-tw" href="mailto:mogomezwai@gmail.com" target="_blank" rel="noopener">
<svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg></a>
            
            
                <a class="social-link social-link-fb" href="https://facebook.com/mogomezwai" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>
</a>
            
            
                <a class="social-link social-link-tw" href="https://twitter.com/mogomezwai" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>
</a>
            
            <a class="social-link social-link-rss" href="https://feedly.com/i/subscription/feed/https://kimchanjung.github.io/feed.xml" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"/><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/></svg>
</a>
            
            <!-- <a class="subscribe-button" href="#subscribe">search</a> -->
            <a class="social-link social-link-fb" href="#subscribe" ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" ><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg></a>
            
        </div>
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "algorithm-2020-07-29-zip": {
        "title": "프로그래머스 - 문자열 압축 [2020 KAKAO BLIND RECRUITMENT]",
            "author": "kimchanjung",
            "category": "",
            "content": "카카오 블라인드 2020 문자열 압축 문제를 설명과 함께 풀이 합니다.프로그래머스 - 문자열 압축문제바로가기문제유형  Brute-Force문제 설명  주어진 문자열을 압축하는 문제  aabbaccc =&gt; 2a2ba3c 각 중복되는 문자열앞에 중복개수를 붙여준다.  단 1개짜리 문자열은 개수를 붙이지 않는다.  ababcdcdababcdcd =&gt; 경우 2ab2cd2ab2cd 보다 2ababcdcd 가 문자열 길이가 더 짧다.결론 적으로는 각각의 케이스를 다 조사해서 제일 작은 문자열 길이를 리턴해야한다.풀이법처음에는 for문 하나에서 앞자리 문자와 다음 문자열을 비교 하면서 처리하려고 하였다. aabbaccc케이스는 문자 1개씩만 비교하니 통과하는 로직이지만 ababcdcd == ababcdcd 비교 로직이 들어가야 되기 때문에 for문 하나로는 안된다. 결국 전체 케이스를 다 확인 해야한다.aabbaccc를 압축 하는 예aabbaccc      a-a a-b b-b b-a a-c c-c c-c &lt;= 한칸씩 옮겨가며 조합을 본다.    aa-bb  bb-ac  ac-cc &lt;= 두개씩 잘라서 조합을 본다.    aab-bac bac-cc &lt;= 3개씩 잘라서 조합을 본다.    aabb-accc 4개씩 잘라서 조합을 본다.  총문자 열이 8개 이므로 1/2인 4개 즉 1~4개 까지 잘라서 비교해보는 로직을 구성하는 방법으로 해결한다.소스코드public class Lessons60057 {    public static int solution(String s) {        int result = s.length();        for (int i = 1; i &lt;= s.length() / 2; i++) {            StringBuilder zipStr = new StringBuilder();            String str = \"\", prevStr = \"\";            int strCount = 1;            for (int j = 0; j &lt; s.length(); j += i) {                str = s.substring(j, Math.min(j + i, s.length()));                if (prevStr.equals(str)) {                    strCount++;                    continue;                }                zipStr.append(strCount &gt; 1 ? strCount + prevStr : prevStr);                prevStr = str;                strCount = 1;            }            zipStr.append(strCount &gt; 1 ? strCount + str : str);            result = Math.min(result, zipStr.length());        }        return result;    }}",
        "url": "/algorithm/2020/07/29/zip/"
    }
    ,
    
    "algorithm-2020-07-13-bracket": {
        "title": "프로그래머스 - 괄호변환 [2020 KAKAO BLIND RECRUITMENT]",
            "author": "kimchanjung",
            "category": "",
            "content": "깔끔한 코드와 재귀로 프로그래머스 괄호변환 문제를 해석하고 풀이합니다.프로그래머스 - 괄호변환문제바로가기문제유형  Stack문제 설명  괄호를 확인하여 올바른 열고닫음의 짝수 괄호인지 확인하고 열고닫임이 맞지 않는 경우 변환하여 리턴하는 문제stack을 이용한 괄호 문제를 어렵게 내기 위해 꼬아 놓은 듯한 문제라 문제를 이해하는 것이 쉬운 편은 아님괄호를 설명하는 예시1. (()())() =&gt; 괄호가 짝도 맞고 열고 닫음 도 맞다 그대로 리턴2. )(       =&gt; 괄호가 짝은 맞지만 열고닫음이 틀리다 =&gt; ()로 변환하여 리턴3. ()))((() =&gt; 괄호가 짝은 맞지만 열고닫음이 틀리다 =&gt; ()(())()로 변환하여 리턴풀이법  문제 지면에 자세한 알고리즘이 설명되어 있다 사실 이것을 잘 이해하는 것이 중요하다.일반적인 Stack을 이용한 괄호 판별문제      ”(“ 열린 괄호를 스택에 넣다가 “)” 닫힌 괄호가 나오면 스택에서 꺼낸다.    1번 작업을 모두 완료 후 스택이 최종적으로 비었으면 짝이 맞다는 것으로 올바른 괄호로 판단하는 것이 기본 알고리즘  문제를 해결하는 핵심  올바른 여닫음 및 쌍으로 이루진 괄호를 판단하는 기준이 문제 해결의 핵심이다 그리고 괄호를 나누고 재조합하는 단위 U, V의 정의를 자세히 보아야한다.U의 정의  괄호가 “)(“,  “))((“ 열고닫음이 반대인 경우라도 서로 짝이 맞으면 U가 된다.그리고 최소한의 단위여야한다 (())(()) 경우 짝이 맞지만 (()), (()) 쪼개 지기 때문에 최소 개수로 짝이 맞으면 U가 된다.V의 정의  V는 U를 분리한 나머지괄호를 의미한다.주어진 괄호 ()))((()에 대해서 처리를 순서대로 본다면 1. ()))((() =&gt; U = (),   V = ))((()    =&gt; U \"()\" 개수도 짝이며 열고닫음도 맞다    =&gt; U +  재귀(V) 합친후 리턴한다2. ))((()   =&gt; U = ))((, V = ()   =&gt; U \"))((\" 개수는 짝이지만 열고닫음이 맞지 않다. 변환 처리를 한다   =&gt; \"(\" + 재귀(V) +\")\" + 변환처리(U) 를 반환 한다.  U가 열고 닫음이 바르면 U+재귀(V) 리턴하고  U가 열고 닫음이 틀리면 \"(\"+재귀(V)+\")\"+ 변환처리(U) 리턴한다U를 판단하고 분리하는 조건U를 판단하는 메소드는 stack을 이용해서 괄호를 판단하는 로직을 구성한다      ”(“ 스택에 넣는다, 여는괄호 개수 증가    ”)” 스택에서 뺀다  닫는괄호 개수 증가    for loop를 수행하는 동안 매번 여는괄호 == 닫는괄호 체크하여 같으면 loop를 종료한다    스택이 비었으면 열고닫음이 맞는 괄호 이므로 TRUE를 리턴 아니면 FALSE를 리턴한다.    이때 까지 수행한 괄호 문자열의 INDEX 저장하여 추후 U,V를 분리해 내는 기준 INDEX로 활용한다.  올바르지 않는 괄호의 변환처리의 조건      ”))(( “ U가 열고 닫음이 틀리면    첫번째와 마지막을 제거하여  “)(“만 남게 된다.    ”)(“ =&gt; 뒤집은 후 () 리턴한다    중요! - U가 “)(“인 경우는 =&gt; 첫번째와 마지막을 제거 =&gt; “” 공백을 리턴한다.문제 처리의 골격올바른괄호여부 = 괄호체크(괄호)   if (올바른괄호여부 == 참)   return U + 재귀함수(V)else   return \"(\"+재귀함수(V)+\")\" + 변환처리(U)소스코드public class Solution {    private static int index = 0;    public static String solution(String p) {        if (p.equals(\"\")) return \"\";        boolean check = check(p);        String U = p.substring(0, index), V = p.substring(index);        return check ? U + solution(V) : \"(\" + solution(V)+ \")\" + reverse(U);    }    // U를 판단하는 메소드    private static boolean check(String str) {        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        int balanced = 0;        index = 0;        for (char ch : str.toCharArray()) {            index++;            if ('(' == ch) {                stack.push(ch);balanced++;            } else {                if (!stack.isEmpty()) stack.pop();balanced--;            }            if (balanced == 0) break;        }        return stack.isEmpty();    }    // 올바르지 않은 괄호를 변환하는 메소드    private static String reverse(String str) {        return str.substring(1, str.length() - 1)                .chars()                .mapToObj(v -&gt; '(' == v ? \")\" : \"(\")                .collect(Collectors.joining(\"\"));    }}",
        "url": "/algorithm/2020/07/13/bracket/"
    }
    ,
    
    "programming-2020-07-05-typescipt-import-js-module-error": {
        "title": "[typescript] npm 모듈 import시 오류를 해결하는 방법(d.ts 파일 생성법)",
            "author": "kimchanjung",
            "category": "",
            "content": "typescript npm 모듈 import시 오류의 원인과 해결하는 방법을 알아봅니다.Typescript에서 js npm 모듈 import시 오류를 해결하는 방법typescript로 프로젝트를 할 때 npm에서 필요한 모듈들을 설치하고 import해서 사용하려고 할때 모듈 'module name'에 대한 선언 파일을 찾을 수 없습니다. 라는 메시지와 함께 모듈을 import할 수가 없습니다.  원인은 기존 js 파일에서만 import 하여 사용가능한 형태만 지원하고 npm모듈을 만든 개발자가 typescript사용할 수 있도록 처리를 하지 않았기 때문입니다.구글링 키워드가 잘 못 되었는지 정확한 문제 해결에 대한 답변을 찾을 수가 없었고 stack overflow의 답변들을 적용해보았으나 명확히 해결되지 않았습니다. 삽질 시간이 꽤 소모되어서 다른분들은 부디 삽질 하지 마시길 바라며 본 포스팅을 남깁니다.해결방법d.ts 파일 생성// @types/모듈명/index.d.ts declare module '모듈명'      모듈명 - import 모듈 from ‘모듈명’에서 사용하던 모듈명과 동일합니다.  d.ts 파일 생성 위치app /src    /node_modules    /assets    /@types &lt;= 폴더를 생성           /모듈명 &lt;= 모듈명과 같은 폴더명을 생성                /index.d.ts &lt;= index.d.ts파일 생성  생성위치 - app/@types/모듈명/index.d.tsimportimport 모듈 from '모듈명';  import 하는 곳에서는 다른 부분없이 그대로 평소 처럼 import하여 사용한다.tsconfig.json 설정설정을 추가해야한다고 하지만 본인의 경우에는 추가하지 않아도 동작하였습니다. 혹시 동작하지 않으신 분들은 추가 하세요{  \"compilerOptions\": {    \"typeRoots\" : [\"./@types\", \"./node_modules/@types\"]  },}  새로 생성한 @types폴터를 추가해 줍니다.마무리typescript사용시 npm 모듈이 import되지 않는 문제 해결방법을 알아 보았습니다.",
        "url": "/programming/2020/07/05/typescipt-import-js-module-error/"
    }
    ,
    
    "programming-2020-07-03-spring-security-03": {
        "title": "[Spring Security] 스프링시큐리티 커스텀 필터의 구현(3)",
            "author": "kimchanjung",
            "category": "",
            "content": "스프링시큐리티의 커스텀 필터를 생성하고 적용하는 방법을 예제코드와 함께 알아봅니다.Spring Security 커스텀 필터를 이용한 인증 구현 - 커스텀 필터의 구현(3)  본 포스팅은 스프링시큐리티의 전반적인 사용방법을 설명하는 포스팅은 아닙니다. 기본적인 동작구조와 별도의 인증을 도입할 때 필요한 커스텀인증필터를 작성하고 적용하는 방법을 알아봅니다.버전정보  Spring Boot v2.1.2  Spring Security v 5.1.3커스텀 인증을 위한 클래스들을 생성스프링시큐리티가 제공하는 인증필터와 인증매니저 대신 별도의 인증처리를 담당할 커스텀 클래스들을 생성합니다.커스텀 필터 CustomAuthenticationProcessingFilter 생성전체적인 인증 처리를 담당합니다.public class CustomAuthenticationProcessingFilter extends AbstractAuthenticationProcessingFilter {    public CustomAuthenticationProcessingFilter(String defaultFilterProcessesUrl) {        super(defaultFilterProcessesUrl);    }    @Override    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {        String username = request.getParameter(\"username\");        String password = request.getParameter(\"password\");        return getAuthenticationManager()                .authenticate(new UsernamePasswordAuthenticationToken(username, password)));    }}[코드1] 커스텀 인증 필터 생성      defaultFilterProcessesUrl에 설정한 URL이 호출되면 수행됩니다. 예) “/login-process”    username, password를 받아와서 UsernamePasswordAuthenticationToken에 담아 실제 인증처리를 하는 인증매니저를 호출합니다.    username, password를 가져오는 로직의 예외처리는 필수 입니다. 핵심로직만 설명하기 위해 간략한 코드로 설명합니다.  커스텀 인증매니저 CustomAuthenticationManager를 생성커스텀 필터는 전체적인 인증처리를 담당하는 역할을 하고 인증매니저는 실제 인증처리를 하는 로직을 구현하는 클래스입니다.CustomAuthenticationManagerpublic class CustomAuthenticationManager implements AuthenticationManager {    @Autowired    private UserDetailsService userDetailsService;    @Override    public Authentication authenticate(Authentication authentication) throws AuthenticationException {        UserDetails userDetails = userDetailsService.loadUserByUsername(authentication.getPrincipal());        // 각종 처리를 구현        // 비번이 일치하는지        // 아이디로 회원을 조회 했을 때 존재하는 회원인지        // 기타 등등과 적절한 예외 처리         return new UsernamePasswordAuthenticationToken(userDetails.getUsername()                , userDetails.getPassword()                , userDetails.getAuthorities()))    }}[코드2] 커스텀 인증 매니저 생성      AuthenticationManager를 상속한 커스텀 인증매니저는 로그인 폼으로 부터 받아온 아이디로 사용자를 가져와 인증 처리를 한다.    비번이 일치하는 지, 존재하는 사용자인지 등등의 로직을 처리하고 적절한 예외 처리도 한다.    코드의 핵심을 설명하기 위해 상세한 로직 처리와 예외 처리는 생략하였습니다.  사용자정보를 가져오는 인터페이스를 구현UserDetailsService는 스프링시큐리티가 제공하는 인터페이스입니다. 인터페이스에 맞게 사용자가 구현해야 하며 사용자의 정보를 가져오는 로직을 구현합니다.사용자의 정보를 가져오는 로직은 DB가 될 수도 있고 별도의 인증서버일 수도 있고 사용자의 상황에 맞게 구현하면 됩니다.UserDetailsService 구현유저정보를 담아낼 UserDetails인터페이스를 구현스프링시큐리에서 제공하는 UserDetails를 구현하여 유저정보를 담는 클래스를 생성합니다.public class CustomUserDetails implements UserDetails {    private List&lt;GrantedAuthority&gt; authorities;    private String password;    ...    public CustomUserDetails(User user) {        this.authorities = user.getAuthorities();        this.password = user.getPassword();        ....    }    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {        return authorities;    }    @Override    public String getPassword() {        return password;    }    ...}    [코드3] 유저 정보를 담는 클래스UserDetailsService를 구현유저정보를 아이디로 찾아와서 UserDetails구현한 CustomUserDetails클래스에 담아서 리턴하는 로직을 구현합니다.@Servicepublic class UserDetailServiceImpl implements UserDetailsService {    @Autowired    private UserRepository userRepository;    @Override    public UserDetails loadUserByUsername(String userId) throws BrmsBadCredentialsException {        return CustomUserDetails(userRepository.findByUserId(userId));    }}[코드4] 커스텀 인증 매니저 생성  이 부분은 DB에서 가져오거나 외부 서버에서 사용자정보를 가져오거나 할때 적절하게 구현하면 됩니다.인증 성공/실패 커스텀 핸들러커스텀 핸들러는 선택사항이지만 특별한 처리가 필요하면 커스텀핸들러를 추가할 수 있습니다.인증성공 커스텀핸들러 생성public class CustomAuthenticationSuccessHandler implements AuthenticationSuccessHandler {    private String defaultSuccessUrl = \"/\";    public CustomAuthenticationSuccessHandler(String defaultSuccessUrl) {        this.defaultSuccessUrl = defaultSuccessUrl;    }    @Override    public void onAuthenticationSuccess(HttpServletRequest request,                                         HttpServletResponse response,                                         Authentication authentication)             throws IOException, ServletException {        // 성공이후 로그를 님긴다        // 성공이벤트를 발행한다.        // 이메일을 발송한다.        response.sendRedirect(defaultSuccessUrl);    }}  커스텀 인증 성공 핸들를 생성하여 추가로직을 포함 할 수 있습니다.인증실패 커스텀핸들러 생성public class CustomAuthenticationFailureHandler implements AuthenticationFailureHandler {    private String defaultFailureUrl = \"/login-error\";    public CustomAuthenticationFailureHandler(String defaultFailureUrl) {        this.defaultFailureUrl = defaultFailureUrl;    }    @Override    public void onAuthenticationFailure(HttpServletRequest request,                                         HttpServletResponse response,                                         AuthenticationException ex)             throws IOException, ServletException {        // 실패로그를 남긴다        // 실패이벤트를 발송한다        response.sendRedirect(defaultSuccessUrl);    }}  커스텀 인증 실패 핸들를 생성하여 추가로직을 포함 할 수 있습니다.최종 Configuration 클래스@EnableWebSecuritypublic class BrmsWebSecurityConfiguration extends WebSecurityConfigurerAdapter {    @Override    public void configure(HttpSecurity http) throws Exception {        http.authorizeRequests()                .antMatchers(\"/login**\", \"/web-resources/**\", \"/actuator/**\").permitAll()                .antMatchers(\"/admin/**\").hasAnyRole(\"ADMIN\")                .antMatchers(\"/order/**\").hasAnyRole(\"USER\")                .anyRequest().authenticated()                .and()                .formLogin()                .and()                .addFilterBefore(customAuthenticationProcessingFilter(),                         UsernamePasswordAuthenticationFilter.class);    }    // 커스텀 인증 필터    @Bean    public CustomAuthenticationProcessingFilter customAuthenticationProcessingFilter() {        CustomAuthenticationProcessingFilter filter = new CustomAuthenticationProcessingFilter(\"/login-process\");        filter.setAuthenticationManager(customAuthenticationManager());        filter.setAuthenticationFailureHandler(new CustomAuthenticationFailureHandler(\"/login\"));        filter.setAuthenticationSuccessHandler(new SimpleUrlAuthenticationSuccessHandler(\"/\"));        return filter;    }    // 커스텀 인증 매니저     @Bean    public CustomAuthenticationManager customAuthenticationManager() {        return new CustomAuthenticationManager();    }} 마무리최종적으로 커스텀 인증 필터와 그에 필요한 클래스들의 생성 방법을 알아보고 적용하는 방법까지 알아 보았습니다. 물론 세부적인 내용이나 구현은 내용이 많아 생략하였지만 원래 글의 의도인 인증로직을 사용자에 상황에 맞게 구현할 때 대략적인 스프링시큐리티의 구조속에서 어떤 방향으로 접근해야하는지에 중점을 두어 글을 작성하였습니다.연관 글[Spring Security] 스프링시큐리티 동작구조의 이해(1) [Spring Security] 스프링시큐리티 설정값들의 역할과 설정방법(2)",
        "url": "/programming/2020/07/03/spring-security-03/"
    }
    ,
    
    "programming-2020-07-02-spring-security-02": {
        "title": "[Spring Security] 스프링시큐리티 설정값들의 역할과 설정방법(2)",
            "author": "kimchanjung",
            "category": "",
            "content": "스프링시큐리티의 여러가지 설정값들의 역할과 설정방법을 상세히 알아봅니다.Spring Security 커스텀 필터를 이용한 인증 구현 - 스프링시큐리티 설정(2)  본 포스팅은 스프링시큐리티의 전반적인 사용방법을 설명하는 포스팅은 아닙니다. 기본적인 동작구조와 별도의 인증을 도입할 때 필요한 커스텀인증필터를 작성하고 적용하는 방법을 알아봅니다.버전정보  Spring Boot v2.1.2  Spring Security v 5.1.3Spring Security 설정스프링부트를 사용한다면 application.yml에서 설정도 가능하지만 몇가지 설정만 제공하고 모든 설정을 할 수 없으므로 Configuration Class에서 하는 설정이 기본이라고 생각하시면 됩니다.Configuration Class 작성스프링시큐리티 Configuration Class를 작성하기 위해서는 WebSecurityConfigurerAdapter를 상속하여 클래스를 생성하고 @EnableWebSecurity 애노테이션을 추가합니다. (@Configuration 애노테이션 대신)@EnableWebSecuritypublic class BrmsWebSecurityConfiguration extends WebSecurityConfigurerAdapter {    /**     * 스프링시큐리티 앞단 설정들을 할 수 있다.     */    @Override    public void configure(WebSecurity web) throws Exception {        // resources 모든 접근을 허용하는 설정을 해버리면        // HttpSecurity 설정한 ADIM권한을 가진 사용자만 resources 접근가능한 설정을 무시해버린다.        web.ignoring()                .antMatchers(\"/resources/**\");    }    /**     * 스프링시큐리티의 설정을 할 수 있다.     */    @Override    public void configure(HttpSecurity http) throws Exception {        // WebSecurity에 접근 허용 설정을 해버리면 이 설정이 적용되지 않는다.        http.authorizeRequests()                .antMatchers(\"/resources/**\").hasRole(\"ADIM\") // no effect                .anyRequest().authenticated();    }}    [코드1] 스프링시큐리티 설정WebSecurity 설정  스프링시큐리티의 각종 설정은 HttpSecurity로 한다  WebSecurity 스프링시큐리티 앞단의 설정들을 하는 객체이므로 HttpSecurity 설정한 스프링시큐리티 설정이 오버라이드 되는 설정이 있는 경우도 있다.기억해야될 부분은 스프링시큐리티의 설정은 HttpSecurity 하는 것 입니다. WebSecurity 때문에 햇갈림이 발생할 수 있는 부분이기도 합니다. WebSecurity는 잠시 잊으셔도 좋습니다.HttpSecurity 설정  스프링시큐리티의 각종 설정은 HttpSecurity로 대부분 하게 됩니다.      리소스(URL) 접근 권한 설정    인증 전체 흐름에 필요한 Login, Logout 페이지 인증완료 후 페이지 인증 실패 시 이동페이지 등등 설정    인증 로직을 커스텀하기위한 커스텀 필터 설정    기타 csrf, 강제 https 호출 등등 거의 모든 스프링시큐리티의 설정  HttpSecurity는 스프링시큐리티의 거의 대부분설정을 담당하는 객체 입니다.간략한 스프링시큐리티 설정들세세한 설정 정보는 매우 방대 하기 때문에 공식 문서를 참고하기 바랍니다. 이 내용에서는 기본적인 몇가지 설정 방법들을 설명합니다.리소스(URL)의 권한한 설정특정 리소스의 접근 허용 또는 특정 권한을 가진 사용자만 접근을 가능하게 할 수 있습니다.@EnableWebSecuritypublic class BrmsWebSecurityConfiguration extends WebSecurityConfigurerAdapter {    @Override    public void configure(HttpSecurity http) throws Exception {        http.authorizeRequests()                .antMatchers(\"/login**\", \"/web-resources/**\", \"/actuator/**\").permitAll()                .antMatchers(\"/admin/**\").hasAnyRole(\"ADMIN\")                .antMatchers(\"/order/**\").hasAnyRole(\"USER\")                .anyRequest().authenticated();    }}    [코드2] 리소스의 인증 및 권한 설정antMatchers antMatchers(\"/login**\", \"/web-resources/**\", \"/actuator/**\")특정 리소스에 대해서 권한을 설정합니다.permitAllantMatchers(\"/login**\", \"/web-resources/**\", \"/actuator/**\").permitAll() antMatchers 설정한 리소스의 접근을 인증절차 없이 허용한다는 의미 입니다.hasAnyRoleantMatchers(\"/admin/**\").hasAnyRole(\"ADMIN\")리소스 admin으로 시작하는 모든 URL은 인증후 ADMIN 레벨의 권한을 가진 사용자만 접근을 허용한다는 의미입니다.anyRequestanyRequest().authenticated()모든 리소스를 의미하며 접근허용 리소스 및 인증후 특정 레벨의 권한을 가진 사용자만 접근가능한 리소스를 설정하고 그외 나머지 리소스들은 무조건 인증을 완료해야 접근이 가능하다는 의미입니다.로그인처리 설정가장 일반 적인 로그인 방식인 로그인 FORM 페이지를 이용하여 로그인하는 방식을 사용하려고 할때 여러가지 설정을 할 수 있습니다. 중요한 사실은 커스텀 필터를 적용 할때와 여러가지 설정이 중복되거나 서로 상관없는 설정이 겹치게 되어 햇갈는 부분이 있습니다.@EnableWebSecuritypublic class BrmsWebSecurityConfiguration extends WebSecurityConfigurerAdapter {    @Override    public void configure(HttpSecurity http) throws Exception {        http.formLogin()                .loginPage(\"/login-page\")                .loginProcessingUrl(\"/login-process\")                .defaultSuccessUrl(\"/main\")                .successHandler(new CustomAuthenticationSuccessHandler(\"/main\"))                .failureUrl(\"login-fail\")                .failureHandler(new CustomAuthenticationFailureHandler(\"/login-fail\"))                    }} [코드3] 로그인 폼 사용 및 설정formLogin  로그인 페이지와 기타 로그인 처리 및 성공 실패 처리를 사용하겠다는 의미 입니다.http.formLogin();  일반적인 로그인 방식 즉 로그인 폼 페이지와 로그인 처리 성공 실패 등을 사용하겠다는 의미입니다. http.formLogin() 를 호출하지 않으면완전히 로그인처리 커스텀필터를 만들고 설정하지 않는 이상 로그인 페이지 및 기타처리를 할 수 가 없습니다. 커스텀 필터를 만들면 사실상 필요 없는 경우도 있습니다.loginPage  사용자가 따로 만든 로그인 페이지를 사용하려고 할때 설정합니다.loginPage(\"/login-page\") 따로 설정하지 않으면 디폴트 URL이 “/login”이기 때문에 “/login”로 호출하면 스프링이 제공하는 기본 로그인페이지가 호출됩니다.loginProcessingUrl  로그인 즉 인증 처리를 하는 URL을 설정합니다. “/login-process” 가 호출되면 인증처리를 수행하는 필터가 호출됩니다.loginProcessingUrl(\"/login-process\") 로그인 FORM에서 아이디와 비번을 입력하고 확인을 클릭하면 “/login-process” 를 호출 하게 되었들 때 인증처리하는 필터가 호출되어 아이디 비번을 받아와 인증처리가 수행되게 됩니다. 즉 UsernamePasswordAuthenticationFilter가 실행 되게 되는 것입니다.defaultSuccessUrl  정상적으로 인증성공 했을 경우 이동하는 페이지를 설정합니다.defaultSuccessUrl(\"/main\")설정하지 않는경우 디폴트값은 “/” 입니다.successHandler  정상적인증 성공 후 별도의 처리가 필요한경우 커스텀 핸들러를 생성하여 등록할 수 있습니다.successHandler(new CustomAuthenticationSuccessHandler(\"/main\"))커스텀 핸들러를 생성하여 등록하면 인증성공 후 사용자가 추가한 로직을 수행하고 성공 페이지로 이동합니다.failureUrl  인증이 실패 했을 경우 이동하는 페이지를 설정합니다.failureUrl(\"/login-fail\")failureHandler  인증 실패 후 별도의 처리가 필요한경우 커스텀 핸들러를 생성하여 등록할 수 있습니다.successHandler(new CustomAuthenticationFailureHandler(\"/login-fail\"))커스텀 핸들러를 생성하여 등록하면 인증실패 후 사용자가 추가한 로직을 수행하고 실패 페이지로 이동합니다.커스텀 필터 등록스프링시큐리티는 각각역할에 맞는 필터들이 체인형태로 구성되서 순서에 맞게 실행되는 구조로 동작합니다. 사용자는 특정 기능의 필터를 생성하여 등록할 수 있습니다. 인증을 처리하는 기본필터 UsernamePasswordAuthenticationFilter 대신 별도의 인증 로직을 가진 필터를 생성하고 사용하고 싶을 때 아래와 같이 필터를 등록하고 사용합니다.@EnableWebSecuritypublic class BrmsWebSecurityConfiguration extends WebSecurityConfigurerAdapter {    @Override    public void configure(HttpSecurity http) throws Exception {        http.addFilterBefore(new CustomAuthenticationProcessingFilter(\"/login-process\"),                 UsernamePasswordAuthenticationFilter.class);             }} [코드4] 커스텀 필터의 추가addFilterBefore  지정된 필터 앞에 커스텀 필터를 추가 (UsernamePasswordAuthenticationFilter 보다 먼저 실행된다)addFilterAfter  지정된 필터 뒤에 커스텀 필터를 추가 (UsernamePasswordAuthenticationFilter 다음에 실행된다.)addFilterAt  지정된 필터의 순서에 커스텀 필터가 추가된다마치 지정된 필터 대신에 커스텀필터를 추가하는 것 처럼 메소드가 동작할 것 같지만 실제로는 오버라이드 되지는 않습니다.설명에는 지정된 필터의 순서와 같은 자리에 커스텀필터를 삽입한다고 되어 있고 오버라이드 되지 않는다고 설명되어 있습니다.하지만 직접테스트 결과 지정된 필터 보다 커스텀 필터가 먼저 실행되었습니다. 결론 적으로 어떤 메소드로 커스텀 필터를 추가하더라도 기존 필터가 오버라이드 되는 메소드는 없습니다. 다만 커스텀 필터가 실행 되고 인증이 완료 되었기 때문에 UsernamePasswordAuthenticationFilter 수행되면서 인증완료된 상태이면 인증 로직이 수행되지 않고 자연스럽게 통과 하기 때문에 마치 오버라이드된 것 처럼 동작하는 것으로 착각 할 수 있습니다 (직접 테스트 해봄)커스텀필터에 설정을 추가커스텀 필터에 인증 매니저 및 성공 실패 핸들러를 추가적으로 등록 및 설정을 추가 할 수 있습니다.@EnableWebSecuritypublic class BrmsWebSecurityConfiguration extends WebSecurityConfigurerAdapter {    @Bean    public CustomAuthenticationProcessingFilter customAuthenticationProcessingFilter() {        CustomAuthenticationProcessingFilter filter = new CustomAuthenticationProcessingFilter(\"/login-process\");        filter.setAuthenticationManager(new CustomAuthenticationManager());        filter.setAuthenticationFailureHandler(new CustomAuthenticationFailureHandler(\"/login\"));        filter.setAuthenticationSuccessHandler(new SimpleUrlAuthenticationSuccessHandler(\"/\"));        return filter;    }    @Override    public void configure(HttpSecurity http) throws Exception {        http.addFilterBefore(customAuthenticationProcessingFilter(),                 UsernamePasswordAuthenticationFilter.class);             }} [코드5] 커스컴 필터의 상세 설정CustomAuthenticationProcessingFilter  AbstractAuthenticationProcessingFilter 상속하여 구현하며 인증처리를 담당합니다.http.addFilterBefore(customAuthenticationProcessingFilter(),         UsernamePasswordAuthenticationFilter.class);  스프링시큐리티의 기본 인증 처리 담당 필터인 UsernamePasswordAuthenticationFilter 앞에 커스텀 필터를 추가합니다.UsernamePasswordAuthenticationFilter필터는 Override되지 않고 CustomAuthenticationProcessingFilter 인증 처리가되면 자연스럽게 로직을 통과하는 구조입니다.인증로직이 포함된 인증매니저 인증성공/실패 처리 핸들러 등등 기타 추가 설정 이나 기능을 대체 하는 의존성을 주입 할 수 있습니다.setAuthenticationManager  AuthenticationManager를 상속받아 생성하며 실제 인증로직이 포함된 커스텀 인증 매니저를 추가합니다.filter.setAuthenticationManager(new CustomAuthenticationManager());setAuthenticationFailureHandler  인증실패 핸들러를 따로 등록 할 수 있습니다. 따로 등록하지 않으면 기본 핸들러가 동작합니다.filter.setAuthenticationFailureHandler(new CustomAuthenticationFailureHandler(\"/login\"));setAuthenticationFailureHandler  인증실패 핸들러를 따로 등록 할 수 있습니다. 따로 등록하지 않으면 기본 핸들러가 동작합니다.filter.setAuthenticationFailureHandler(new CustomAuthenticationFailureHandler(\"/login\"));마무리스프링시큐리티의 기본적인 설정 방법과 커스텀 필터를 등록하는 방법을 알아 보았습니다. 설정의 세부 내용이 방대하기 때문에 공식 문서를 참고해야합니다.본 글에서는 대략적인 설정 내용을 알아 보았습니다. 다음 포스팅에는 커스텀 필터를 생성해서 사용자가 별도의 인증로직을 구현하는 커스텀 필터의 세부 내용을 알아보도록 하겠습니다.연관 글[Spring Security] 스프링시큐리티 동작구조의 이해(1) [Spring Security] 스프링시큐리티 커스텀 필터의 구현(3)",
        "url": "/programming/2020/07/02/spring-security-02/"
    }
    ,
    
    "programming-2020-07-01-spring-security-01": {
        "title": "[Spring Security] 스프링시큐리티 동작구조의 이해(1)",
            "author": "kimchanjung",
            "category": "",
            "content": "스프링시큐리티의 기본적인 동작구조와 별도의 인증을 도입할 때 필요한 커스텀 필터를 작성하고 적용하는 방법을 알아봅니다”Spring Security 커스텀 필터를 이용한 인증 구현 - 스프링시큐리티 동작구조의 이해(1)  본 포스팅은 스프링시큐리티의 전반적인 사용방법을 설명하는 포스팅은 아닙니다. 기본적인 동작구조와 별도의 인증을 도입할 때 필요한 커스텀인증필터를 작성하고 적용하는 방법을 알아봅니다.버전정보  Spring Boot v2.1.2  Spring Security v 5.1.3러닝커브가 높은 스프링시큐리티본인도 처음에 실무 프로젝트에 스프링시큐리티를 이용하여 인증을 구현하면서 느끼는 것 이지만 인증자체가 비즈니스로직처럼 매번 개발하는 부분이 아니기 때문에 익숙하지 않고 팀내에서 이미 개발되어 있는 경우에는 신규 프로젝트를 할 때 이외엔 볼일도 별로 없는 부분이기도 합니다.  스프링시큐리티는 인증과 권한등의 많은 기능을 편리하게 적용할 수 있도록 도와 주는 라이브러리이지만 사용법은 결코 만만하지 않다는 느낌을 받습니다. 스프링과 JAVA공식 문서들이 그렇지만 방대한 내용과 설명이 많아 학습하는 것도 쉽지 않습니다. (요즘 React나 Vue같은 프론트엔드 공식문서는 너무도 잘되어 있는 최근 추세에 비해서)가장 먼저 학습 해야하는 부분일단 공식 문서를 처음부터 정독하거나, 튜토리얼을 보는 것도 좋지만 가장 먼저 스프링시큐리티의 동작 구조를 먼저 이해하는 것이 나중에 학습 + 개발의 리소스를 줄여주는 방법이라고 생각합니다.  스프링시큐리티의 동작 구조를 이해하면 설정과 추가적인 구현 및 변경이 어느 부분에 적용되어야 되는지 파악이 빨라 집니다.스프링시큐리티의 동작 구조  스프링시큐리티는 각각의 역할에 맞는 작업을 처리하는 여러개의 필터들이 체인형태로 구성되어 순서에 따라 순차적으로 수행됩니다.그 중 UsernamePasswordAuthenticationFilter가 인증처리를 담당하고 있습니다.Spring Security Flow Communication Diagram[그림1] 스프링시큐리티 동작구조1. 로그인정보를 담아 서버에 인증을 요청한다. 1: doFilter(request: HttpServletRequest, response: HttpServletResponse)브라우저의 로그인화면에서 아이디와 비번을 입력하고 확인을 누르면 서버에 로그인 인증 요청을 하게 되고 스프링시큐리티에 Chain형태로 구성된 Filter들의 doFilter메소드들이 순서에 따라 호출되어 각각의 역할로직들이 수행되게 됩니다.2. 인증 처리 담당하는 UsernamePasswordAuthenticationFilter가 실행된다.2: attemptAuthentication(request: HttpServletRequest, response: HttpServletResponse):Authentication    AbstractAuthenticationProcessingFilter 추상 클래스의 추상메소드 attemptAuthentication를 호출하여 요청을 처리하게 됩니다. attemptAuthentication추상메소드의 구현은 상속한 UsernamePasswordAuthenticationFilter에 구현 되어 있습니다.  추후 외부인증을 위한 작업을 할때 UsernamePasswordAuthenticationFilter기능을 대신하는 커스텀 필터를 추가하게 됩니다.  인증 성공 실패에 따라 AuthenticationSuccessHandler, AuthenticationFailureHandler 를 최종적으로 호출하게 됩니다.  인증이 성공했다면 리턴값 UsernamePasswordAuthenticationToken를 세션에 저장합니다3. AuthenticationManager가 적절한 AuthenticationProvider를 찾는다. 3: authenticate(authRequest):Authentication    AuthenticationManager는 인터페이스이며 구현체는 ProviderManager입니다. ProviderManager는 실제 인증을 처리하는 로직이 포함된 AuthenticationProvider 인터페이스의 구현체들 중에 설정된 인증 처리방식의 구현체를 찾아 실행합니다.4. 실제 인증처리하는 AuthenticationProvider의 인증처리 메소드를 호출한다.4: authenticate(authRequest):Authentication   일반적으로 클라이언트에서 아이디 비번을 받아 인증하는 방식을 사용한다면 AuthenticationProvider 인터페이스의 구현체 AbstractUserDetailsAuthenticationProvider 추상클래스를 호출하게 되고 실제 상속한 클래스의 DaoAuthenticationProvider에서 인증 처리를 하게 됩니다.5. 인증제공자는 UserDetailsService를 호출하여 사용자를 가져온다.5: loadUserByUsername(username:String):UserDetails  개발자는 UserDetailsService 인터페이스를 구현해야합니다. UserDetailsService의 구현체에는 일반적으로 회원정보가 DB에 있다고 한다면 사용자의 이름(ID)로 DB를 조회하여 비밀번호가 일치하는지 확인하여 인증을 처리합니다. 인증이 완료되면 UsernamePasswordAuthenticationToken에 회원정보를 담아 리턴하게 됩니다.마무리인증을 구현하기 앞서 스프링시큐리티의 대략적인 동작구조를 알아보았습니다. 다음 포스팅에서는 본격적으로 어떤 부분을 커스텀해야 하는지에 대해 알아 보도록 하겠습니다.연관 글[Spring Security] 스프링시큐리티 설정값들의 역할과 설정방법(2)[Spring Security] 스프링시큐리티 커스텀 필터의 구현(3)",
        "url": "/programming/2020/07/01/spring-security-01/"
    }
    ,
    
    "programming-2020-06-28-spring-jpa-antity-listner-autowired-not-working": {
        "title": "[Spring] JPA EntityListeners에서 @Autowired를 통한 의존성 주입이 미동작하는 문제 해결",
            "author": "kimchanjung",
            "category": "",
            "content": "@EntityListeners로 지정한 클래스에 의존성이 필요한 경우 @autowired를 통한 의존성 주입이 동작하지 않는 문제가 있습니다 설명과 예제를 통하여 원인과 해결방법을 알아보도록 하겠습니다JPA EntityListeners에서 @Autowired를 통한 의존성 주입이 미동작하는 문제 해결JPA Entity 클래스에 @EntityListeners 추가 하여 엔티티의 CRUD가 일어날때 로그를 남긴다던가 하는 추가 작업을 선언하여 코드 중복을 줄일 수 있습니다.하지만 @EntityListeners로 지정한 클래스에 의존성이 필요한 경우 @autowired를 통한 의존성 주입이 동작하지 않는 문제가 있습니다. 설명과 예제를 통하여 원인과 해결방법을 알아보도록 하겠습니다.Entity 클래스Rider 엔티티 클래스에 @EntityListeners로 CRUD이벤트를 처리할 listner 클래스를 등록합니다.@Getter@EntityListeners(RiderEntityListener.class)public class Rider {    @Id    private String id;    @Column(unique = true, nullable = false)    private String userId;    ...}  @EntityListeners로 지정된 RiderEntityListener 클래스에 CRUD 해당하는 액션이 일어 날때 추가 작업을 정의할 수 있다.RiderEntityListener 클래스Rider 엔티티 CRUD이벤트를 처리하는 RiderEntityListener에 스냅샷을 저장하는 RiderLog 앤티티를 생성하고 저장하기위해 RiderLogRepository의 의존성을 추가합니다. Rider엔티티를 조작하는 코드마다 로그를 남기는 코드의 중복을 제거할 용도로 사용할 수 있습니다.public class RiderEntityListener {    private RiderLogRepository riderLogRepository;    @Autowired    public RiderEntityListener(RiderLogRepository riderLogRepository) {        this.riderLogRepository = riderLogRepository;    }    /**     * INSERT 이후 호출됨     * @param riderAccount     */    @PostPersist    public void postPersist(Rider rider) {       riderLogRepository.save(new RiderLog(rider));    }    /**     * UPDATE 완료 후 호출     * @param riderAccount     */    @PostUpdate    public void postUpdate(Rider rider) {        riderLogRepository.save(new RiderLog(rider));    }    ...}  RiderLogRepository 클래스를 @Autowired를 통한 DI를 했지만 NPE가 발생합니다. 즉 DI가 되지 않았던 것 입니다.RiderLogRepository가 DI 되지 않았던 이유EntityListeners로 등록한 클래스는 Spring IOC 컨테이너의 관리 대상이 아닙니다. 그렇기 때문에 스프링 애플리케이션이 실행되는 과정에서 빈이 생성되고 등록되는 중에 EntityListeners로 등록한 클래스가 먼저 생성 되었을 수 있습니다. 즉 의존성 빈과 EntityListeners로 등록한 클래스가 생성되는 시점이 서로 다른 것입니다.타이밍이 잘 맞으면 의존성이 주입되어 있지만 그렇지 않으면 null인경우가 발생하는 것 입니다.Spring ApplicationEvent를 통해서 분리하여 해결하는 법이 문제와 관련하여 구글링을 해보면 몇 가지 해결 방법을 찾을 수 있습니다. static 변수지정하여 DI한다거나 애플케이션컨텍스트내에서 빈을 찾아 등록한다거나 약간은 매끄럽지 못한 방법으로 해결하는 방법을 재시합니다.하지만 저는 개인적으로 ApplicationEvent를 통하여 event pub/sub 구조로 한번더 분리하여 해결하는 방법을 추천합니다.Rider 엔티티 변경 이벤트를 정의@Getterpublic class RiderEntityEvent extends ApplicationEvent {    private Rider rider    public RiderEntityEvent(Rider rider) {        super(rider);        this.rider = rider;    }}Rider 엔티티 변경 이벤트 발행ApplicationEvent 이용하여 event를 발행합니다. ApplicationEventPublisher가 @Autowired DI되는 이유는 repository나 service 처럼 사용자가 생성한 빈이 아니라 스프링이 제공하는 이미 등록된 기능의 빈이기 때문에 RiderEntityListener가 생성시 이미 ApplicationEventPublisher는 존재하기 때문입니다.public class RiderEntityListener {    private ApplicationEventPublisher applicationEventPublisher;    @Autowired    public RiderEntityListener(ApplicationEventPublisher applicationEventPublisher) {        this.applicationEventPublisher = applicationEventPublisher;    }    /**     * INSERT 이후 호출됨     * @param riderAccount     */    @PostPersist    public void postPersist(Rider rider) {        applicationEventPublisher.publishEvent(new RiderEntityEvent(rider);    }    /**     * UPDATE 완료 후 호출     * @param riderAccount     */    @PostUpdate    public void postUpdate(Rider rider) {        applicationEventPublisher.publishEvent(new RiderEntityEvent(rider);    }    ...}  각 메소드에 이벤트를 발행하는 코드만 생성합니다.이렇게 이벤트만 발행 하도록 함으로써 추후 이 이벤트를 구독하여 로그를 남긴다거나 이메일을 보낸다거나 기타 여러가지 작업을 pub/sub형태로 개별적으로 코드를 분리하여 작성가능하므로 더 낳은 구조라고 생각합니다.위 방법이 아니라면 아마도 이런 구조public class RiderEntityListener {    ...    @PostPersist    public void postPersist(Rider rider) {       로그저저장하기()       이메일발송하기()       외부API호출하기()       //계속적인 코드추가...    }    ...  postPersist 메소드에 수많은 기능이 추가 되겠네요….발행된 이벤트를 구독하는 클래스RiderEntityEvent를 구독하여 처리하는 다수의 핸들러 클래스를 정의하고 사용합니다.// 스냅샷 저장 @Componentpublic class RiderEntityLogEventHandlerImpl implements RiderEntityLogEventHandler {    @Autowired    private RiderLogRepository riderLogRepository;    @Override    @EventListener    public void handle(RiderEntityEvent event) {        riderLogRepository.save(event.getRider())    }}// 이메일발송@Componentpublic class RiderSendEmailHandlerImpl implements RiderSendEmailHandler {    @Autowired    private EmailService emailService;    @Override    @EventListener    public void handle(RiderEntityEvent event) {        emailService.send(event.getRider())    }}  이벤트를 구독하여 처리하는 클래스를 계속적으로 추가할 수 있습니다.마무리@EntityListeners에 등록한 클래스는 스프링의 관리영역이 아니기 때문에 사용자가 생성한 빈을 사용할 때는 null 값이 되는 경우가 있습니다.하지만 ApplicationEventPublisher를 사용하여 스프링 이벤트 발생/구독 모델로 분리하고 정상적으로 사용자가 생성한 스프링빈을 사용할 수 있는 방법을 알아 보았습니다.",
        "url": "/programming/2020/06/28/spring-jpa-antity-listner-autowired-not-working/"
    }
    ,
    
    "programming-2020-06-26-react-spinner": {
        "title": "[React] 로딩처리용 spinner를 사용시 position 옵션 문제를 Portal을 사용해 해결하는 방법",
            "author": "kimchanjung",
            "category": "",
            "content": "NPM react용 Spinner 모듈을 가져와 사용할 때 발생하는 position 옵션 문제를 Portal을 이용해 해결하고 깔끔한 방식으로 사용할 수 있는 방법을 알아봅니다API호출시 보통 로딩을 처리하는 동안 Spinner를 표시해서 로딩처리를 사용자에게 알리는 용도로 많이 사용됩니다. NPM에서 React용 Spinner를 찾아보면 수많은 종류의 로딩처리 Spinner 모듈들이 존재합니다. 기능이나 디자인도 수없이 다양합니다. NPM 대부분의 Spinner 모듈이 다양한 방식으로 사용하고자 할때 몇가지 문제점이 있었습니다.이번 포스팅은 Spinner 모듈을 가져와 사용할 때 발생하는 문제점을 해결하고 깔끔한 방식으로 사용할 수 있는 방법을 알아봅니다.사용 모듈 버전정보  react-loader v2.4.5  react-portal v4.1.5Modal이나 Dialog 사용시 Spinner의 위치 설정문제대부분의 NPM에서 React용 모듈을 사용하는 방법은 모듈을 import하고 컴포넌트를 삽입하는 방법입니다.React 컴포넌트의 부모자식 구조컴포넌트를 삽입하면 실제 렌더링된 DOM의 형태도 마찬가지로 해당 부모자식 DOM 엘리먼트 구조로 렌더링 됩니다.NPM React용 Spinner모듈들이 대부분 컴포넌트를 삽입하는 방식입니다(제가 찾은 모듈은 대부분) 결국은 Spinner 모듈도 id=”app”인 div 하위 어딘가에 포홤된다는 이야기가 됩니다. 하지만 Modal의 경우는 보통 전체화면의 메인이 되는 영역밖에 생성되는 것이 보통합니다.class App extends React.Component {  render() {    return (      &lt;div id=\"app\"&gt;          &lt;Loader /&gt;        &lt;Search  /&gt;        &lt;UserPages /&gt;      &lt;/div&gt;    );  }} class Search extends React.Component {  render() {    return (      &lt;form&gt;          &lt;input id=\"address\" name=\"address\" .... /&gt;        &lt;input id=\"phone\" name=\"phone\" .... /&gt;        ...      &lt;/form&gt;    );  }} class UserPages extends React.Component {  render() {    return (      &lt;div&gt;          &lt;UserList /&gt;        &lt;Pager/&gt;        ...      &lt;/div&gt;    );  }}React 컴포넌트가 랜더링된 결과&lt;div id=\"app\"&gt;  &lt;div id=\"spinner\"&gt;    로딩 스피너 관련 엘리먼트들이 위치하는 곳  &lt;/div&gt;  &lt;form&gt;    &lt;input id=\"address\" name=\"address\" .... /&gt;    &lt;input id=\"phone\" name=\"phone\" .... /&gt;    ...  &lt;/form&gt;  &lt;div&gt;      &lt;table&gt;     ~~~~    &lt;/table&gt;    &lt;div&gt;      &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;2&lt;/span&gt;      &lt;span&gt;3&lt;/span&gt;      &lt;span&gt;next&lt;/span&gt;    &lt;div&gt;  &lt;/div&gt;&lt;/div&gt;React에서 Modal의 사용과 렌더링된 결과Modal 컴포넌트를 분명 UserPage 컴포넌트에 삽입하여 사용했는데도 불구하고 실제 렌더링은 root 엘리먼트 밖에 생성이 되는 결과를 가져왔습니다. 포지션이나 스크롤 기타 여러 style설정과 관련하여 전체 화면밖에 생성되는 것이 일반적입니다.class UserPage extends React.Component {  render() {    return (      &lt;div&gt;          &lt;UserList /&gt;        &lt;Pager/&gt;        &lt;Modal /&gt;       &lt;/div&gt;    );  }}&lt;div id=\"app\"&gt;  &lt;div id=\"spinner\"&gt;    로딩 스피너 관련 엘리먼트들이 위치하는 곳  &lt;/div&gt;  &lt;form&gt;    &lt;input id=\"address\" name=\"address\" .... /&gt;    &lt;input id=\"phone\" name=\"phone\" .... /&gt;  &lt;/form&gt;  &lt;div&gt;      &lt;table&gt;      사용자리스트    &lt;/table&gt;    &lt;div&gt;      &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;2&lt;/span&gt;      &lt;span&gt;3&lt;/span&gt;      &lt;span&gt;next&lt;/span&gt;    &lt;div&gt;    // 이자리에 modal이 렌더링되어야할 위치 같지만 실제는 밖에 생성됩니다.  &lt;/div&gt;&lt;/div&gt;// 대부분 modal의 경우 포지션이나 설정이나 기타 그런 것 들 때문에 // 전체 페이지 영역밖에 생성되는 경우가 일반적입니다.&lt;div id=\"modal\"&gt;  &lt;div&gt;    모달이 생성되는 곳  &lt;/div&gt;&lt;/div&gt;  modal에서 spinner사용할때 spinner가 modal 내부에 포함어 있지않아서 position 관련 style을 제대로 조작하기 어렵게 됩니다.modal 중앙에 표시되어야 하는데 전체 화면 중심에 표시된다거나 스크롤이 되더라도 spinner는 고정되어야 하는데 같이 스크롤된다거나 하는 설정이 제대로 동작하지 못하게 되는 것이 가장 큰 문제점입니다.React용 Spinner 모듈을 사용하는 간단한 예import Loader from 'react-loader';class UserPage extends React.Component {  render() {    return (      &lt;&gt;          &lt;Loader loaded={this.state.loaded} /&gt;        &lt;UserPageTemplate model={this.state.profile} /&gt;      &lt;/&gt;    );  }}                  렌더링하는 컴포넌트에 Loader 컴포넌트를 가져와서 사용하는 방식입니다.    이런 경우 일일히 모든 페이지에 Loader 가져와서 사용해야합니다.  그러나 한곳에만 Loader를 포함시켜놓고 코드 중복없이 사용하고 싶습니다.App 컴포넌트// Loader 컴포넌트를 포함시킨다.@inject('store')@observerclass App extends React.Component {  render() {    return (      &lt;&gt;        &lt;Loader loaded={this.props.store.isLoadingSpinner} /&gt;        &lt;UserPage /&gt;        &lt;OrderPage /&gt;        &lt;AccountPage /&gt;      &lt;/&gt;    );  }}  User 페이지 컴포넌트// 개별페이지들은 Store의 값을 컨트롤하여 Spinner를 조작한다.// 개별페이지들은 일일히 Spinner 모듈을 가져와 사용할 필요 없어져서 중복이 제거 되었다.@inject('store')@observerclass UserPage extends React.Component {  componentDidMount() {    this.props.store.visibleSpinner(true);  }  render() {    return (      &lt;&gt;          &lt;UserPageTemplate model={this.state.profile} /&gt;      &lt;/&gt;    );  }}Store를 통한 Spinner 사용// 스토어는 Mobx를 예로 들었습니다.class Store {  @observable    isLoadingSpinner = false;  @action  visibleSpinner(value) {    this.isLoadingSpinner = value;  }}   일일이 개별페이지에서 가져다 사용하는 것이 아니라 상단 컴포넌트에 한 곳에만 Loader를 지정해두고 각각의 페이지는 state관리 라이브러리를 사용하여 store에 선언된 state를 조작하여 Spinner 모듈을 컨트롤하여 사용하도록 합니다.Modal이나 Dialog는 최상의 엘리먼트 밖에 생성됩니다App 컴포넌트// App.js@inject('store')@observerclass App extends React.Component {  render() {    return (      &lt;&gt;        &lt;Loader loaded={this.props.store.isLoadingSpinner} /&gt;        &lt;UserPage /&gt;        &lt;OrderPage /&gt;        &lt;AccountPage /&gt;      &lt;/&gt;    );  }}  // index.jsReactDOM.render(&lt;App /&gt;, document.getElementById('root'));모달이 생성되는 위치&lt;body&gt;  &lt;div id=\"root\"&gt;    // 실제 페이지를 구성하는 html등이 위치한다.    &lt;div id=\"spinner\" style=\"......\"&gt;        // 로딩 스피너는 여기에 포함된다.    &lt;/div&gt;  &lt;/div&gt;  &lt;div id=\"modal\"&gt;    // 모달을 구성하는 html등이 위치한다.  &lt;/div&gt;&lt;/body&gt;      React App은 id=”root” 엘리먼트 하위에 생성됩니다.    Modal은 App밖에 생성됩니다.    이런경우 공통으로 사용하기 위한 Spinner는 모달에서 사용할 때 모달엘리먼트 상위나 하위에 포함된 것이 아니라서 위치나 포지션 설정시 원하는 위치에 설정하기 불가능한 상황이 발생합니다.  React Portal을 이용하여 Spinner 모듈 컴포넌트를 App밖에 생성Portal을 이용하여 특정 엘리먼트에 Spinner를 동적으로 위치시키는 컴포넌트// SpinJsLoader.jsimport { Portal } from 'react-portal';export default function SpinnerLoader(props) {  // containerName은 Spinner를 추가하고 싶은 특정 엘리먼트의 클래스네임입니다.  const { isLoading, containerName } = props;  return (    &lt;Portal node={document.getElementsByClassName(containerName)[0]}&gt;      &lt;Loader        className=\"spinner\"        loaded={!isLoading}      /&gt;    &lt;/Portal&gt;  );}      여기서는 React Portal을 간단하게 사용하게 해주는 NPM모듈을 사용하였습니다.    Spinner(Loader) 모듈은 이제 특정 클래스명을 가진 엘리먼트에 동적으로 추가되록 구성되었습니다.    결국은 $(‘.app-root’).append(‘&lt;div id='spinner' style='....'&gt;…&lt;/div&gt;’); 와 같은 기능입니다.  App 컴포넌트에 추가import { SpinJsLoader } from 'SpinJsLoader';class App extends React.Component {  render() {    return (      &lt;&gt;        &lt;SpinnerLoader           isLoading={this.props.store.isLoading}          container={this.props.store.containerName}        /&gt;        &lt;UserPage /&gt;        &lt;OrderPage /&gt;        &lt;Modal /&gt;      &lt;/&gt;    );  }} Store를 통한 Spinner 사용// 스토어는 Mobx를 예로 들었습니다.class Store {  @observable    isLoading = false;  @observable  containerName;    // spinner를 사용할 때는 표시여부와 spinner가 위치할 엘리먼트의 클래스명을 지정합니다.  @action  visibleSpinner(isLoading, containerName) {    this.isLoading = isLoading;    this.containerName = containerName;  }} 개별 컴포넌트들은 상황에 맞게 Spinner를 조작// 사용자 페이지 컴포넌트@inject('store')@observerclass UserPage extends React.Component {  componentDidMount() {    this.props.store.visibleSpinner(true, 'app-root');  }  render() {    return (      &lt;&gt;          &lt;UserPageTemplate model={this.state.profile} /&gt;      &lt;/&gt;    );  }}// 검색용 모달 컴포넌트@inject('store')@observerclass Modal extends React.Component {  componentDidMount() {    this.props.store.visibleSpinner(true, 'search-modal');  }  render() {    return (      &lt;&gt;          &lt;ModalTemplate model={this.state.profile} /&gt;      &lt;/&gt;    );  }}      각각의 컴포넌트나 모달은 Spinner를 사용할 때 Spinner를 위치시킬 엘리먼트의 class명을 함께 지정합니다.    Spinner는 생성될때 지정된 class 하위에 생성됩니다.    App밖에 생성되는 Modal하위에도 Spinner는 생성됩니다.    Spinner의 position 즉 absolute, fixed 설정이 Modal을 기준으로 위치할 수 있게 됩니다.    애초에 App 내부에 포함하여 사용하는 방식이면 Modal에서 position 설정의 기준이 다르기 때문에 맞지않게 되는 문제가 발생하지만 Portal을 이용하여 동적으로 Spinner를 위치 시키므로써 가능해 졌습니다.  API호출시에 자동으로 Spinner가 로딩 되도록 하는 팁import axios from 'axios';import { store } from 'stores';class AxiosConfig {  initInterceptor() {    const { contentRootStore } = rootStore;    axios.interceptors.request.use(      (config) =&gt; {        // API 호출시 Spinner 표시         store.visibleSpinner(true);        return config;      },      error =&gt; Promise.reject(error),    );    axios.interceptors.response.use(      (response) =&gt; {         // API 완료시 Spinner 제거          store.visibleSpinner(false);        return response;      },      error =&gt; Promise.reject(error).catch((err) =&gt; {         // API 오류시 Spinner 제거          store.visibleSpinner(false);        return response;      }),    );  }}  axios(http 호출 모듈)를 사용한다면 API 호출시 Spinner를 표시하고 완료시 제거하는 store의 메소드를 호출하는 코드를 넣어두면 개별 페이지에서 Spinner 호출 코드를 제거하여 중복을 줄일 수 있다.마무리Spinner모듈을 Modal과 일반 페이지 둘다 position 설정이 가능하도록 Portal을 이용하여 구현하는 방법을 알아 보았습니다.",
        "url": "/programming/2020/06/26/react-spinner/"
    }
    ,
    
    "programming-2020-06-25-react-scroll-top": {
        "title": "[React] 페이지 이동시 스크롤을 상단으로 초기화 하는 방법(scroll top)",
            "author": "kimchanjung",
            "category": "",
            "content": "React로 개발 하다보면 기본 매카니즘이 상태란 것 남아 있기 때문에 나는 분명 다른페이지로 이동 했는데도 새로 고침을 하였는데도 불구하고 이전의 스크롤위치로 페이지가 나타나는 현상이 있습니다.[React] 페이지 이동시 스크롤을 상단으로 초기화 하는 방법(scroll top)  아니러니 하게도 React로 개발 하다보면 기본 매카니즘이 상태란 것 남아 있기 때문에 나는 분명 다른페이지로 이동 했는데도 새로 고침을 하였는데도 불구하고 이전의 스크롤위치로 페이지가 나타나는 현상이 있습니다.사실은 이런 장점 때문에 SPA없이 개발하던 방식은 검색값들을 유지하기 위해서 페이지 이동시 마다 query string을 url에 포함시켜 가지고 다니는 번거로운 작업을 했던 것에 비하면 React에서 상태가 남아 있는 것은 이런 작업이 필요없는 편리한 장점이 있습니다.하지만 스크롤의 경우에는 페이지를 왔다갔다 하는 사이에도 페이지 스크롤위치가 엉뚱하게 중간즘이나 아래에 있는 경우가 나타다 당황스러웠던 기억이 납니다. 본 포스팅에서 페이지 이동시 스크롤을 상단에 위치하는 방법을 알아봅니다.페이지를 확인하여 Scroll을 상단으로 이동시키는 컴포넌트 작성class ScrollToTop extends React.Component {    getSnapshotBeforeUpdate(prevProps, prevState) {    const { location = {} } = prevProps;    // 컴포넌트 업데이트 시 페이지 이동인지 확인    if (this.props.location.pathname !== location.pathname) {      window.scrollTo(0, 0);    }  }    render() {    return this.props.children;  }}export default ScrollToTop;      getSnapshotBeforeUpdate 메소드에서 매번 업데이트가 발생 할 때 마다 현제 페이지와 이전페이지를 비교하여 같은 페이지가 아니라면 즉 페이지 이동이 있었다면 스크롤을 상단으로 이동시킵니다.    페이지비교 조건이 없으면 해당페이지에서 무엇인가 업데이트가 발생할 때 마다 스크롤이 이동되어 버리니 꼭 필요한 조건입니다.  this.props.children에 대한 설명  단순히 스크롤이동 처리만하는 컴포넌트이므로 실제 동작하는 페이지 상위에 위치합니다.  실제 페이지가 구현된 하위 컴포넌트는 this.props.children props에 있습니다.  스크롤처리를 하고 단순히 하위 컴포넌트는 그대로 렌더링합니다.생성한 ScrollTop 컴포넌트를 적용한다.import ScrollToTop from './ScrollToTop';class ContentRoot extends React.Component {  render() {    return (      &lt;Router history={history}&gt;        &lt;ScrollToTop&gt;          &lt;UserPage /&gt;        &lt;/ScrollToTop&gt;      &lt;/Router&gt;    );  }}export default ContentRoot;      ScrollToTop 컴포넌트를 실제 페이지를 구성하는 페이지 상단에 위치 시킵니다.    ScrollToTop은 페이지 정보를 사용해야 하므로 react-router의 라우팅 설정 컴포넌트의 하위에 위치해야합니다.    Router(라우팅관련 정보 설정) &gt; ScrollTop(페이지명을 받아옴) &gt; UserPage(실제페이지는 렌더링)  마무리실제 동작페이지 컴포넌트와 라우팅설정컴포넌트 사이에 스크롤상단처리컴포넌트를 추가하여 페이지 이동시 스크롤을 상단으로 초기화 하는 방법을 알아보았습니다.",
        "url": "/programming/2020/06/25/react-scroll-top/"
    }
    ,
    
    "programming-2020-06-25-spring-gradle-build-with-front-end": {
        "title": "[Gradle] node yarn 빌드 react 프로젝트를 gradle에 통합 포함하여 빌드하는 방법",
            "author": "kimchanjung",
            "category": "",
            "content": "스프링 프로젝트를 빌드할 때 백엔드 API + 프론트엔드 구성의 프로젝트 빌드시 node yarn을 사용하여 빌드하는 프론트엔드 빌드를 Gradle 빌드에 포함하여 빌드하는 방법을 알아 봅니다.Yarn 빌드 React 프로젝트를 Spring 프로젝트 Gradle 빌드에 통합하여 빌드하는 방법  스프링 프로젝트를 빌드할 때 백엔드 API + 프론트엔드 구성의 프로젝트 빌드시 yarn을 사용하여 빌드하는 프론트엔드 빌드를 Gradle 빌드에 포함하여 빌드하는 방법을 알아 봅니다.벡엔드 API와 프론트엔드의 일반적인 구성보통 Java Spring 백엔드 API와 React나 Vue를 사용한 프론트엔드로 구성된 프로젝트에서는 Spring 벡엔드 API 서버 프로젝트의 resources 폴더에 빌드가 완료된 javascript 프론트엔드의 static 파일을 복사하여 포함 시켜 빌드를 하는 것이 일반적인 방식이라면 프론트엔드 빌드 과정을 따로하지 않고 백엔드 API 서버 빌드에 통합하는 방법을 설명합니다.적용 버전 정보  Java v1.8  Spring-Boot v2.1.2  Gradle v4.7  gradle-node-plugin v1.2.0Node 플러그인 의존성추가buildscript {    ext {        springBootVersion = '2.1.2.RELEASE'        .....    }    repositories {        mavenCentral()        maven { url \"https://plugins.gradle.org/m2\"}    }    dependencies {        // node사용 할 수 있는 플러그인의 의존성을 추가합니다.        classpath(\"com.moowork.gradle:gradle-node-plugin:1.2.0\")    }}  gradle-node-plugin 의존성을 추가합니다.build.gradle에 node 및 yarn 설치 명령을 추가// build.graldeconfigure(nodeProjects) {    // gradle에서 node명령을 사용하게 해주는 플러그인 사용을 추가합니다.    apply plugin: 'com.moowork.node'    node {        version = '10.15.1' // 설치할 node 버전        yarnVersion = '1.13.0' // 설치할 yarn 버전        download = true        distBaseUrl = 'https://nodejs.org/dist' // node를 다운받을 수 있는 주소        workDir = file(\"${project.rootDir}/nodejs\") // node를 설치할 폴더를 설정        yarnWorkDir = file(\"${project.rootDir}/yarn\") // yarn을 설치할 폴더를 설정    }    // yarn install 즉 package.json에 추가된 의존 모듈을 설치하는 명령을 설정    task yarnInstallProduction(type: YarnTask) {        args = ['install']    }    // node와 yarn을 설치하고 yarn install 명령을 하나의 테스크로 묶었다.    task nodeModuleInstall {        doLast {            nodeSetup.execute() // node를 설치            yarnSetup.execute() // yarn을 설치            yarnInstallProduction.execute() // package.json에 추가된 의존 모듈을 설치(yarn install)        }    }}  Gradle 설정 파일에서 node와 yarn을 사용하기 위한 기본 설정을 추가합니다.프론트빌드를 위한 설정을 추가합니다.// 백엔드 api 서버 설정 부분project(\":api-server\") {        dependencies {        compile ('org.springframework.boot:spring-boot-starter-actuator')           ....                          }    // 프론트엔드 프로젝트의 실제위치를 설정한다.    node {        nodeModulesDir = file(\"${rootDir}/front-end/\")    }    // 프로젝트 빌드 명령을 설정한다    // yran build 명령을 실행하는 것    // 이렇게 되면 프론트엔드 프로젝트가 빌드된다.    task yarnBuild(type: YarnTask) {        args = ['run', \"build\"]    }        // 빌드된 프론트엔드 파일을 백엔드 API서버 resources에 복사한다.    task copyDistToStatic(type: Copy) {        // 빌드된 프론트엔드의 파일 위치        from(\"${rootDir}/front-end/build/\")         // 백엔드 API 서버의 static 리소스로 복사할 위치        into(\"${project.projectDir}/src/main/resources/static/\")        includeEmptyDirs = true    }        // gralde 빌드시 사용하는 task 프론트엔드 빌드와 복사까지 전과정을 수행한다    // nodejs 설치 -&gt; yarn 설치 -&gt; node_modules 다운로드 -&gt; front-end source 빌드 -&gt; resource/static 복사    // ./gradlew ~~~~~~~:frontEndBuild &lt;= 빌드시 task 명을 포함시켜 빌드     task frontEndBuild {        doLast {            nodeModuleInstall.execute()            yarnBuild.execute()            copyDistToStatic.execute()        }    }}  프로젝트 빌드시 프론트엔드빌드 task를 추가하고 빌드 프로세스에 포함 시키는 설정을 추가합니다.주의Gradle task 설정을 추가 할때는 프론트엔드 빌드 task가 완전히 완료된 후 java 빌드가 수행되도록 되어야 합니다. 그렇지 않으면 프론트빌드가 완료되기 전에 java 빌드가 되기 때문에 프론트 파일이 미포함되는 경우가 발생하기 때문에 주의 해야합니다.마무리Spring 프로젝트 Gradle 빌드에 프론트엔드 빌드를 통합하여 빌드하는 방법을 알아 보았습니다. 더 좋은 방법이 있으면 코멘트 남겨주세요",
        "url": "/programming/2020/06/25/spring-gradle-build-with-front-end/"
    }
    ,
    
    "programming-2020-06-24-react-router-private-router": {
        "title": "[React] react-router에서 인증 및 권한 Router(Private) 구현하기(권한별 routing)",
            "author": "kimchanjung",
            "category": "",
            "content": "react-router의 url 권한을 체크하여 routing 이 가능하도록 하고 권한이 없으면 권한이 없다는 페이지로 redirect하는 방법을 알아보고자 합니다react-router 에서 Private Router 구현하기(권한별 routing)실무에서 페이지를 개발할 때 인증 및 부여된 권한 등급에 따라서 메뉴의 노출 및 접근이 제한 되도록 구성하는것이 일반적입니다. react-router 라이브러리는 routing을 구현하는 라이브러리인데 뭔가 라이브러리 차원에서 권한별 라우팅을 쌈박한 방법으로 지원해 줄 것이라는 기대와 달리 뭔가 복잡하게 구현하는 예제만 제공되고 있었습니다.  본 포스팅에서 권한을 체크하여 routing 이 가능하도록 하고 권한이 없으면 권한이 없다는 페이지로 redirect하는 방법을 알아보고자 합니다.권한을 체크하는 Router Component 생성import { Route, Redirect } from 'react-router';const PrivateRoute = ({component: Component, ...parentProps}) =&gt; {  return (    &lt;Route      {...parentProps}      render={props =&gt; (        checkAuth() ? (         &lt;Component {...props} parentMenu={this.props.menu} /&gt;        ) : (         &lt;Redirect to=\"/403\" /&gt;        )      )}    /&gt;  );}  Route 컴포넌트가 호출되기 전에 권한 체크를 한다음 권한이 있으면 지정된 컴포넌트(페이지)를 호출 하고 권한이 없다면 권한없음을 안내하는 페이지로 redirect 시킵니다.parentProps의 설명부모 컴포넌트로 부터 넘겨 받은 props에서 Component를 제외한 나머지 props를 parentProps에 모두 담습니다.// parentProps로 받아온 나머지 props를 스프레드 문법으로 풀어주면&lt;Route {...parentProps} /&gt;  // 사실상 아래 처럼 되는 것과 같습니다.&lt;Route exact path=\"/users\" .... /&gt;  parentProps는 exact path=”/users” 같은 react-router의 Route 컴포넌트를 사용할때 제공하는 설정 값들을 넘겨받아서 {…parentProps} 와 같이 스프레드 문법으로 그대로 설정해주기 위함입니다.권한을 체크하는 커스텀 Private Router를 사용import PrivateRoute from './PrivateRoute';class Routers extends React.Component {  constructor(props) {    super(props);  }  render() {    return (      &lt;React.Fragment&gt;        // Route 컴포넌트의 사용방식과 동일하게 사용하면 된다.        &lt;PrivateRoute exact path=\"/rider-management\" component={RiderManagement}/&gt;        &lt;PrivateRoute exact path=\"/common-management\" component={CommonManagement} /&gt;      &lt;/React.Fragment&gt;    );  }}export default Routers;  권한 체크 기능이 추가된 react-router Route 컴포넌트를 래핑한 PrivateRouter를 사용하도록 하여 router를 구성한다.마무리권한 체크기능이 추가된 Private Router는 react-router의 Router에 컴포넌트를 호출할 때 간단한 분기처리가 추가된 방법으로 간단하게 구현해 보았습니다.",
        "url": "/programming/2020/06/24/react-router-private-router/"
    }
    ,
    
    "programming-2020-06-24-react-mobx-async-action": {
        "title": "[React] Mobx의 async action(비동기 액션) 처리를 mobx-utils를 이용하여 가장 깔끔하게 구현하는 방법",
            "author": "kimchanjung",
            "category": "",
            "content": "Mobx 공식 문서에 제공하는 async action(비동기 액션) 처리를 mobx-utils를 이용하여 더 깔끔한 처리방법을 살펴봅니다Mobx의 async action(비동기 액션) 처리를 가장 깔끔하게 구현하는 방법Mobx에서 상태를 수정하는 함수는 @action 데코레이터를 추가하여 상태를 변경합니다. api를 호출하는 비동기 처리의 경우 Mobx에서는몇가지 방식을 제공합니다. 그러나 별로 깔끔하지가 않습니다. Mobx 공식 문서에 제공하는 비동기액션 처리의 예제보다 더 깔끔한 처리방법을 살펴봅니다.Mobx의 일반적인 상태변경 action 처리class UserStore {  @observable  name;  @action  changeName(name) {      this.name = name;  }}  changeName 메소드에 @action 데코레이터를 붙이므로써 name 값이 변경된다.예상과 달리 동작하지 않는 Mobx의 비동기 action 처리비동기 api를 호출하는경우 아래와 같이 코드를 작성하는 것이 일반적이나 비동기 api 호출 완료후 결과값을 처리하는 콜백함수는 Mobx의 action에서 처리되지 않습니다.class UserStore {  @observable  users;  @action  getUsers(name) {    axios.get('/users')      .then(response =&gt; {          // 서버로부터 가져온 데이터를 저장하는 콜백처리는 동작하지 않는다.        this.users = response.data;      })      .catch(error =&gt; {        console.log(error);      })  }}  Mobx의 action 에서 비동기 처리 콜백은 동작하지 않기 때문에 특별한 처리를 해주어야 한다Mobx에서 비동기함수를 사용하여 상태를 변경하는 경우 action 처리Mobx 공식 문서에는 여러가지 방법을 제시하고 있습니다. 하지만 그리 깔끔한 방법들이 아니란 것이 아쉽습니다.비동기 콜백 함수를 따로 분리하는 방법class UserStore {  @observable  users;  @action  getUsers() {    axios.get('/users')      .then(this.getUsersCallback)      .catch(this.getUsersError)  }    @action.bound  getUsersCallback(response) {      this.users = response.data;  }  @action.bound  getUsersError(error) {      console.log(error);  }}  콜백함수를 따로 분리하여 action 테코레이터를 추가한 메소드로 만든다하지만 메소드가 개수가 많아지고 깔끔한 방법은 아니다.비동기 콜백 함수를 action 키워드로 래핑하는 방법class UserStore {  @observable  users;  @action  getUsers(name) {    axios.get('/users')      .then(action(\"successUsers\", response =&gt; {          this.users = response.data;      })      .catch(action(\"errorUsers\", error =&gt; {        console.log(error);      })  }}  전보다 조금 깔끔하지만 action으로 한번더 래핑하는 것이 번거롭다..runInAction를 사용하는 방법class UserStore {  @observable  users;  @action  getUsers(name) {    axios.get('/users')      .then(response =&gt; {          runInAction(() =&gt; {            this.users = response.data;        })      })      .catch(error =&gt; {        runInAction(() =&gt; {            console.log(error);        })      })  }}  이방법도 그리 깔끔하지는 않다.async/await를 사용하는 방법class UserStore {  @observable  users;  @action  async getUsers(name) {     const res = await axios.get('/users');     // 마찬가지로 await이후 구문은 처리되지 않기 때문에 runInAction으로 래핑처리를 해주어야한다.     runInAction(() =&gt; {       this.users = res.data     });  }}  async/await를 사용한 비동기 처리시에도 await이후 구문은 동작하지 않는다.runInAction으로 래핑처리를 추가해야만 처리가 된다.Mobx공식 문서에서 제공하는 방법들이 모두다 깔끔하지가 않다.flow를 사용하여 처리하는 방법class UserStore {  @observable  users;  getUsers = flow(function*() {    const res = yield axios.get('/users');    this.users = res.data  }}  이방법도 앞선 방법보다 깔끔하지만 flow로 래핑처리를 해야해서 그리 깔끔하지 못하다그리고 클래스의 메소드 선언이 함수표현식의 형태라 함수명만 선언하는 방식보다 번잡하다mobx-utils 이용하여 깔끔하게 처리하는 2가지 방법1. mobx-utils의 @asyncAction을 용하여 래핑없이 깔끔하게 비동기액션을 처리import { asyncAction } from 'mobx-utils';class UserStore {  @observable  users;  @asyncAction  async* getUsers() {    const res = yield axios.get('/users');    this.users = res.data;  }}      mobx-utils 라이브러리를 추가하고 import합니다    @asyncAction 데코레이터를 import하여 함수에 추가합니다.    메소드명 앞에 async* 추가하고 generator yield 이용하여 비동기 처리를 합니다.  2. mobx-utils의 @actionAsync과 task를 이용하여 async/await 키워드 사용으로 깔끔하게 비동기액션을 처리  예전 버전에는 없는 기능이기 때문에 Mobx와 mobx-utils의 최신버전이 필요합니다.import { actionAsync, task } from 'mobx-utils';class UserStore {  @observable  users;  @actionAsync  async getUsers() {    // task로 한번 래핑이 필요하긴 합니다.    const res = await task(axios.get('/users'));    this.users = res.data;  }}      mobx-utils 라이브러리를 추가하고 import합니다    actionAsync, task import하여 @actionAsync 함수에 추가합니다    메소드명 앞에 async 추가하고 await를 통하여 비동기 함수를 호출합니다    다만 비동기 함수에 task를 이용하여 래핑이 한번 필요합니다.  마무리Mobx 공식 문서에서 제공하는 비동기액션의 처리방법은 래핑이 많아 깔끔하지 못합니다. 그래서 mobx-utils 라이브러이에서 제공하는데코레이터와 generator 또는 async/await 비동기처리 키워드의 조합을 통하여 직관적이고 깔끔한 방법으로 비동기처리하는 방법을 알아보았습니다.",
        "url": "/programming/2020/06/24/react-mobx-async-action/"
    }
    ,
    
    "programming-2020-06-24-react-material-ui-combine-with-style": {
        "title": "[React] Material-UI에서 withStyle 사용시 1개 이상 여러개 style을 함께 사용하는 방법(multiple)",
            "author": "kimchanjung",
            "category": "",
            "content": "Material-UI에서 withStyle 함수로 JSS 스타일을 적용할때 1개 이상 여러개(multiple) 스타일을 같이 사용하는 방법을 알아봅니다.React Material-UI에서 withStyle 사용시 1개 이상 style을 함께 사용하는 방법Material-UI사용시 스타일(css)를 적용하는 방법은 JSS(javascript 객체방식으로 style을 정의)로 정의한 파일을 withStyle(Higher-order component 방식으로 Style을 적용)함수를 이용하여 템플릿에 적용하고 style class를 가져와 사용하는 구조가 일반적입니다.그러나 withStyle을 사용할때 JSS로 정의된 파일 즉 객체를 1개만 사용할 수 있기 때문에 일반적으로 공통 스타일을 정의 하고 개별 템플릿에 따로 정의한 스타일이 있는 경우 2개를 한꺼번에 사용하기가 어렵습니다.  이번포스팅은 withStyle 함수로 JSS 스타일을 적용할때 1개 이상 스타일을 같이 사용하는 방법을 알아봅니다.Material-UI 스타일을 적용하는 일반적인 방식일련의 코드는 사실상 css를 import하고 css class를 사용하는 보편적인 방식과 같은 Material-UI를 사용할 때 적용하는 방식을 설명한 것이라보 보면됩니다.CSS 대신 JSS로 스타일을 선언한다.// 파일명 CustomButtonStyleexport default {  customButton: {    maxWidth: 400,    maxHeight: 400    marginTop: 10  }}  css를 javascript 객체형식으로 선언해서 사용한다. 또한 하나의 객체템플릿에 스타일을 적용한다import { withStyles } from '@material-ui/styles';// 스타일을 정의한 객체를 import 한다import style from 'CustomButtonStyle';// CustomButtonStyle 선언했던 customButton 글래스를 사용하여 스타일을 적용한다.function CustomButton(props) {  const { classes } = props;  return &lt;Button className={classes.customButton}&gt;custom button&lt;/Button&gt;;}// withStyle 함수를 이용하여 CustomButton 템플릿에 style을 적용한다export default withStyles(styles)(CustomButton);  스타일 파일을 import해서 선언한 스타일객체를 withStyle 함수로 적용한다withStyle은 하나의 스타일 객체만 적용가능하다.큰 프로젝트를 하다보면 상황에 따라 적절히 파일을 나누기도하는 경우도 있습니다. 예를 들면 공통으로 사용하는 스타일을 정의한 공통스타일 JSS객체가 있고 특정 템플릿에만 사용하는 스타일만 정의한 JSS객체가 있을 수도 있는 경우 입니다.하지만 Material-UI의 withStyle을 사용하여 1개의 JSS객체의 만 적용가능하기 때문에 공통부분을 따로 묶은 JSS객체와 별도로 선언한 JSS객체 즉 1가지 이상의 스타일객체를 적용할 수가 없습니다.그냥 파일 하나에 모두 선언하고 가져다 사용해야 합니다. 그래서 1개 이상의 스타일객체를 매개변수로 받아서 두객체를 1개로 합치는 함수를 추가하여 1개이상의 스타일객체를 사용하는 방법을 알아봅니다.1개 이상의 스타일 객체를 1개의 객체로 합치는 함수를 작성// 파일명 CombineWithStyles import { withStyles } from '@material-ui/core/styles';function CombineWithStyles(...styles) {  function combineStyles() {    return function CombineStyles(theme) {      const outStyles = styles.map((arg) =&gt; {        if (typeof arg === 'function') {          return arg(theme);        }        return arg;      });            return outStyles.reduce((acc, val) =&gt; Object.assign(acc, val));    };  }    return withStyles(combineStyles(...styles), { withTheme: true });}export default CombineWithStyles;  withStyle함수를 래핑하여 1개이상의 스타일객체를 매겨변수로 받아와서 합치는 기능을 추가한다.withStyle 함수를 래핑한 함수를 사용한다.import { withStyles } from '@material-ui/styles';import combineWithStyles from 'core/CombineWithStyles';// 공통스타일을 importimport commonStyle from 'CommonStyle';// 개별스타일을 importimport style from 'CustomButtonStyle';// CustomButtonStyle 선언했던 customButton 글래스를 사용하여 스타일을 적용한다.function CustomButton(props) {  const { classes } = props;  return &lt;Button className={classes.customButton}&gt;custom button&lt;/Button&gt;;}// withStyle 함수를 이용하여 style과 공통스타일(commonStyle)을 동시에 적용할 수 있다.// combineWithStyles(commonStyle, style1, style2, ....) &lt;= 매개변수의 개수 한개는 없다.export default combineWithStyles(commonStyle, style)(CustomButton);  combineWithStyles 래핑 함수로 스타일객체를 1개~N개 까지 적용이 가능하다.마무리Material-UI withStyle 함수의 스타일 적용 개수가 1개 뿐이라 적절히 구조적으로 나눈 스타일 파일을 상황에 맞게 여러개 적용하고 싶을 때해결하는 방법을 알아 보았습니다. 더 좋은 방법을 알고 계신분은 코멘트 남겨주세요",
        "url": "/programming/2020/06/24/react-material-ui-combine-with-style/"
    }
    ,
    
    "programming-2020-06-22-react-router-history-with-mobx-problem": {
        "title": "[React] Mobx 와 react-router 사용시 history를 이용한 url 이동이 미동작 않는 경우 해결방법",
            "author": "kimchanjung",
            "category": "",
            "content": "Ract에서 mobx와 react-router를 함께 사용할 시 history를 이용한 페이지 이동이 미동작 문제점을 해결합니다.Mobx 와 react-router 사용시 history를 이용한 url 이동이 동작하지 않는 경우 해결방법일반적으로 React에서 react-router 사용시 링크를 설정하는 경우&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;// &lt;a href=\"/about\"&gt;About&lt;/a&gt; 와 같습니다  React에서 react-router와 같이 사용하는 경우 링크설정시 아래와 같이 사용합니다.javascript에서 history를 이용하여 동적으로 URL 이동하는 경우document.location.href = \"/about\";document.location.hash = \"#about\";window.history.back()window.history.pushState(null, null, \"/about\")  일반적인 상황에서는 a태그 대신 javascript를 사용해서 위 예제 처럼 동적으로 페이지 이동이 필요한 경우도 있습니다.React에서 react-router를 사용하는 경우 동적으로 페이지 이동 하는 방법Router 설정import { createBrowserHistory } from \"history\";const history = createBrowserHistory();ReactDOM.render(  &lt;Router history={history}&gt;    &lt;App /&gt;  &lt;/Router&gt;,  node);  React에서 react-router를 사용하는 경우 보통 createBrowserHistory() 사용하여 history를 props으로 전달합니다.그리고 각각의 컴포넌트들은 history, location, match 객체를 props로 부터 제공받아 사용할 수 있도록 합니다.컴포넌트에서 react-router의 history 이용하여 페이지 이동하는 예class Comp extends React.Component {  movePage() {   this.props.history.push(\"/about\")  }}  react-router가 제공하는 props 중에 history를 사용하여 페이지 이동이 동적으로 가능합니다컴포넌트 이외(store나 다른 함수등에서) react-router의 history를 이용하여 페이지 이동하는 예import { useHistory } from \"react-router-dom\";class AboutStore() {  history = useHistory();  handleClick() {    this.history.push(\"/home\");  }}  컴포넌트는 react-router 설정시 props에 history를 제공하기 때문에 사용가능하지만 그외 곳 store등에서 사용시에는 react-router-dom의 useHistory() 함수를 통하여 history를 가져와서 사용이 가능합니다.Mobx를 적용한 프로젝트에서 react-router의 동적 페이지 이동이 동작하지 않는 문제 해결Router 설정import { createBrowserHistory } from \"history\";// mobx-react-router 모듈을 추가합니다.import { syncHistoryWithStore, RouterStore } from 'mobx-react-router';const browserHistory = createBrowserHistory();const routerStore = new RouterStore();// mobx-react-router 의 syncHistoryWithStore 함수로 한번더 설정을 추가합니다.// 설정을 추가한 history를 props에 전달합니다.const history = syncHistoryWithStore(browserHistory, routerStore);ReactDOM.render(  &lt;Router history={history}&gt;    &lt;App /&gt;  &lt;/Router&gt;,  node);      mobx-react-router 라는 라이브러리를 설치합니다.    mobx-react-router 의 syncHistoryWithStore, RouterStore 를 이용하여 기존 Router의 history 설정에 추가적인 설정이 포함되도록 합니다.  컴포넌트에서 페이지 이동하는 방법기존 방법과 동일합니다. 컴포넌트의 props에 history를 기존대로 사용하면 됩니다.컴포넌트 이외의 곳(store)에서 history를 사용하여 페이지 이동하는 방법import { RouterStore } from 'mobx-react-router';class AboutStore() {  routerStore = new RouterStore();  handleClick() {    this.routerStore.history.push(\"/home\");  }}  mobx-react-router의 RouterStore 객체를 생성하여 history를 가져온 다음 동적으로 페이지 이동이 가능합니다.마무리react-router 사용할때 동적으로 페이지를 이동하는 방법에서 Mobx를 사용할때 동작하지 않는 부분을 mobx-react-router 라이브러리를 이용하여 설정을 추가한 후 해결하는 방법을 알아 보았습니다.  React로 개발하다 보면 뭔가 매끄럽거나 깔끔하지 못한 부분이 많은데 아무래도 React는 rendering만 제공하는 프레임워크가 아닌  라이브러리이기 때문에 나머지 기능은 서드파티 라이브러리를 사용한다는 점에서 매끄럽게 관리 되지 못해서 그런것 같다는 생각을 해보기도 합니다.깔끔한 방법을 아시는 분은 코멘트 남겨 주시면 감사하겠습니다.",
        "url": "/programming/2020/06/22/react-router-history-with-mobx-problem/"
    }
    ,
    
    "programming-2020-06-22-react-material-ui-datepicker-binding": {
        "title": "[React] mobx-react-form 사용시 material-ui datepicker의 date format이 미동작 해결 방법",
            "author": "kimchanjung",
            "category": "",
            "content": "Mobx사용시 form validation 라이브러리로 mobx-react-form을 사용했을 때 material-ui datepicker의 날짜를 변경한 후 화면에 표시되는 날짜는 설정한 date format 대로 표시가 되지만 실제 값은 적용되어 있지 않은 미동작 문제를 해결하는 방법을 알아봅니다mobx-react-form 사용시 material-ui datepicker의 date format이 제대로 동작하지 않는 문제 해결Mobx사용시 form validation 라이브러리로 mobx-react-form을 사용했을 때 material-ui datepicker의 날짜를 변경한 후 화면에 표시되는 날짜는 설정한 date format 대로 표시가 되지만 실제 값은 적용되어 있지 않은 문제가 있습니다.  datepicker 에서 날짜를 선택 했고 설정한 날짜형식은 yyyy-MM-dd 대로 입직일 항목에 2019-05-31로 표시가 되어 있지만 실제값은 yyyy-MM-dd가 아닌 Fry May 31 2019 13:44:31 GMT+0900 되어 있는 버그입니다문제가 발생했던 라이브러리의 버전정보  mobx v5.9  mobx-react-form v2.0.2  material-ui v3.9.3  material-ui-pickers v2.2.4mobx-react-form의 input 필드의 일반적인 바인딩의 예시// material-ui 컴포넌트와 mobx-react-form의 필드 바인딩&lt;TextField {...form.$('phoneNumber').bind()} /&gt;// 실제 input 필드는 아래 처럼 name, onClick 같은 속성과 이벤트리스너가 생성됩니다.&lt;input name=\"phoneNumber\" id=\"phoneNumber\" onClick=\"...\" onChange=\"...\" ....      TextField는 material-ui가 제공하는 input 필드의 컴포넌트입니다    form.$(‘phoneNumber’).bind() 추가하게 되면 name, id, onClick, onChange등이 생성됩니다.  Material-UI datepicker와 mobx-react-form의 바인딩&lt;DatePicker    format=\"yyyy-MM-dd\"    {...form.$('retireDate').bind()}/&gt;          DatePicker 컴포넌트에 mobx-react-form을 바인딩합니다.    DatePicker 컴포넌트가 제공하는 속성값 format=”yyyy-MM-dd” 에 날짜 포맷을 설정합니다    {…form.$(‘retireDate’).bind()} mobx-react-form 을 사용하여 바인딩합니다    날짜변경 및 화면에 선택된 날짜는 yyyy-MM-dd 형식으로 잘 표시 되지만 실제 retireDate의 값을 보면 Fry May 31 2019 13:44:31 GMT+0900 값으로 설정되어 있습니다.    {…form.$(‘retireDate’).bind()} 바인딩 처리를 했기 때문에 내부적으로 onChange이벤트리스너에 변경 함수가 자동적으로 생성이 되어 있는데 이 &gt; 함수가 yyyy-MM-dd 형식으로 값을 적용하지 못하는 문제입니다.    결론적으로 서버로 submit할 때 *yyyy-MM-dd 아니라 Fry May 31 2019 13:44:31 GMT+0900 형식으로 전송되는 것이 문제 입니다.  datepicker onChange 메소드를 오버라이드 하여 해결합니다.&lt;DatePicker    format=\"yyyy-MM-dd\"    {...form.$('retireDate').bind()}    onChange={value =&gt; form      .$('retireDate')      .onChange(format(new Date(value), 'yyyy-MM-dd'))    }/&gt;          {…form.$(‘retireDate’).bind()}에 의해서 onChange이벤트리스너가 이미 생성되어 있지만 onChange를 임의로 추가하여 자동으로 생성된 onChange를 오버라이드 합니다.    form.$(‘retireDate’) &lt;= mobx-react-form의 retireDate 값에 접근합니다.    form.$(‘retireDate’).onChange 메소드에 매개변수를 넘길때 retireDate의 선택된 날짜 값을 yyyy-MM-dd 변환하여 넘기도록 처리합니다.  마무리mobx-react-form에도 많은 기능이 있기 때문에 mobx-react-form으로 선언한 form validation 처리 class내부에서 처리하는 방법이 일반적인데 여러가지 동작에서 제대로 작동하지 않고 제시한 방법처럼 처리해야만 해결이 가능 하였습니다.혹시 최신버전에서 해결이되었거나 다른 깔끔한 방법을 알고 계시면 댓글을 남겨 주세요",
        "url": "/programming/2020/06/22/react-material-ui-datepicker-binding/"
    }
    ,
    
    "programming-2020-06-22-react-router-overlab-routing": {
        "title": "[React] react-router 에서 트리구조의 부모자식 URL 페이지를 구성하는 방법",
            "author": "kimchanjung",
            "category": "",
            "content": "react-router를 이용해서 아래와 같은 부모자식 트리구조 URL 구조가 있을 때 구현 하는 방법을 알아 봅니다React-router 에서 트리구조의 부모자식 URL 페이지를 구성하는 방법  react-router를 이용해서 아래와 같은 부모자식 URL 구조가 있을 때 구현 하는 방법을 알아 봅니다URL 항목URL 이렇게 존재한다고 했을 때user/listuser/detailorder/listorder/detailURL의 구조일반적으로는 이렇게 부모 자식으로 구성됩니다.user - list     - createorder - list      - createreact-router 에서 일반적인 routing 방식&lt;React.Fragment&gt;    &lt;Route exact path=\"/user/list\" component={UserList} /&gt;    &lt;Route exact path=\"/user/create\" component={UserCreate} /&gt;    &lt;Route exact path=\"/order/list\" component={UserList} /&gt;    &lt;Route exact path=\"/order/create\" component={UserCreate} /&gt;&lt;/React.Fragment&gt;  user 와 order가 중복이 됩니다 URL이 많아 지면 복잡해 보이기도 합니다.react-router 에서 URL 매핑을 부모자식(트리구조)구조로 구현 하는 방법&lt;React.Fragment&gt;    &lt;Route        path=\"/user\"        render={props =&gt; (            &lt;React.Fragment&gt;                &lt;Route exact path={`${props.match.url}/list`} component={UserList} /&gt;                &lt;Route exact path={`${props.match.url}/create`} component={UserCreate} /&gt;            &lt;/React.Fragment&gt;        )}    /&gt;    &lt;Route        path=\"/order\"        render={props =&gt; (            &lt;React.Fragment&gt;                &lt;Route exact path={`${props.match.url}/list`} component={OrderList} /&gt;                &lt;Route exact path={`${props.match.url}/create`} component={OrderCreate} /&gt;            &lt;/React.Fragment&gt;        )}    /&gt;&lt;/React.Fragment&gt;react-router 에서 URL 매핑을 트리구조 구조의 컴포넌트로 분리하는 방법  부모 자식의 트리 구조로 컴포넌트를 분리하여 URL 매핑을 구성할 수 있습니다.Root Router (부모라우터)&lt;React.Fragment&gt;    &lt;Route path=\"/user\" component={UserRouters} /&gt;    &lt;Route path=\"/order\" component={OrderRouters} /&gt;&lt;/React.Fragment&gt;  상위 URL을 정의 해놓고 하위 URL을 매핑을 정의 해놓은 router 컴포넌트를 호출합니다.User Routers (자식라우터)export default function UserRouters({ match }) {  return (    &lt;React.Fragment&gt;        &lt;Route            path={match.url}            render={props =&gt; (                &lt;React.Fragment&gt;                    &lt;Route exact path={`${props.match.url}/list`} component={UserList} /&gt;                    &lt;Route exact path={`${props.match.url}/create`} component={UserCreate} /&gt;                &lt;/React.Fragment&gt;            )}        /&gt;    &lt;/React.Fragment&gt;  )}  /user/~~~~ 시작하는 url은 모두 위 컴포넌트를 호출하게 됩니다.OrderRouters (자식라우터)export default function OrderRouters({ match }) {  return (    &lt;React.Fragment&gt;        &lt;Route            path={match.url}            render={props =&gt; (                &lt;React.Fragment&gt;                    &lt;Route exact path={`${props.match.url}/list`} component={UserList} /&gt;                    &lt;Route exact path={`${props.match.url}/create`} componet={UserCreate} /&gt;                &lt;/React.Fragment&gt;            )}        /&gt;    &lt;/React.Fragment&gt;  )}  /order/~~~~ 시작하는 url은 모두 위 컴포넌트를 호출하게 됩니다.마무리URL이 많을 경우 모튼 URL 매핑을 나열하면 부모자식 구조가 잘 한눈에 보이지 않고 파악이 어렵지만 위 같은 방식으로 부모자식으로 패턴을 구분하여 구현 할 수 있습니다.개인적으로는 react-router의 부모자식 구조로 router를 구성하는 방식이 그리 깔끔한 것 같지는 않다는 생각이 듭니다.조금더 깔끔한 방법을 아시는 분은 댓글 부탁드립니다.",
        "url": "/programming/2020/06/22/react-router-overlab-routing/"
    }
    ,
    
    "design-pattern-2020-05-29-visitor-pattern": {
        "title": "방문자 패턴 - Visitor Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "방문자 패턴은 정의가 가장 어려운 패턴 중에 하나인 듯 하다 수많은 블로그의 방문자 패턴을 정의하는 문구를 아무리 봐도 이해가 가장 어려웠다방문자 패턴 - Visitor Pattern방문자 패턴의 정의  패턴의 정의가 가장 어려운 패턴 중에 하나인 듯 하다 수많은 블로그의 방문자 패턴을 정의하는 문구를 아무리 봐도 이해가 가장 어려웠다. 설명으로 대체 한다.이해를 돕기 위한 설명  객체는 자기의 상태(필드)와 행위(메소드)를 가진다.  객체의 행위의 구조는 같으나 세부 구현이 다른경우 일관성있게 처리 할 수 있다.방문자 패턴 미사용배달하기(타입)    if (타입 == 정규직)        정규직라이더.운전()        정규직라이더.배달()    else        시간제라이더.운전()        시간제라이더.배달()    ...      모든 라이더는 배달, 운전, 수리라는 행위를 하지만 라이더의 타입에 따라 행위의 세부 구현은 다르다. 모든 타입의 라이더의 일련의 행위를 모두 호출한다면 각각 호출 해야한다.인터페이스 사용한다면배달하기(라이더)   라이더.운전()   라이더.배달()   인터페이스를 타입별로 구현하면 위 처럼 가능하다. 하지만 운전(), 배달() 각각의 메소드는 모두 호출 해야한다.방문자 패턴 사용배달하기()    for(라이더: 라이더객체리스트) // 정규직라이더, 시간제라이더 ..        라이더.업무() // 운전하기(), 배달하기(), 수리하기()....  방문자 패턴을 사용하면 여려객체(정규직라이더, 시간제라이더) 타입을 일반화하고 거기에 여러 메소드들(운전하기, 배달하기, 퇴근하기)까지 일반화 하여 사용 할 수 있도록 해준다.장점  클래스타입/메소드종류에 관계없이 추상화된 메소드로 일관성 있게 사용함으로써 클래스/메소드 추가나 로직 변경으로 부터 자유롭다.단점  관련 클래스들이 늘어남에 따라 구조가 복잡해 진다.클래스 다이어그램예제코드라이더의 행위(메소드)들을 추상화 한다.// 라이더의 개별 행위 즉 배달, 운전, 수리를 업무수행이라는 메소드로 추상황 한다.interface RiderTask {    fun doTask(rider: Rider): String}// 추상화된 메소드 업무수행을 배달, 운전, 수리 구현체에서 구현한다.class DeliveryTask : RiderTask {    override fun doTask(rider: Rider) = rider.doTask(this)}class DriveVehicleTask : RiderTask {    override fun doTask(rider: Rider) = rider.doTask(this)}class RepairVehicleTask : RiderTask {    override fun doTask(rider: Rider) = rider.doTask(this)}  delivery(), driveVehivle().. 등의 각각 메소드들을 사실상 doTask라는 메소드명 1개로 사용하기 위해서 하는 작업라이더 타입별로 구현한다.// 라이더의 행위들을 정의 한다.interface Rider {    fun doTask(deliveryTask: DeliveryTask): String    fun doTask(driveVehicleTask: DriveVehicleTask): String    fun doTask(repairVehicleTask: RepairVehicleTask): String}// 라이더의 타입에 따라 각각의 행위를 구현한다.// 행위들은 이제 fullTimeRider.delivery(),fullTimeRider.driveVehicle() 대신// rider.doTask() 추상화 되어 수행 될 것이다.class FullTimeRider : Rider {    override fun doTask(deliveryTask: DeliveryTask) = \"오토바이배달\"    override fun doTask(driveVehicleTask: DriveVehicleTask) = \"오토바이를운전한다\"    override fun doTask(repairVehicleTask: RepairVehicleTask) = \"오토바이를수리한다\"}class PartTimeRider : Rider {    override fun doTask(deliveryTask: DeliveryTask) = \"자전거배달\"    override fun doTask(driveVehicleTask: DriveVehicleTask) = \"자전거를운전한다\"    override fun doTask(repairVehicleTask: RepairVehicleTask) = \"자전거를수리한다\"}클라이언트class TotalRiderTask : RiderTask {    private val riderTaskList =            mutableListOf(DeliveryTask(), DriveVehicleTask(), RepairVehicleTask())    // 배달/운전/수리 모든 메소드를 수행한다.    override fun doTask(rider: Rider) =            riderTaskList.joinToString(separator = \"\"){ it.doTask(rider) }}val fullTimeRider = FullTimeRider()val partTimeRider = PartTimeRider()val totalRiderTask = TotalRiderTask()// 정규직 라이더의 배달/운전/수리 일련의 행위를 수행totalRiderTask.doTask(fullTimeRider)// 시간제 라이더의 배달/운전/수리 일련의 행위를 수행totalRiderTask.doTask(partTimeRider)  doTask 메소드는 정규직/시간제 라이더 타입별, 배달/운전/수리 메소드별 처리를 구분하는 로직이 필요 없고 추후 라이더 타입 추가 및 메소드 추가에도 코드 변경으로 부터 자유 롭다.",
        "url": "/design-pattern/2020/05/29/visitor-pattern/"
    }
    ,
    
    "design-pattern-2020-05-28-template-method-pattern": {
        "title": "템플릿 메소드 패턴 - Template Method Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "템플릿 메소드 패턴 전체적으로는 동일하지만 부분적으로 다른 경우 중복을 최소화 하는 패턴 동일한 기능을 상위 클래스에 정의하고 부분적으로 다른부분은 서브클래스에 정의하여 사용한다템플릿 메소드 패턴 - Template Method Pattern템플릿 메소드 패턴 이란  전체적으로는 동일하지만 부분적으로 다른 경우 중복을 최소화 하는 패턴동일한 기능을 상위 클래스에 정의하고 부분적으로 다른부분은 서브클래스에 정의하여 사용한다.쉽게 말하면 같은부분은 공통으로 사용하고 약간 다른부분만 따로 생성장점  코드중복을 줄인다.  자식클래스의 역할을 줄이면서 핵심로직 관리 용이  객체 추가 및 확장이 쉽다.단점  추상메소드가 많아지면 관리가 복잡  추상클래스와 구현클래스간의 복잡성 증대주의!      반드시 추상클래스에서 하위클래스를의 메소드나 멤버를 호출하는 의존 관계를 가져야한다    하위클래스에서 추상클래스를 호출하면 안된다.    하위클래스를 핸들링하는 주체는 상위 클래스여야 한다. 클라이언트가 하위 클래스이 메소드를 직접 호출하여 컨트롤하도록 하면 안된다.  클래스 다이어그램예제코드공통된 골격을 추상클래스로 선언abstract class Rider(var name: String,                     var age: Int,                     var address: String) {    // 일련의 로직을 수행한다.    fun work(): String {        return goToWork() + delivery() + repairVehicle() + offWork()    }    // 로직이 같은 부분이므로 하위 클래스가 구현할 필요 없다. 중복제거    // 하위 클래스가 호출하지 못하도록 제한    private fun goToWork() = \"출근\"    private fun offWork() = \"퇴근\"    // 로직이 다른 메소드는 하위 클래스가 구현하도록 한다    protected abstract fun delivery(): String    protected abstract fun repairVehicle(): String}  공통된 로직은 하위 클래스가 상위 클래스의 것을 사용하도록 하여 중복을 줄이고부분적으로 다른 부분만 추상메소드를 정의 하여 구현하도록 마련한다.다른 부분을 확장class FullTimeRider(name: String,                    age: Int,                    address: String,                    var employeeNumber: String)    : Rider(name, age, address) {    override fun delivery() = \"오토바이배달\"    override fun repairVehicle() = \"오토바이수리\"}class PartTimeRider(name: String,                    age: Int,                    address: String,                    var feePerDelivery: Int)    : Rider(name, age, address) {    override fun delivery() = \"자전거배달\"    override fun repairVehicle() = \"자전거수리\"}  공통된 부분은 상위 클래스의 메소드를 사용하고 부분적으로 다른 부분은 구현한다.중요한것은 상위 클래스의 work() 메소드가 일련의 로직을 제어하여 사용하도록 되어 있고 외부에 노출되고 나머지 메소드들은 사실상 외부로 부터의 접근이 불가하도록 해야한다.클라이언트class DeliveryService(private val rider:Rider) {    fun delivery() {        rider.work()        // 일련의 메소드를 클라이언트가 사용하지 못하도록 캡슐화한다.        // rider.goToWork()        // rider.delivery()        // rider.offWork()    }}val deliveryService = DeliveryService(FullTimeRider())deliveryService.delivery()  사실상 전체 로직의 구성은 동일하나 일부 로직이 부분적으로 다른 경우에 사용하는 패턴이다. 만약에 메소드들을 외부에 노출하면 로직이 달라지기 때문에 주의 해야한다.",
        "url": "/design-pattern/2020/05/28/template-method-pattern/"
    }
    ,
    
    "design-pattern-2020-05-28-strategy-pattern": {
        "title": "전략 패턴 - Strategy Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "전략 패턴은 알고리즘 및 로직을 따로 정의하여 필요에 의해 사용 또는 교체 할 수 있는 패턴전략 패턴 - Strategy Pattern전략 패턴 이란  알고리즘 및 로직을 따로 정의하여 필요에 의해 사용 또는 교체 할 수 있는 패턴.명령패턴과 차이점명령패턴 저장() {    실행() // 실행위치, 파일명, 객체생성 등의 일련의 행위를 갭슐화 하여 간단하게 제공 }  명령패턴은 어떤 행위자체(로직전체 또는 거의 대부분)를 직접 처리하지 않고 캡슐화된 메소드를 사용하는 것이지만전략패턴저장(){   객체생성   덧셈전략() // 전체 로직중에 일부로직을 캡슐화한 패턴을 사용하는 것    파일에저장()}  전략패턴은 어떤 행위를 처리할때 로직의 일부 전략을 캡슐화하여 이용하는 패턴이다.장점  로직이나 알고리즘 변경시 해당 코드를 직접 변경하지 않고 이미 정의된 알고리즘을 교체하여 사용할 수 있다.  분기로직 제거단점  객체의 수가 증가  코드 복잡도 증가  구현된 객체 사이의 결합도 증가클래스 다이어그램예제코드전략을 추상화 한다 - 출근 전략// 출근 전략interface GoToWorkStrategy {    fun goToBy(): String}class BySubwayStrategy : GoToWorkStrategy {    override fun goToBy() = \"지하철\"}class ByCarStrategy : GoToWorkStrategy {    override fun goToBy() = \"자가용\"}class DontGoToWorkStrategy : GoToWorkStrategy {    override fun goToBy() = \"출근안함\"}전략을 추상화 한다 - 배달 전략interface DeliveryStrategy {    fun move(): String}class MotorCycleStrategy : DeliveryStrategy {    override fun move() = \"오토바이\"}class BikeStrategy : DeliveryStrategy {    override fun move() = \"자전거\"}클라이언트class Rider(        var name: String,        private var goToWorkStrategy: GoToWorkStrategy,        private var deliveryStrategy: DeliveryStrategy) {    // 추후 변경이 생기면 전략을 갈아 끼운다    fun changeGoToWorkStrategy(goToWorkStrategy: GoToWorkStrategy) {        this.goToWorkStrategy = goToWorkStrategy    }    fun changeDeliveryStrategy(deliveryStrategy: DeliveryStrategy) {        this.deliveryStrategy = deliveryStrategy    }    // 로직의 일부를 패턴화한 전략을 사용한다.    fun goToWork() {        // 아침에 일어난다        // 샤워를 하고 옷을 입는다         goToWorkStrategy.goToBy() // 출근 시 이동수단 전략을 사용한다.        // 내려서 지점 건물 까지 걸어간다.    }    fun delivery() {        // 배달을 배차한다        // 음식을 픽업한다.        deliveryStrategy.move() // 배달시 이동수단 전략을 사용한다.        // 고객에게 음식을 전달한다.    }}private var motorCycleStrategy = MotorCycleStrateg()private var bikeStrategy = BikeStrategy()private var bySubwayStrategy = BySubwayStrategy()private var byCarStrategy = ByCarStrategy()private var dontGoToWorkStrategy =DontGoToWorkStrategy()val rider = Rider(\"김찬정\", bySubwayStrategy, motorCycleStrategy)rider.goToWork() // 지하철 타고 출근rider.goToDelivery() // 오토바이로 배달rider.changeDeliveryStrategy(bikeStrategy) // 자전거배달 전략으로 변경 rider.goToDelivery() // 자전거로 배달   클라이언트는 출근 이동 수단 및 배달 이동 수단의 종류가 변경 되더라도 코드 변경에서 자유 롭다.",
        "url": "/design-pattern/2020/05/28/strategy-pattern/"
    }
    ,
    
    "design-pattern-2020-05-26-state-pattern": {
        "title": "상태 패턴 - State Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "상태 패턴은 객체가 상태에 따른 행위를 직접 구현하지 않고 상태와 행위를 구현한 별개의 상태객체에게 위임하는 패턴상태 패턴 - State Pattern상태 패턴 이란  객체가 상태에 따른 행위를 직접 구현하지 않고 상태와 행위를 구현한 별개의 상태객체에게 위임하는 패턴이해를 돕기위한 설명상태 패턴 미적용다음상태변경(상태)    if (상태 == 대기) {        상태 = 배차완료    } else if (상태 == 배차완료) {        상태 = 배차완료    } else if (상태 == 배달완료) {        println(\"다음 상태 없음\")    }  상태 패턴을 적용하지 않으면 분기처리 및 기타 복잡한 알고리즘도 한꺼번에 같이 포함 된다. 새로운 로직이나 상태추가 시 클래스를 변경해야한다.상태 패턴 적용다음상태변경(상태패턴객체)    상태패턴객체.다음상태()  상태에 따른 처리를 분기해서 처리하는 로직 대신 상태패턴을 구현한 객체의 다음상태() 메소드를 호출하는 것으로 일관성 있게 사용가능 하며 새로운상태 추가 및 로직 변경에 대해서 자유롭다.장점  상태 변경에 따른 행위 로직을 직접 구현 하지 않아도 됨으로써 확장에 유리하다.  번잡한 분기로직이 제거된다.단점  관련 클래스가 많아저 복잡도가 증가클래스 다이어그램예제코드배달상태를 변경하는 인터페이스 정의interface DeliveryStatus {    val name: String    fun forward(delivery: Delivery): String    fun backward(delivery: Delivery): String}개별 배달상태 인터페이스를 구현// 배차대기object Wait : DeliveryStatus {    override val name = \"배차대기\"    // 배차대기의 다음 상태는 배차완료 이므로 배차완료 상태로 변경한다.    override fun forward(delivery: Delivery): String {        delivery.status = Assign // 해당 배달을 매겨변수로 넘겨 받아 상태를 변경시킨다.        return delivery.status.name    }    // 배차대기에서 뒤로 갈 상태가 없으므로 뒤로불가 리턴한다.    override fun backward(delivery: Delivery) = \"뒤로불가\"} // 배차완료object Assign : DeliveryStatus {    override val name = \"배차완료\"    override fun forward(delivery: Delivery): String {        delivery.status = Pickup        return delivery.status.name    }    override fun backward(delivery: Delivery): String {        delivery.status = Wait        return delivery.status.name    }}// 픽업완료object Pickup : DeliveryStatus {    override val name = \"픽업완료\"    override fun forward(delivery: Delivery): String {        delivery.status = Complete        return delivery.status.name    }    override fun backward(delivery: Delivery): String {        delivery.status = Assign        return delivery.status.name    }}// 전달완료 object Complete : DeliveryStatus {    override val name = \"전달완료\"    // 전달완료는 다음상태가 없기 때문에 진행불가    override fun forward(delivery: Delivery) = \"진행불가\"    override fun backward(delivery: Delivery): String {        delivery.status = Pickup        return delivery.status.name    }}클라이언트class Delivery {    var status: DeliveryStatus = Wait    fun forwardStatus() = status.forward(this)    fun backwardStatus() = status.backward(this)}val delivery = Delivery()delivery.forwardStatus() // 배차대기 =&gt; 배차완료 변경delivery.forwardStatus() // 배차완료 =&gt; 픽업완료 변경deliivery.backwardStatus() // 픽업완료 =&gt; 배차완료  배달클래스는 자신의 상태변경과 로직을 자신이 가지고 있지 않고 상태패턴으로 정의된 별도의 클래스를 사용한다.이로써 배달클래스는 새로운 상태추가 및 상태변경 조건 로직의 변경으로 부터 자유롭다.",
        "url": "/design-pattern/2020/05/26/state-pattern/"
    }
    ,
    
    "design-pattern-2020-05-25-singleton-pattern": {
        "title": "싱글톤 패턴 - Singleton Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "싱글톤 패턴은 매번 새로운 객체를 생성하지 않고 오직 하나의 객체만 생성하어 사용하려고 할때 사용한다.싱글톤 패턴 - Singleton Pattern싱글톤 패턴 이란  매번 새로운 객체를 생성하지 않고 오직 하나의 객체만 생성하어 사용하려고 할때 사용한다.장점  메모리 낭비를 방지  전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다  객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용단점  private 생성자톨 갖고 있기 때문에 상속할 수 없다.  싱글톤은 테스트하기가 힘들다  서버환경에서는 싱글톤이 하나만 생성되는 것을 보장하지 못한다.  싱글톤의 사용은 전역상태를 만들수 있기 때문에 바람직하지 못하다  스프링은 싱글톤패턴을 대신하여 싱글톤을 생성 관리해주는 싱글톤레지스트리를 사용하여 단점을 해결함예제코드kotlin object 키워드 사용object SingletonPattern {    var name = \"김찬정\"}  object 키워드로 싱글톤이 제공된다. thread-safe 하고 lazy 한 초기화 가능싱글톤 생성시 파라메터가 필요하다면 패턴 사용class LikeJavaSingletonPattern private constructor(private val name: String) {    companion object {        @Volatile        private var instance: LikeJavaSingletonPattern? = null        @Synchronized        fun getInstance(param: String) = instance                ?: LikeJavaSingletonPattern(param).also { instance = it }    }}",
        "url": "/design-pattern/2020/05/25/singleton-pattern/"
    }
    ,
    
    "design-pattern-2020-05-24-proxy-pattern": {
        "title": "프록시 패턴 - Proxy Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "프록시 패턴은 실제객체를 대신하는 객체가 로직의 흐름을 제어하여 실제 객체를 조작하는 패턴프록시 패턴 - Proxy Pattern프록시 패턴 이란  실제객체를 대신하는 객체가 로직의 흐름을 제어하여 실제 객체를 조작하는 패턴장점  원래 객체의 기능에 부가적인 작업을 추가 할 때 용이함  메소드 호출이 발생하기 전까지 실제 객체가 생성성되지 않는다 (메모리 이점)단점  한단계를 거치므로 간혹 객체 응답이 느려질 수 있댜.  인터페이스를 구현하므로 프록시 객체에서 구지 필요없는 메소드도 구현해야하며 코드 중복될 수 있다.클래스 다이어그램예제코드인터페이스 정의interface Rider {    fun delivery(): String    fun getPersonalInfo(level: Int): String?}실제클래스 구현// 실제 클래스 class FullTimeRider(var name: String) : Rider {    override fun delivery() = \"음식배달\"    override fun getPersonalInfo(level: Int) = name}실제객체 생성을 제어하는 프록시class ProxyRider(var name: String) : Rider {    private var fullTimeRider: FullTimeRider? = null    override fun delivery() =            (fullTimeRider ?: FullTimeRider(name)).delivery()    override fun getPersonalInfo(level: Int) = name}  rider.delivery() 메소드 호출시 실제 라이더 객체가 없으면 생성, 이미 생성되어 있으면 그 객체를 사용하도록 프록시가 실제 라이더 객체의 생성에 관여 한다.라이더 정보 접근을 제어하는 프록시class ProtectedProxyRider(var name: String) : Rider {    private var fullTimeRider: FullTimeRider? = null    private fun getRider(name: String) = fullTimeRider ?: FullTimeRider(name)    override fun delivery() = getRider(name).delivery()    override fun getPersonalInfo(level: Int) = if (level &gt; 3)        getRider(name).getPersonalInfo(level)    else        \"접근불가\"}  라이더의 개인정보의 접근을 Level 3 초과 하는 경우에만 접근 할 수 있도록 실제 객체의 정보접근을 제어하는 프록시클라이언트class DeliveryService(private val rider: Rider) {    fun delivery() = rider.delivery()    fun getRiderInfo() = rider.getPersonalInfo(1)}val deliveryService = DeliveryService(ProxyRider())deliveryService.delivery()  배달서비스 클라이언트가 마치 실제 객체인 라이더객체를 사용하는 듯 하지만 주입된 프록시 구현체의 메소드가 호출된다.",
        "url": "/design-pattern/2020/05/24/proxy-pattern/"
    }
    ,
    
    "design-pattern-2020-05-23-observer-pattern": {
        "title": "옵저버 패턴 - Observer Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "옵저버 패턴은 그야 말로 발행/구독 모델 이라고 생각하면 쉽다. spring 의 ApplicationEvent 이용한 이벤트 발행/구독이나 javascript onClick 같은 이벤트 리스너를 사용한다거나 크게는 aws sns/sqs 같은 것들도 발생/구독 모델이다.옵저버 패턴 - Observer Pattern옵저버 패턴이란  옵저버 패턴은 그야 말로 발행/구독 모델 이라고 생각하면 쉽다. spring 의 ApplicationEvent 이용한 이벤트 발행/구독이나 javascript onClick 같은 이벤트 리스너를 사용한다거나 크게는 aws sns/sqs 같은 것들도 발생/구독 모델이다.장점  객체간 겹합도가 느슨해진다.단점  옵저버의 실행 순서를 알 수 없다.클래스 다이어그램예제코드  배달상태 변경 시 발행자는 이벤트를 발행하고 구독자는 이벤트를 수신 받는다.배달완료 상태 이벤트를 수신 받으면 이메일을 발송한다.발행/구독 인터페이스 정의// 발행 인터페이스를 정의한다.interface Publisher {    fun update(deliveryStatus: String): Boolean    fun add(subscriber: Subscriber): Boolean    fun delete(subscriber: Subscriber): Boolean   }// 구독 인터페이스를 정의한다.interface Subscriber {    fun onUpdate(deliveryStatus: String): Boolean}발행 인터페이스를 구현class DeliveryStatusPublisher : Publisher {    private val observerList = mutableListOf&lt;Subscriber&gt;()    private var deliveryStatus = \"WAIT\"    // 등록된 구독자들에게 이벤트발송    // 등록된 구독자들을 순회하면서 이벤트 수신 받을 메소드들을 호출한다.    override fun update(deliveryStatus: String): Boolean {        this.deliveryStatus = deliveryStatus        observerList.forEach { it.onUpdate(deliveryStatus) }        return true    }    // 구독자를 추가한다    override fun add(subscriber: Subscriber) = observerList.add(subscriber)    // 구독자를 제거한다.    override fun delete(subscriber: Subscriber) = observerList.remove(subscriber)}  발행 구현체는 이벤트 발생 시 등록된 구독자들을 모두 순회하여 이벤트 변경을 수신받을 수 있는 메소드를 호출한다.구독 인터페이스 구현class DeliveryStatusSubscriber : Subscriber {    var isSent = false        private set    // 배달 상태 변경, 배달 완료 상태라면 이메일을 발송한다.    override fun onUpdate(deliveryStatus: String): Boolean {        if (deliveryStatus == \"COMPLETE\") {            sendEmail()        }        return true    }    private fun sendEmail() {        isSent = true    }}  구독자는 이벤트 발생 시 발행자에서 onUpdate 메소드가 호출 되어 이벤트를 수신 받게 된다.",
        "url": "/design-pattern/2020/05/23/observer-pattern/"
    }
    ,
    
    "design-pattern-2020-05-22-flyweight-pattern": {
        "title": "플라이웨이트 패턴 - Flyweight Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "플라이웨이트 패턴은 공통으로 사용하는 클래스를 생성하는 팩토리클래스를 만들고 필요한 클래스의 인스턴스가 없는 경우 인스턴스를 새로 생성하고 이미 있는 경우는 생성해둔 인스턴스를 리턴해서 1개만 생성하여 공유해서 사용할 수 있도록 제공하는 패턴플라이웨이트 패턴 - Flyweight Pattern플라이웨이트 패턴이란  공통으로 사용하는 클래스를 생성하는 팩토리클래스를 만들고 필요한 클래스의 인스턴스가 없는 경우 인스턴스를 새로 생성하고 이미 있는 경우는 생성해둔 인스턴스를 리턴해서 1개만 생성하여 공유해서 사용할 수 있도록 제공하는 패턴플라이웨이트 패턴을 사용하는 이유공통적으로 많이 사용하는 클래스가 있고 무수이 많은 개수가 사용되고 있을 때 클라이언트에서 매번 새로운 인스턴스를 생성하면 매모리 낭비가 심한 경우가 발생하는 경우에 적용하면 유리함.싱글톤 패턴과의 차이는?싱글톤 패턴은 클래스자체가 오직 1개의 인스턴스만 허용하지만, 플라이웨이트 패턴은 싱글톤이 아닌 클래스를 플라이웨이트 패턴의 팩토리가 제어하는 것이다. 인스턴스 생성의 제안을 누가 제어하느냐에 차이장점  많은 객체를 만들때 성능을 향상시킬수 있다.  많은 객체를 만들때 메모리를 줄일수 있다.단점  특정 인스턴스를 다르게 처리하는 것은 불가능 함클래스 다이어그램예제코드 - 생성 클래스가 1개 일때class Rider(var center: String) {     fun delivery() = \"$center 배달\"}class RiderFactory {    private val riderMap = mutableMapOf&lt;String, Rider&gt;()    // 해당지점 라이더 인스턴스가 없으면 새 인스턴스를 생성 후 리턴    fun getRider(center: String) = riderMap.computeIfAbsent(center) {        Rider(center)    }}val riderFactory = RiderFactory()val 강남라이더 = riderFactory.getRider(\"강남\")val 강남라이더2 = riderFactory.getRider(\"강남\") // 이미 생성된 인스턴스를 리턴val 관악라이더 = riderFactory.getRider(\"관악\")예제코드 - 비슷한 종류의 클래스가 여러개 인 경우팩토리가 생성할 클래스들을 추상화interface Rider {    var center:String    fun delivery(): String}class FullTimeRider(override var center: String) : Rider {    override fun delivery() = \"$center 오토바이배달\"}class PartTimeRider(override var center: String) : Rider {    override fun delivery() = \"$center 자전거배달\"}  클래스들을 추상화하는 이유는 여러종류의 라이더 타입 객체를 처리할 때 팩토리에서 분기 처리를 제거 하기 위함이다.팩토리를 생성class RiderFactory {    // 인스턴스 생성시 if문을 제거 하기 위해서 map활용하여 관리함     private val riderClasses =            mapOf(\"fulltime\" to FullTimeRider::class, \"parttime\" to PartTimeRider::class)    // 생성된 인스턴스가 관리됨             private val riderMap = mutableMapOf&lt;String, Rider&gt;()    // 강남지점-정규직라이더가 이미 있으면 리턴    // 없으면 riderClasses에서 클래스원본을 가져와 리플렉션을 사용하여 새 인스턴스를 생성    // 이 로직은 단순히 if 처리를 제거하기 위함임(패턴과는 관계 없음)    fun getRider(center: String, type: String) =            riderMap.computeIfAbsent(center + type) {                riderClasses[type]!!.primaryConstructor!!.call(center)            }}클라이언트class RiderService {    private val riderFactory = RiderFactory()    fun delivery(center: String, type: String) = riderFactory            .getRider(center, type)            .delivery()}val riderService = RiderService()riderService.delivery(\"강남\",\"fulltime\")  라이더의 배달을 수행하는 라이더서비스는 배달 메소드 호출 시 지점과 라이더 타입만 매개변수로 받아서 riderFactory를 사용하여 라이더 객체를 가져온다. 수많은 객체가 필요해도 riderFactory에서 적절히 관리하여 1개의 인스턴스만 유지되고 라이더 서비스는 라이더타입의 추가, 객체성성 로직의 변화로 부터 자유롭다.",
        "url": "/design-pattern/2020/05/22/flyweight-pattern/"
    }
    ,
    
    "design-pattern-2020-05-21-factory-method-pattern": {
        "title": "팩토리 메소드 패턴 - Factory Method Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "팩토리 메소드 패턴 객체 생성을 직접 하지 않고 객체를 생성/제공하는 클래스를 사용하여 획득하는 패턴팩토리 메소드 패턴 - Factory Method Pattern팩토리 메소드 패턴 이란  객체 생성을 직접 하지 않고 객체를 생성/제공하는 클래스를 사용하여 획득하는 패턴이해를 돕기위한 설명팩토리 메소드 패턴 미적용라이더생성(타입)    if (타입 == \"정규직\")        정규직라이더 라이더 = new 정규직라이더(\"김찬정\")    else if (타입 == \"파트타임\")        파트타임라이더 라이더 = new 파트타임라이더(\"김찬정\")    else if (타입 == \"야간타임\")        if (현재시각 &gt; 오후9시)            야간타임 라이더 = new 야간타임(\"김찬정\")        else            println(\"야간타임 라이더 생성불가\")    ...  다양한 타입의 라이더객체를 생성할 경우 분기 처리가 필요하며야간타임 라이더 객체는 오후 9시 이후만 생성 할수있다(객체성성 조건 로직)팩토리 메소드 패턴 적용라이더생성(타입)    라이더 라이더 = 라이더팩토리.라이더생성(타입)  분기처리 및 객체 생성 조건 로직을 팩토리객체로 위임하고 일관성있는 방법으로 객체를 생성한다.다른 종류의 라이더클래스 추가 및 생성 로직의 변경에 의한 소스코드 변경이 필요 없다.장점  클라이언트는 팩토리객체를 통하여 생성하기 때문에 생성하고자 하는 클래스와 클라이언트간의 결합도가 낮아진다.  하나의 메소드로 여러가지 클래스의 객체를 생성할 수 있다.단점  객체가 늘어날 때마다 하위 클래스 재정의로 인한 불필요한 많은 클래스 생성 가능성이 있음클래스 다이어그램예제코드클래스를 추상화interface Rider {    fun delivery(): String    fun repairVehicle(): String}class FullTimeRider : Rider {    override fun delivery() = \"오토바이배달\"    override fun repairVehicle() = \"오토바이수리\"}class PartTimeRider : Rider {    override fun delivery() = \"자전거배달\"    override fun repairVehicle() = \"자전거수리\"}팩토리 메소드class RiderFactory {    fun createRider(className: String): Rider {        return when (className) {            \"fulltime\" -&gt; FullTimeRider()            \"parttime\" -&gt; PartTimeRider()            \"nighttime\" -&gt;                if (LocalDateTime.now().hour &gt; 21)                    NightTimeRider()                else                    throw IllegalArgumentException(\"오후 9시 이후만 생성 가능합니다\")            else -&gt; throw IllegalArgumentException(\"생성할 수 있는 객체명이 아닙니다.\")        }    }}클라이언트class DeliveryService {    private var riderFactory = RiderFactory()    fun assignDelivery(deliveryId: String) {        val rider = riderFactory.createRider(\"fulltime\")        rider.delivery(deliveryId)    }}  라이더 타입에 따른 객체생성을 구분할 필요 없이 일관성있는 메소드로 생성이 가능하다.라이더 타입이 추가 되거나 야간타임라이더의 생성 가능 시간이 변경되어도 수정이 필요 없다.",
        "url": "/design-pattern/2020/05/21/factory-method-pattern/"
    }
    ,
    
    "design-pattern-2020-05-20-facade-pattern": {
        "title": "퍼사드 패턴 - Facade Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "퍼사드 패턴은 아마도 우리가 프로그래밍 하면서 자연스럽게 사용되어지는 패턴중에 가장 흔한 패턴이 아닌가 싶다.퍼사드 패턴 - Facade Pattern퍼사드 패턴이란  일련의 복잡한 로직을 간추려 별도의 클래스로 만들어 제공한다.퍼사드 패턴은 아마도 우리가 프로그래밍 하면서 자연스럽게 사용되어지는 패턴중에 가장 흔한 패턴이 아닌가 싶다.이해를 돕기위한 설명  AWS S3에 이미지를 업로드 한다고 가정 하자.  AWS에서 제공하는 S3 라이브러리를 추가하고 사용하여 이미지를 업로드한다.퍼사드 패턴 미적용라이더서비스 {    이미지저장(이미지) {        AwsS3 s3 = AwsS3()        이미지.이미지명        이미지.이미지위치        이미지.bytecode        s3.setName(이미지.이미지명)        s3.setLocation(이미지.이미지위치)        ..        s3.upload()    }}배달서비스 {    이미지저장(이미지) {        AwsS3 s3 = AwsS3()        이미지.이미지명        이미지.이미지위치        이미지.bytecode        s3.setName(이미지.이미지명)        s3.setLocation(이미지.이미지위치)        ..        s3.upload()    }}  클라이언트들은 매번 이미지를 업로드 할 때마다 AwsS3 객체 생성 및 필요한 정보를 설정 해줘야 한다.퍼사드 패턴 적용아마존S3서비스   업로드이미지(이미지) {        AwsS3 s3 = AwsS3()        이미지.이미지명        이미지.이미지위치        이미지.bytecode        s3.setName(이미지.이미지명)        s3.setLocation(이미지.이미지위치)        ..        s3.upload()   }라이더서비스 {    이미지저장(이미지) {        아마존S3서비스.업로드이미지(이미지)    }}배달서비스 {    이미지저장(이미지) {        아마존S3서비스.업로드이미지(이미지)    }}  업로드를 위한 일련의 작업들을 하나의 클래스로 만들어 클라이언트에게 제공한다.클라이언트는 세부 사용방법을 알 필요없이 “아마존S3서비스.업로드이미지(이미지)”만 사용하면 된다.장점  클라이언트와 서브시스템(라이브러리 및 클래스)간의 결합도가 줄어든다.  클라이언트는 서브시스템(라이브러리 및 클래스)의 다루기위한 정보와 행위가 줄어들거나 몰라도 된다.단점  Client가 서브시스템 내부의 클래스를 직접 사용하는 것을 막을 수 없다. Namespace를 선언하는 것이 대한이 될 수 있다. (&lt;= 무슨말인지 솔직히 이해는 안됨)클래스 다이어그램예제코드사용이 번거로운 외부라이브러리class AwsS3 {    lateinit var name: String    lateinit var location: String    fun upload() = true}퍼사드 패턴을 적용한 클래스class AwsS3UploadService {    private val awsS3 = AwsS3()    fun upload(image: Image): Boolean {        s3.name = image.name        s3.location = image.fileDir                ?.replace(\"/local/image\", \"\")                .toString()        return s3.upload()    }}  아마존 s3 객체를 생성하고 업로드에 필요한 정보를 설정하고 업로드하기 까지 일련의 로직을 구현하여 upload 메소드로 제공한다.클라이언트class RiderService {    private val awsS3UploadService = AwsS3UploadService()    fun uploadRiderProfile(image: Image) = awsS3UploadService.upload(image)}  라이더정보를 다루는 라이더서비스는 라이더 프로필을 업로드 하기위해 아마존 s3를 직접 다루지 않고 AwsS3UploadService를 사용한다.",
        "url": "/design-pattern/2020/05/20/facade-pattern/"
    }
    ,
    
    "design-pattern-2020-05-19-decorator-pattern": {
        "title": "데코레이터 패턴 - Decorator Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "데코레이터 패턴은 특정 클래스의 기본기능에 추가기능을 기존 클래스를 수정하지 않고 패턴을 통하여 덧 붙이고 싶을 때 사용한다.데코레이터 패턴 - Decorator Pattern데코레이터 패턴이란  데코레이터 패턴은 특정 클래스의 기본기능에 추가기능을 기존 클래스를 수정하지 않고 패턴을 통하여 덧 붙이고 싶을 때 사용한다.이해를 돕기위한 설명      개발자는 개발이라는 업무만 할 수 있다.    그런데 추가적으로 개발업무에 프론트엔드개발라는 업무을 넣고 싶다.    하지만 개발업무만 하는 개발자가 필요할 수도 있기 때문에 필요할때 만  프론트엔드개발라는 업무를 추가 하고 싶다.  상속을 통하여 기능을 추가한 클래스를 만들면 기능조합에 따른 클래스의 수가 늘어난다개발개발프론트엔드개발백엔드개발프론트엔드백엔드개발안드로이드백엔드개발안드로이드백엔드프론트엔드....데코레이터 패턴을 적용하면개발 프론트엔드 백엔드 안드로이드개발프론트엔드 = 개발+프론트엔드개발백엔드 = 개발+백엔드개발안드로이드 = 개발+안드로이드개발안드로이드백엔드 = 개발+안드로이드+백엔드....  정의된 클래스로 모든 경우의 조합이 가능하다.장점  데코레이터 패턴은 기본적인 클래스에 추가할 기능이 다양하고 일정하지 않을 때 효율적이다.단점  연관 클래스들이 많이 필요하게 된다.  코드복잡도가 증가하여 가독성이 떨어진다클래스 다이어그램예제코드기본 기능을 하는 객체를 추상화/** * 기본 기능 즉 \"일한다\" 정의한 추상 클래스를 만든다 */abstract class Employee(var jobType: String = \"\") {    open fun showJobType() = jobType    abstract fun working(): String}/** * 추상클래스를 상속한 라이더클래스를 만든다 * 라이더 클래스의 기본업무는 음식배달이다. */class Rider(jobType: String) : Employee(jobType) {    override fun working() = \"음식배달\"}/** * 추상클래스를 상속한 개발자클래스를 만든다 * 개발자 클래스의 기본업무는 java개발이다. */class Developer(jobType: String) : Employee(jobType) {    override fun working() = \"java개발\"}업무를 추가할 수 있는 데코레이터 추상 클래스를 만든다abstract class CompanyWorkDecorator : Employee() {    // Employee 클래스를 상속할 때 추상 메소드가 아닌 메소드를    // 필요에 의해서 임의로 추상 메소드를 만들 수 도 있다.     abstract override fun showJobType(): String}데코레이터 추상 클래스를 상속하여 실제 추가에 사용할 클래스를 구현한다class RiderWithRepairVehicle(private var rider: Employee) : CompanyWorkDecorator() {    override fun showJobType() = rider.showJobType() + \"|수리기사\"    override fun working() = rider.working() + \"|오토바이수리\"}class RiderWithManagement(private val rider: Employee) : CompanyWorkDecorator() {    override fun showJobType() = rider.showJobType() + \"|관리자\"    override fun working() = rider.working() + \"|라이더관리업무\"}class DeveloperWithReactJs(private var rider: Employee) : CompanyWorkDecorator() {    override fun showJobType() = rider.showJobType() + \"|프론트엔드\"    override fun working() = rider.working() + \"|reactjs\"}class DeveloperWithSpringBoot(private val rider: Employee) : CompanyWorkDecorator() {    override fun showJobType() = rider.showJobType() + \"|백엔드\"    override fun working() = rider.working() + \"|springboot\"}  이 클래스들은 나중에 필요한 기능을 조합할 때 덧붙여 조합하여 최종 기능을 만드는데 활용된다.클라이언트// 개발자 기본 객체 단순히 일한다는 기능만 있음val developer = Developer(\"개발자\")// 개발자+ReactJS 개발 기능을 추가함val developerWithReactJs = DeveloperWithReactJs(developer)// 개발자+ReactJS+SpringBoot 개발 기능을 추가 하여 풀스택개발자를 만듬val fullStackDeveloper = DeveloperWithSpringBoot(developerWithReactJs)",
        "url": "/design-pattern/2020/05/19/decorator-pattern/"
    }
    ,
    
    "design-pattern-2020-05-18-composite-pattern": {
        "title": "컴포지트 패턴 - Composite Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "컴포지트 패턴은 하나 또는 하나이상의 객체이거나 상관없이 하나의 객체처럼 다룰 수 있게 해주는 패턴컴포지트 패턴 - Composite Pattern컴포지트 패턴이란  하나 또는 하나이상의 객체이거나 상관없이 하나의 객체처럼 다룰 수 있게 해주는 패턴이해를 돕기위한 설명컴포지트 패턴 미적용모든라이더들배달()    정규직라이더 정규직라이더 = new 정규직라이더()    파트타임라이더 파트타임라이더 = new 파트타임라이더()    배민커넥트라이더 배민커넥트라이더 = new 배민커넥트라이더()    정규직라이더.배달()    파트타임라이더.배달()    배민커넥트라이더.배달()    ...  모든 라이더타입들의 객체를 생성하고 배달 메소드를 모드 호출한다. 라이더타입이 추가될 때마다 코드는 수정 되어야 한다.컴포지트 패턴 적용모든라이더들배달()    for (라이더 : 라이더리스트)        라이더.배달()  모든 라이더타입은 인터페이스를 구현하도록 하고 리스트에 포함 된다.리스트를 순회 하여 배달() 메소드를 호출하도록 코드화함으로써 개별 객체생성 및 메소드 호출 코드가 제거 된다.라이더타입이 추가되어도 변경으로 부터 자유롭다.장점  하나던 여러개던 일관성있는 방법으로 객체를 사용가능하며 클라이언트 코드가 단순해짐  새로운 객체를 추가하는 것이 용이함 클라이언트 코드를 변경할 필요 없음단점  여러 종류의 객체를 일반화 시켰기 때문에 특정 객체에 제약 조건을 주거나 할 수 없다.클래스 다이어그램예제코드라이더타입별 클래스를 추상화interface Rider {    fun delivery(vehicle: String): String}class FullTimeRider : Rider {    override fun delivery(vehicle: String) = \"정규직\" + vehicle + \"배달\"}class PartTimeRider : Rider {    override fun delivery(vehicle: String) = \"시간제\"+ vehicle + \"배달\"}class ConnectRider : Rider {    override fun delivery(vehicle: String) = \"커넥트\"+ vehicle + \"배달\"}리스트로 관리되는 라이더객체들class AllTypeRider(private val riders: MutableList&lt;Rider&gt;) : Rider {    override fun delivery(vehicle: String): String {        return riders.joinToString(separator = \"\") { it.delivery(vehicle) }    }    fun add(rider: Rider) = riders.add(rider)    fun remove(rider: Rider) = riders.remove(rider)}  클라이언트에게 마치 하나의 객체를 다루는 방식으로 제공한다클라이언트class RiderService(private val allTypeRider: AllTypeRider) {    fun deliveryAllRiders(vehicle: String) =            allTypeRider.delivery(vehicle)}val allTypeRider = AllTypeRider(mutableListOf(FullTimeRider(), PartTimeRider(), ConnectRider()))// 새로운 라이더타입의 객체를 추가 할 수도 있다allTypeRider.add(NewRiderType())// 모든라이더의 배달 메소드를 호출한다.val riderService = RiderService(allTypeRider)val delivery = riderService.deliveryAllRiders(\"자전거\")  클라이언트는 하나의 객체처럼 다룬다.",
        "url": "/design-pattern/2020/05/18/composite-pattern/"
    }
    ,
    
    "design-pattern-2020-05-17-command-pattern": {
        "title": "커맨드 패턴 - Command Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "커맨드 패턴은 각각 형태가 다른 메소드를 추상화하여 클라이언트가 사용할 수 있도록 하는 패턴커맨드 패턴 - Command Pattern커맨드 패턴이란  커맨드 패턴은 각각 형태가 다른 메소드를 추상화하여 클라이언트가 사용할 수 있도록 하는 패턴이해를 돕기 위한 설명커맨트패턴 미적용운전(타입)    if (타입 == 오토바이)        오토바이 오토바이 = 오토바이()        오토바이.시동()        오토바이.가속핸들돌린다()    else if (타입 == 자전거)        자전거 자전거 = 자전거()        자전거.페달을밟는다()    ...              두종류의 이동 수단은 조작 하는 방법이 서로다르다    오토바이는 시동을 건다, 가속핸들을 돌린다, 자전거는 페달을 밟는다.    각 탈것 종류에 따라 운전하는 방법을 분기처리한다.    탈 것이 추가 되면 코드 수정이 필요하다.  커맨트 패턴 적용운전(배달명령)    배달명령.탈것운전()      여러 탈것을 운전하는 행위를 탈것운전()이라는 메소드를 추상화 하여 클라이언트에게 제공한다.    클라이언트는 배달명령이라는 일련의 메소드가 추상화된 배달명령의 탈것운전() 메소드만 사용한다.    탈 것 종류가 추가 되어도 코드 변경은 없다.  장점  기존 Code를 수정하지 않고, 새 명령을 쉽게 추가할 수 있다  명령의 호출자와 수신자의 의존성을 제거한다.단점  명령에 대한 클래스가 늘어난다.클래스 다이어그램예제코드오토바이/자전거 클래스class MotorCycle {    fun start() = \"오토바이시동\"    fun accelerate() = \"오토바이출발\"}class Bike {    fun pedaling() = \"자전거출발\"}명령 메소드를 추상화interface DeliveryCommand {    fun driveVehicle(): String}class MotorCycleCommand(private var motorCycle: MotorCycle) : DeliveryCommand {    override fun driveVehicle() =            motorCycle.start() + motorCycle.accelerate()}class BikeCommand : DeliveryCommand {    override fun driveVehicle() = bike.pedaling()}클라이언트class Rider(private var deliveryCommand: DeliveryCommand) {    fun changeDeliveryCommand(deliveryCommand: DeliveryCommand): Rider {        this.deliveryCommand = deliveryCommand        return this    }    fun delivery() = deliveryCommand.driveVehicle()}val motorCycleCommand = MotorCycleCommand(MotorCycle())val bikeCommand = BikeCommand(Bike())val rider = Rider(motorCycleCommand)// 오토바이를 운전한다.rider.delivery()// 자전거로 변경한다.rider.changeDeliveryCommand(bikeCommand)// 자전거를 운전한다.rider.delivery()  라이더 클라이언트는 분기문 없이 일관성있는 코드를 사용하며 로직변경이나 탈것의 추가에도 코드 수정에서 자유롭다.",
        "url": "/design-pattern/2020/05/17/command-pattern/"
    }
    ,
    
    "design-pattern-2020-05-16-chain-of-reponsibility-pattern": {
        "title": "책임 연쇄 패턴 - Chain Of Reponsibility Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "요청을 처리를 하나이상의 체인형태로 구성된 객체에게 위임하고 요청을 처리할 수 있는 객체를 만날 때까지 다음 객체로 처리를 위임하는 패턴책임 연쇄 패턴 - Chain Of Reponsibility Pattern책임 연쇄 패턴이란  요청을 처리를 하나이상의 체인형태로 구성된 객체에게 위임하고 요청을 처리할 수 있는 객체를 만날 때까지 다음 객체로 처리를 위임하는 패턴장점  요청의 처리 방식을 다음 객체로 위임하면서 분기처리가 없어진다.  요청의 처리를 layer 방식으로 나누어 처리하므로 객체간 결합도를 낮춘다.단점  요청을 처리하는 객체들을 어떻게 구성하느냐에 따라 요청이 처리될 수도 아닐 수도 있다.  무한루프에 빠질 수 있으니 잘 고려해서 구성 해야함클래스 다이어그램예제코드처리객체interface Rider {    fun delivery(foodType: String): String}class FullTimeRider(var next: Rider? = null) : Rider {    override fun delivery(foodType: String) =            if (foodType == \"양식\") \"양식배달\" else next!!.delivery(foodType)}class PartTimeRider(var next: Rider? = null) : Rider {    override fun delivery(foodType: String) =            if (foodType == \"한식\") \"한식배달\" else next!!.delivery(foodType)}class ConnectRider(var next: Rider? = null) : Rider {    override fun delivery(foodType: String) =            if (foodType == \"분식\") \"분식배달\" else next!!.delivery(foodType)}  처리할 수 없으면 다음 객체에 처리를 넘긴다.처리의 전체적인 구성은 인스턴스 생성시 어떻게 다음 객체들을 구성 했느냐에 따라 달라진다.클라이언트class RiderService(private val rider: Rider) {    fun delivery(foodType:String): String {        // 분기 처리가 사라진다.         // if (foodType == \"양식\")        //     val fullTimeRider = FullTimeRider()        //     fullTimeRider.delivery()        // else if (oodType == \"한식\")        //     val partTimeRider = PartTimeRider()        //     partTimeRider.delivery()        // else        // ....            return rider.delivery(foodType)    }  }val riderService = RiderService(FullTimeRider(PartTimeRider(ConnectRider())))val delivery = riderService.delivery(\"분식\")",
        "url": "/design-pattern/2020/05/16/chain-of-reponsibility-pattern/"
    }
    ,
    
    "design-pattern-2020-05-15-adapter-pattern": {
        "title": "어댑터 패턴 - Adapter Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "사용자는 어댑터 패턴의 인터페이스를 사용함으로써 각각 구현체의 세부로직과 변경에 관계없이 일관성있는 사용이 가능하다.어댑터 패턴 - Adapter Pattern어댑터 패턴이란  사용자는 인터페이스를 사용함으로써 각각 구현체의 세부로직과 변경에 관계없이 일관성있는 사용이 가능하다.현실에서 가장 이해하기 쉬운 예는 바로 만능 리모컨이다 사용자는 TV 종류에 따라 약간식 조작 방법이 다른 개별 리모컨을 이용하는 대신 만능 리모컨 하나만 사용한다. 그렇게됨으써 TV가 삼성에서 LG로 변경되더라도 그에 맞게 리모컨을 바꾸고 사용방법을 파악할 필요가 없는 것이다.이해를 돕기위한 설명어댑터 패턴 미적용 시로그인(타입)    if(타입 == 구글)        구글 구글 = new 구글()        구글.로그인페이지()        구글.인증()        구글.리다이렉트()    else         페이스북 페이스북 = new 페이스북()        페이스북.로그인페이지()        페이스북.로그인()    ...      로그인기능이 있다 구글인증을 사용해 로그인 하다가 페이스북 인증이 추가 되었다.    구글과 페이스북은 인증 절차가 상이하다.    구글인증이 필요하면 구글객체를 생성하고 인증한다.    페이스북인증이 필요하면 페이스북객체를 생성하고 인증한다.  어댑터 패턴 적용로그인(로그인서비스)    로그인서비스.로그인페이지()    로그인서비스.인증()    로그인서비스.리다이렉트()      나는 각각 필요한 인증업체의 인증 객체를 따로 사용하지 않고 만능 리모컨 같은하나의 인증서비스를 이용하고 싶다.    어댑터 패턴을 이용하면 서로다른 인증업체의 객체를 추상화하여 사용자에게 일반화된 인터페이스를 제공함으로써 인증업체의 종류에 따라 별개의 객체를 구분하여 사용할 필요가 없어진다.    인증업체가 추가 되거나 세부 로직이 변경되어도 클라이언트의 코드를 수정할 필요가 없다.  장단점클래스 방식 - 상속이용장점 - 어댑터(Adapter) 전체를 다시 구현할 필요가 없다.(빠르다)단점 - 상속(Generalzation)을 활용하기 때문에 유연하지 못하다.오브젝트 방식 - 인터페이스 이용장점 - 구성(Composition)을 사용하기 때문에 더 뛰어나다.(유연하다)단점 - 어댑터(Adapter)클래스의 대부분의 코드를 구현해야하기 때문에 효율적이지 못하다.클래스 다이어그램예제코드로그인어댑터를 추상화/** * 어댑터 인터페이스를 선언한다 */interface LoginAdapter {    fun goLoginPage(): LoginAdapter    fun requestLogin(id: String, pw: String): LoginAdapter    fun redirect(url: String): String}/** * 각각 어탭터 인터페이스를 구현한다 */class GoogleLoginAdapterImpl : LoginAdapter {    private val googleLoginService = GoogleLoginService()    override fun goLoginPage(): LoginAdapter {        googleLoginService.goLoginPage()        return this    }    override fun requestLogin(id: String, pw: String): LoginAdapter {        googleLoginService.requestLogin(id, pw)        return this    }    override fun redirect(url: String) = googleLoginService.redirect(url)}class FaceBookLoginAdapterImpl : LoginAdapter {    private val faceBookLoginService = FaceBookLoginService()    override fun goLoginPage(): LoginAdapter {        faceBookLoginService.goLoginPage()        return this    }    override fun requestLogin(id: String, pw: String): LoginAdapter {        faceBookLoginService.requestLogin(id, pw)        return this    }    override fun redirect(url: String): String {        // 페이스북 로그인은 redirect하지 않기 때문에 빈 메소드를 정의한다        return url    }}  구글, 페이스북 인증을 추상화한 인터페이스를 클라이언트에게 제공하고 개별 세부 구현체를 생성한다.추상화된 로그인어댑터를 사용하는 클라이언트class LoginService(private val loginAdapter: LoginAdapter) {    fun login(id: String, pw: String, redirectUrl: String) = loginAdapter            .goLoginPage()            .requestLogin(id, pw)            .redirect(redirectUrl)}val clientService = LoginService(FaceBookLoginAdapterImpl())val clientService2 = LoginService(GoogleLoginAdapterImpl())clientService.login(\"id\", \"pw,\", \"www.home.com\")clientService.login(\"id\", \"pw,\", \"new.home.com\")  클라이언트는 어떤 로그인서비스를 사용할지 스스로 판단하여 필요한 로직을 추가 구현할 필요없이 로그인 어댑터 인터페이스만 사용하면 된다.인증업체가 추가되어도 클라이언트코드는 변경이 없다.",
        "url": "/design-pattern/2020/05/15/adapter-pattern/"
    }
    ,
    
    "design-pattern-2020-05-14-abstract-factory-pattern": {
        "title": "추상팩토리 패턴 - Abstract Factory Pattern [디자인패턴/코틀린/kotlin]",
            "author": "kimchanjung",
            "category": "",
            "content": "추상팩토리 패턴은 어떤 연관된 클래스들을 팩토리를 통하여 일관성 있게 객체생성이 가능하도록 그룹으로 묶어 제공하고 변경도 유연하도록 제공한다.추상팩토리 패턴 - Abstract Factory Pattern추상팩토리 패턴이란  추상팩토리 패턴은 어떤 연관된 클래스들을 팩토리를 통하여 일관성 있게 객체생성이 가능하도록 그룹으로 묶어 제공하고 변경도 유연하도록 제공한다.이해를 돕기위한 설명추상팩토리 패턴 미적용라이더생성(라이더타입)    if (라이더타입 == 정규직)        정규직라이더 정규직라이더 = new 정규직라이더()        오토바이헬멧 헬멧 = new 오토바이헬멧()        오토바이 오토바이 = new 오토바이()    else if (라이더타입 == 파트타임)        파트타임라이더 파트타임라이더 = new 파트타임라이더()        자전거헬멧 헬멧 = new 자전거헬멧()        자전거 오토바이 = new 자전거()    else if ()    ...      고용형태가 각각 다른 음식배달라이더가 있다 정규직, 파트타임    라이더를 생성하기 위해서 고용, 헬멧, 이동수단 등의 객체구성은 비슷하나 세부 객체는 다르다.    구성은 같지만 라이더의 타입이 다르면 개별로 객체생성 해야한다.    라이더타입이 늘어나면 분기문도 늘어나고 코드도 수정해야한다.  추상팩토리 패턴 적용라이더생성(라이더팩토리)    라이더 = 라이더팩토리.라이더객체생성()    헬멧 = 라이더팩토리.헬멧객체생성()    이동수단 = 라이더팩토리.이동수단객체생성()      분기 처리 없이 일관성있게 라이더의 업무를 지시한다    라이더타입이 늘어나도 코드 수정이 없다.  장점  객체생성을 팩토리에 위임 느슨한결합  일련의 객체집합을 한번의 변경으로 모두 변경한다.  객체 집합을 생성할 때 일관성 유지(정규직라이더, 파트타임이동수단 이렇게 잘못 생성하는 경우 방지)  분기처리 제거단점  객체 집합군이 늘어 날수록 관련 클래스들이 늘어나고 설계가 복잡  객체 집합군에 새로운 객체가 생기면 모든 팩토리를 수정해야한다.정규직라이더 -&gt; 배달, 헬멧착용, 이동, 인데 생필품배달 이라는 메소드가 생기면 정규직, 파트타임 전부 생필품배달 메소드를 추가해야함클래스 다이어그램예제 코드업무가 가능한 라이더 생성에 필요한 라이더, 헬멧, 이동수단 클래스들을 추상화 한다.라이더interface Rider {    fun delivery(): String    fun repairVehicle(): String}class FullTimeRider : Rider {    override fun delivery() = \"오토바이배달\"    override fun repairVehicle() = \"오토바이수리\"}class PartTimeRider : Rider {    override fun delivery() = \"자전거배달\"    override fun repairVehicle() = \"자전거수리\"}  인터페이스를 구현 하도록 하여 클라이언트는 타입별 세부 구현을 알필요 없이 인터페이스만 사용한다.이동수단interface Vehicle {    fun start(): String    fun move(): String}class MotorCycle : Vehicle {    override fun start() = \"시동버튼\"    override fun move() = \"악셀\"}class Bike : Vehicle {    override fun start() = \"없다\"    override fun move() = \"페달\"}헬멧interface Helmet {    fun wear(): String}class MotorCycleHelmet : Helmet {    override fun wear() = \"오토바이헬멧착용\"}class BikeHelmet : Helmet {    override fun wear() = \"자전거헬멧착용\"}라이더, 헬멧, 이동수단 객체를 생성하는 팩토리 클래스를 추상화interface RiderFactory {    fun getRider(): Rider    fun getHelmet(): Helmet    fun getVehicle(): Vehicle}// 팩토리 클래스는 싱글톤으로 선언한다.object FullTimeRiderFactory : RiderFactory {    override fun getRider() = FullTimeRider()    override fun getHelmet() = MotorCycleHelmet()    override fun getVehicle() = MotorCycle()}object PartTimeRiderFactory : RiderFactory {    override fun getRider() = PartTimeRider()    override fun getHelmet() = BikeHelmet()    override fun getVehicle() = Bike()}  Client 코드에서 필요한 객체를 직접 생성하지 않고 팩토리를 통하여 생성한다.라이더 객체를 사용하는 Clientclass RiderService(private val riderFactory: RiderFactory) {    fun work(): String {        val rider = riderFactory.getRider()        val helmet = riderFactory.getHelmet()        val vehicle = riderFactory.getVehicle()        return rider.delivery() + helmet.wear() + vehicle.move()    }}// 라이더의 종류를 선택하여 팩토리를 매겨변수로 넘겨준다.// 클라이언트가 원하는 종류를 선택하여 사용한다.val riderService1 = RiderService(FullTimeRiderFactory)val riderService2 = RiderService(PartTimeRiderFactory)assertEquals(\"오토바이배달오토바이헬멧착용악셀\", riderService1.work())assertEquals(\"자전거배달자전거헬멧착용페달\", riderService2.work())  라이더를 생성하여 사용하는 Client는 라이더 타입별 객체생성이 분기처리 없이 일관성있게 사용가능한 형태로 변경되었다.",
        "url": "/design-pattern/2020/05/14/abstract-factory-pattern/"
    }
    ,
    
    "tech-2020-05-08-react-mobx": {
        "title": "[Mobx] React 에서 Mobx 사용기",
            "author": "kimchanjung",
            "category": "",
            "content": "react와 mobx그리고 material-ui를 이용한 개발기와 예제코드를 통한 mobx vs react 차이점 비교 및 atomic design을 통한 프로젝트구조 react 서드파티 라이브러리 리뷰정보등을 알아봅니다.React에서 Mobx 경험기 (Redux와 비교기)안녕하세요 딜리버리플랫폼팀 김찬정입니다.이 글의 목적React와 함께 사용하는 State(상태)관리 라이브러리중 가장 많이 사용되고 있는 Redux와 또 다른 라이브러리인 Mobx를 직접 사용하여 개발해 보고 느낀 차이점과 Mobx만의 장점, 그리고 Java Spring Framework와 Mobx의 유사성을 예제 코드와 함께 비교 해보려고 합니다.  많은 분들이 React 자체 보다는 Redux를 적용 하기 위해서 경험하는 러닝커브가 생각보다 높아서 React가 어렵다고들 느끼시는 것 같고 저도 공감이 되는 부분이긴 합니다. 하지만 초반 러닝커브를 극복하면 단순히 React만 사용 했을 때보다 장점들이 분명히 있기 때문에 State관리 라이브러리를 사용하는 것이 결론적으로 더 낫다고 개인적으로는 생각합니다. (이유는 이후에 설명하도록 하겠습니다.) 그런 맥락에서 Mobx는 Redux에 비해서 눈에 띄는 강력한 장점들이 있습니다. 용어 설명 이후에 바로 장점을 이야기 해보도록 하겠습니다.  이 글은 경험에 의한 지극히 주관적인 견해임을 미리 밝혀 둡니다.튜토리얼 개념으로 예제 코드를 작성한 것이 아닌, 부연설명을 위한 목적이므로 코드상 빠진 부분이 있음을 미리 밝힙니다.Overview  Mobx의 장점과 특징(예제코드)  Mobx와 Redux의 비교 (예제 코드)  Mobx와 Java Spring의 유사성(예제 코드)  React 개발시 효율적인 Directory 구조와 예시 (Atomic Design)  React Component를 구분 하여 사용하는 예  Redux와 일반적으로 같이 사용하는 라이브러리들  React용으로 재구성된 UI 라이브러리들의 적용기 및 장단점(Material-UI, React-Bootstrap, Reactstrap)분석  Redux Form Validation 라이브러리들의 적용기 및 장단점 분석  Mobx Model 라이브러리들의 적용기 및 장단점 분석용어 설명ReactJavascript Web Front-End Rendering 라이브러리 중 하나  보통 Single Page Application Framework가 대부분의 기능을 포함 하고 있는 반면에 React는 대부분의 기능을 포함하고 있는. Framework가 아니라 View를 Rendering 하는 것이 주 기능이며 나머지 기타 기능들(router, ajax등등)은 서드파티 라이브러리를 추가적으로 사용해야 한다.ComponentReact에서 데이터를 화면에 렌더링하는 가장 기본이 되는 단위 라고 할 수 있겠습니다. React.Component를 상속하는 클래스형태의 Component와 함수형태의 Component 두가지 형태를 가지고 있으며 목적에 따라 구분해서 사용합니다. React는 작은 단위 부터 큰단위의 Component의 조합으로 구성되며 상단메뉴, 검색폼, 검색 데이터 그리드와 같이 Component를 분리하여 개발하고 각각을 적절히 조합하여 하나의 Page를 구성하는 형태로 개발 합니다.StateReact Component에서 변경가능한 데이터를 state라고 부릅니다.  본 포스팅에서 데이터와 State는 거의 같은 의미로 사용됩니다.Props자식 컴포넌트가 부모 컴포넌트로 부터 Parameter로 받아 오는 값을 말하며 변경을 할 수 없습니다.StoreGlobal영역에서 애플리케이션의 State와 비즈니스로직을 가지고 있고 있는 주체를 Store라고 합니다.  State를 Global한 영역에서 관리한다는 말은 즉 State관리 라이브러리 사용의 목적중 한가지 입니다.  Redux에서는 State와 State를 핸들링하는 비즈니스로직을 가지고 있는 Reducer, Action등을 포함하는 의미 이기도 하지만, Mobx에서 Store는 명확히 State와 비즈니스로직을 포함하는 Class를 Store라고 부릅니다.ReduxFlux개념을 바탕으로한 React에서 현재 가장 많이 사용되는 State 관리 라이브러리 입니다.MobxRedux와 또 다른 State관리 라이브러리이며 이글을 작성하는 목적의 라이브러리입니다. 기본적으로 객체지향 느낌이 강하며 Component와 State를 연결하는(Redux와 달리) 번잡한 보일러플레이트 코드들을 데코레이터(애노테이션)제공으로 깔끔하게 해결합니다.  추후 예제 코드를 보면 아시 겠지만 데코레이터를 사용하는 장점이 얼마나 큰지 느끼실 수 있습니다.ObservableMobx에서 Rerendering 대상이 되는 state(상태, 값)를 관찰 대상(observable value)라고 칭하며 @observable 데코레이터로 지정한 State는 관찰대상으로 지정되고 그 State는 값이 변경될 때 마다 Rerendering됩니다.  이것이 사실 Mobx가 동작하는 가장 기본 개념입니다.불변성React에서 렌더링을 할 때 판단 하는 방법은 State가 변경 되었을 때 인데 변경전/변경후 State를 서로 비교 할 때 복잡도가 높은 객체의 경우 자식 Property까지 비교하는 것 보다 효율적인 방법으로 State의 레퍼런스가 변경되었을 때 변경된 것으로 간주 하고 렌더링을 합니다. 이경우 기존 State 값을 직접 변경하는 것이 아니라. 기존 State값을 바탕으로 변경되어 새로 생성된 객체의 레퍼런스를 setState 메소드를 통하여 변경하는데, 이것을 즉 불변성을 유지한다 라고 표현합니다.Mobx의 장점객체지향적보다 객체지향적입니다 ES6에서 추가된 Class를 이름뿐인 Class가 아니라 객체지향적으로 사용하고 개발하는 것을 권장하고 있습니다.  도메인모델로 분리됨으로 써 집중된 비즈니스 로직은 적절히 분산되고 도메인간의 상호작용은 message를 주고 받는 형태로 구현 할 수 있습니다.서버개발자들에게 친숙한 아키텍쳐Java Spring Framework와 유사한 아키텍쳐구조를 지향하고 있어 서버개발자들에게 보다 친숙하고 낮은 러닝커브를 제공, 장점을 그대로 적용할 수 있습니다. (흥분되는 부분 이기도 합니다)Decorator데코레이터(java 애노테이션과 유사하다고 보면 된다)를 제공하기 때문에 Redux를 사용할 때 React Component와 state를 연결 하기위한 mapStateToProps, Redux action을 연결을 위한 mapDispatchToProps 그리고 bindActionCreators…. 등등의 보일러플레이트 코드가 사라지고 데코레이터가 처리하기 때문에 너무나도 깔끔한 코드가 생성됩니다.  Redux로 개발 해보신 분이라면 느끼시겠지만 보일러플레이트 코드들의 양 만만하지 않고 또 그런 코드들을 작성하기 위해서는 어느정도 학습이 동반되어야 합니다.  Redux가 어렵다가 아니라 React가 Vue보다 어렵다고 하는 이유에도 이부분도 한 몫하는 것 같습니다.캡슐화Mobx Configuration 설정으로 State를 오직 메소드를 통하여 변경할 수 있도록 Private하게 관리 할 수 있습니다.  Javascript는 기본적으로 접근제어자를 제공하지 않아서 데이터 핸들링 비즈니스 로직이 펴져 버리고, 사이드 이펙트가 발생할 확률이 높고 또한 잘 관리하지 않으면 번잡스러운 코드가 생산되기 쉽습니다.  하지만 접근제어자가 없다고 해도 캡슐화를 구현할 수 있는 방법들이 있긴하지만 잘 활용되어 지지는 않습니다.  Mobx는 Configuration에서 옵션 한줄로 state의 변경은 해당 클래스의 메소드를 통해서만 변경할 수 있도록 할 수 있고  도메인 모델간의 message를 통한 상호작용 코드 패턴을 유지해 나갈 수 있도록 해줍니다.불변성 유지를 위한 노력이 불필요State의 불변성을 유지하기 위해서 번잡스러운 코드나 ImmutableJs같은 라이브러리를 따로 사용할 필요가 없습니다. 이것이 왜 장점이 되냐 하면 불변성을 유지하면 서 State를 변경하는 코드는 Object가 Depth가 깊어지게 되면 코드의 가독성이 매우 떨어집니다. 그래서 ImmutableJs 라이브러리를 사용하게 되는데 Redux와 같이 사용하게 될 경우 여러가지 설정이 필요하고 추가적인 라이브러리도 필요할 뿐 만 아니라 추가적인 학습도 동반 되어야 합니다.State관리 라이브러리 사용 목적다중 계증 컴포넌트에서 데이터와 메소드 접근의 복잡성 해결여러개의 Component 컴포넌트가 조합되에 페이지가 구성된다고 할때 Component간 상호작용 즉 데이터(State, Props)와 메소드의 접근이 까다롭게 됩니다. SPA 개발이 없던 시절 서버렌더링 페이지에서 Jquery로 Dom을 조작하고 함수를 호출 할때는 Global Scope에서 대부분 이루어져서 크게 문제가 없었습니다. 그러나 기능 단위의 Component로 이루어진 최근의 SPA Framework에서는 부모자식의 관계로 Scope이루어져 있기 때문이 각 Component간 state와 method 접근이 복잡해 질수 있습니다. 이를 해결하기 위해서 State를 Global한 Store영역에서 관리하는 방법을 사용하여 state와 method의 접근이 용이 하게 됩니다.컴포넌트에 집중된 비즈니스 로직의 분리State관리 라이브러리 없이 React Component로만 개발하게 되면 거의 대부분의 비즈니스로직이 Component에만 집중되게 되고 코드는 점점더 스파게티화 되기 마련입니다. 하지만 State관리 라이브러리를 사용하게 되면 Component는 Controller에 해당하는 역할을 주로 하게 두고 나머지 로직은 적절히 분리하여 아키텍쳐를 구성할 수 있는 이점이 있습니다.  복잡한 페이지의 프로그램이 아니라면 사용할 필요가 없다는 의견도 있지만, 개인적으로는 실무에서 가장 기본적인 형태의 페이지라도 비즈니스로직을 분리하지 않고도 깔끔하게 코드를 유지할 정도으 규모는 보지 못해서 사용하는 편이 낫다고 생각이 됩니다. 어디까지나 개인적인 경험에서 오는 견해임을 밝혀 둡니다.Mobx에 앞서 Redux  Redux에 비해 Mobx를 사용했을 때 장점을 이야기 하는 것 이지 State관리 라이브러리인 Redux를 사용하는 것 자체를 단점으로 이야기하는 것이 아닙니다. 다시 생각해도 State관리 라이브러리 없는 Component만 가지고 개발 하는 것 보다 다소 러닝커브가 있더라도 개인적으로는 State 관리 라이브러리를 사용 할 것 같습니다.Redux의 데이터 흐름다음 이미지는 Google로 ‘redux diagram’ 키워드로 검색했을 때 검색된 결과 들입니다. 리덕스의 개념을 설명하는데 Data Flow Diagram이 자주 등장 합니다. Action, Reducer, Dispatcher, Store, View 이런 개념들은 사실 State를 렌더링 하고 변경하기 위한 어떤 메소드 즉 서비스 같은 것을 가져다 그냥 사용하는 것 뿐인 데 개념을 장황하게 설명합니다. 그리고 그것들이 상호 작용하기 위해서 추가 해주는 보일러플레이트 코들이 매 Component마다 추가 해주어야합니다. 컴포넌트와 리덕스를 연결하기위해서 mapStateToProps, mapDispatchToProps 함수를 사용하고 Action을 정의 하고.. 등등 Javascript의 높은 문법 자유도 때문에 예제 코드들의 선언 방식 또한 자유 분방합니다. 바로 이런 것들이 React가 다소 어렵다라는 인식을 주게되는 하나의 요인 같댜는 생각이 개인적으로 들기도 합니다.그림 1. redux diagram 키워드 검색한 결과Redux의 테크트리?Redux를 사용하다보면 redux-thunk, redux-saga, reselect 등등 관련 라이브러리들이 등장합니다. 아래 링크는 어떤 개발자가 약간? 위트를 가미한 React + Redux를 개발하는 개발자가 겪게 되는 일련의 흐름을 포스팅 한 내용입니다. 리액트개발자가 겪게되는 길  Redux를 사용하기 위해 더 많은 라이브러리를 선택하고 사용해야 하는 고민에 빠지게 되는 점도 React가 어렵다(Redux가 어려운 것 인데.)라고 인식하게 되는 요인중 하나라로 생각됩니다.본격적으로 Mobx앞서 언급한 대로 Mobx는 Redux와 비슷한 종류의 State관리 라이브러리입니다. 위 언급한 Redux와는 다르게 너무나도 간결하고 깔끔한 구조를 가지고 있습니다.Mobx의 기본개념 및 특징Mobx의 State(데이터)의 흐름과 핵심 개념을 간단하게 표현 해보았습니다. 사실 더 자세한 개념은 공식문서에 있지만 이해하는 데 방해가되는 개념은 제외하고 제가 이해한 부분을 간략하게 그려보았습니다. 배달 리스트를 가져오기 위해서 DeliveryStore(Spring의 서비스의 역할과 거의 비슷하다)의 findAllDeliveries를 호출하여 서버로 부터 가져온 데이터를 선언해둔 deliveries state에 할당 해주면 DeliveryComponent에서 deliveries 를 Rendering 하게 되는데 이것이 기본 동작 개념입니다. 기타 Mobx Store와 React 컴포넌트를 연결하는 방법은 Redux와 달리 @inject 데코레이더 한줄로 이루어 집니다. 물론 그외 여러가지 기능을 하는 데코레이더 들이 제공되고 있으며 설명은 이후 자세히 하겠습니다.그림 2. mobx 데이터 흐름Mobx의 아키텍쳐Mobx는 렌더링 할 State를 관찰대상으로 지정, State를 변경하면 React Component Render 메소드에 의해서 Rerendering 되는 아키텍쳐를 기본 골격으로 합니다. 예제와 함께 Mobx의 작동 방식과 특징을 알아 보겠습니다. 마치 Java Spring Framework유사한 Layer 아키텍쳐를 가지고 있고 실제로 그런식으로 Layer를 분리하여 아키텍쳐를 구성하는 것을 권장하고 있습니다.표 1.spring과 mobx layer 비교Store = ServiceJava Spring Service와 비슷한 역할을 합니다. 차이점 이라면 BackEnd Server의 Service(Spring)에서는 다수의 요청자에 의해서 요청 되기 때문에 특별한 상황이 아니라면 상태를 가지고 있지 않는데 Mobx Store는 observable한 state(상태)를 가지고 있다는 점 입니다. Client는 사용자와 1:1 이기 때문에 서버측의 Service에서 상태와는 상황이 다릅니다. 하지만Store는 싱글톤으로 유지 해야 합니다. 만약 싱글톤이 아니라면 Component에 Inject된 Store는 매번 새로운 Instance가 되고 Observable State가 따로 생성되어 지게 됩니다. 이런 경우 상단 메뉴 바의 크기를 변경하는 Store를 각각 페이지에서 Inject하여 changeMenuBarSize라는 메소드를 통하여 menuBarSize라는 State를 변경한다고 하면 싱글톤이 아닐 때는 menuBarSize = ‘50px’라고 변경해도 menuBarSize는 실제 메뉴바의 사이즈를 가지고 실제 렌더링하는 state가 아닌 개별 Instance Store의 State일 것 입니다.@Autobindclass RiderStore {  @observable  riderList = [];  constructor(rootStore) {    this.rootStore = rootStore;  }  // 비동기인 경우 @action 대신 @asyncAction  @asyncAction  async *findAll(params) {    const { data, status } = yield riderRepository.findAll(params);    this.riderList = data.map(rider =&gt; new RiderModel(rider));  }  // 라이더 리스트에서 특정 요소를 제거 하는 메소드 인데 @observable로 지정된 property의  // 변경은 store의 메소드에 의해서만 가능하다(@action decorator를 추가한)  // 그렇게 때문에 비즈니스 로직이 여기저기 퍼져 나가는 것을 애초에 막을 수  // 있어서 객체지향적인 코드를 유지 해 나갈 수 있다.  @action  removeRider(index) {    this.riderList.splice(index, 1);  }  // 비즈니스 로직이 포함된 getter다 @computed 데코레이터는 반환하는 값이 변경되 었을 때  // rerendering을 하는데 값이 변경 되었다 하더라도 변경되기 전과 같은 값이라면 불필요하게   // rerendering을 하지 않는다.  @computed  get activeRiders() {    return this.riderList.filter(rider =&gt; rider.isActive);  }}export default RiderStore;코드 1.Mobx의 StoreRepository = RepositoryMobx Repository는 Ajax로 데이터를 가져오는 부분입니다. 데이터를 가져오는 부분도 Layer를 나누어 구성하는 것을 권장하고 있습니다. 비즈니스 로직 분리의 이점도 있지만 Test 코드 작성 시 Mocking이 용이 하다는 장점도 있습니다. (물론 ajax 자체를 mocking 할 수 있는 라이브러리도 있지만)class RiderRepository {  URL = \"/v1/api/riders\";  constructor(url) {    this.URL = url || this.URL;  }  findAll(params) {    return axios.get(`${this.URL}`, { params });  }  findOne(riderAccountId) {    return axios.get(`${this.URL}/${agencyId}`);  }}// 싱글톤으로 리턴 (매번 새로운 객체를 생성 할 필요가 없다면 처음 부터 싱글톤으로 export)export default new RiderRepository();코드 2. Mobx Repositry LayerModel = Entity or DtoSpring의 Entity/Dto 와 유사하다고 보면 됩니다. 도메인 로직을 Model Layer에 구성하는데 차이 점이라면 미리 필드 (property)들을 선언 하지 않아도 Object.assign 사용해서 동적으로 추가하면 되기 때문에 특별히 미리 선언할 필드가 없다면 아래 처럼 간단하게 선언 할 수 있습니다. extendObservable은 Mobx가 제공하는 api로 Object.assign 처럼 property와 값을 Target 오브젝트에 합쳐 주는데, 특징이라면 관찰 가능한(Rerendering 대상이 되는 값으로 만들어 추가해준다) Property로 만들어 추가합니다. 합치려는 객체의 Property가 이미 선언 되어 있는 경우는 사용 할 수 없기 때문에 그런경우는 Mobx에서 제공하는 set api를 사용하면 됩니다.미리 선언된 property가 없고 서버에서 받아온 JSON을 RiderModel로 생성하는 가장 심플한 예@Autobindclass RiderModel {  constructor(data) {    extendObservable(this, data);  }  // 라이더명과 지점명을 합친 getter  // 모델 자신의 비즈니스로직을 가지고 있다. 모델 레이어가 없다면 아마도 아래 예제 처럼  // 비즈니스 로직이 널리 퍼졌을 것이다.  @computed  get riderWithAgency() {    return `${this.riderName}(${this.agencyName})`;  }    @action  changeRiderName(riderName) {    this.riderName = riderName;  }    // 렌더링 대상이 아니면 @computed는 필요없다.  isActive() {    return this.status === 'ACTIVE';  }}export default RiderModel;코드 3. Mobx Model Layer - extendObservable미리 선언된 Property가 있는 Model에 서버에서 가져온 JSON으로 객체를 생성하는 경우@Autobindclass RiderModel {  @observable  riderName;  constructor(data) {    set(this, data);  }  @computed  get riderNameWithAgency() {    return `${this.riderName}(${this.agencyName})`;  }  @action  changeRiderName(riderName) {    this.riderName = riderName;  }}export default RiderModel;코드 4. Mobx Model Layer - setModel Layer가 없는 경우 비즈니스 로직의 집중일반적으로 Model Layer 없이 JavaScript 개발을 해왔다면 아마도 이런 식으로 Component에 비지니스 로직이 집중 되었을 것입니다.// 이런형태의 배열 데이터가 있다고 하자.let riderList = [  {    name: '홀길동'    age: 24,    agencyName: '강남지점'  },  {    name: '이순신'    age: 34,    agencyName: '송파지점'  }]export default class SearchRider extends React.Component{   componentDidMount() {    // Component가 Mount될 때 서버에서 라이더 리스트를 가져오는 로직    const riders = axios.get('http://www.rider.com/api/riders')      .then(function(response) {        response.data.map(rider =&gt; {          rider.riderNameWithAgency = `${this.riderName}(${this.agencyName})`;          return rider;        })      }    );    this.setState({riders});  }  // 특정 라이더의 이름을 변경하는 경우의 로직도 Component 메소드에..  chanageRiderName = (riderName, riderId) =&gt;{    this.state.riders.map(rider =&gt; {      if (rider.riderId === riderId) {        rider.riderName = riderName;      }      return rider;    })    this.setState({       riders:this.state.riders    })  }  render(){    .........  }}코드 5. Component에 집중된 비즈니스 로직.  위 예제 처럼 도메인 로직이 해당 컴포넌트에 있었을 것이다 이런 것들이 한두개씩 늘어나면 Component는 그야말로 hell이다ObservableRendering 대상이 되는 State를 관찰 대상이라고 칭하고 @observable 데코레이터로 Observable State로 만들어 줍니다. Presentational Component에서 값이 변경될 때 마다 값이 반영 되어 보여지게 됩니다.@Autobind // javascript this bind를 자동으로 해주는 데코레이(arrow function 사용 없이)export default class SearchRiderStore {  // 라이더 리스트 state를 렌더링 할 것 이고 @observable 데코레이터를 추가하면 선언됩니다.  @observable  riderList = [];  constructor(rootStore) {    // rootStore를 통하여 다른 store(spring 서비스라고 생각하면 이해가 쉽다.)를 사용 할 수 있다.    // rootStore.deliveryStore.findAll() &lt;- 이런식으로    this.rootStore = rootStore;  }  @asyncAction  async *findAllRider(params) {    const { data, status } = yield riderRepositiry.findAll(params);    if (status === 200) {      this.riderList = data.map(rider =&gt; new RiderModel(data));    }  }}코드 6. 라이더 리스트 데이터를 핸들링하는 역할을 하고 있는 Mobx Store위에 선언된 SearcRiderStore에 riderList는 아래와 같이 렌더링 state로 사용됩니다.// @inject 데코레이터 만으로 쉽게 riderStore를 inject한(redux와 비교하면 정말 간단하다)@inject(\"searchRiderStore\")@observer // mobx observable state 를 rerendring 하기위에선언해준다@Autobind // arrow function 없이 this를 자동으로 바인딩시켜준다.export default class SearchRiderContainer extendsReact.Component {  constructor(props) {    super(props);  }  componentDidMount() {    const { searchRiderStore } = this.props;    // 컴포넌트가 마운트 되면 라이더를 가져온다    searchRiderStore.findAllRider();  }  render() {    const { riderList } = this.props.searchRiderStore;    // 라이더 리스트를 데이블로 렌터링    return ;  }}코드 7. Component에서 RiderStore를 연결하고 RiderList를 렌더링  Mobx의 Observable State가 작동하는 경우와 그렇지 않는 경우는 공식문서에 나와 있는 설명을 잘 살펴 보아야 합니다.분명히 @observable 데코레이터로 지정하고 값을 변경했는데 Rerendering이 되지 않는 경우의 케이스를 잘 파악해 놓아야 삽질을 피할 수 있습니다.Mobx와 Redux의 비교이제 부터 Mobx와 Redux의 차이점을 예제 코드와 함께 비교해 보도록 하겠습니다.같은 역할을 하는 두 라이브러리의 Layer(또는 라이브러리)표 2. Mobx와 Redux Layer 비교Service Layer - Store(Mobx) VS Reducer(Redux)Service Layer의 역할을 담당하는 Mobx의 Store와 Redux의 Reducer를 예제 코드를 통하여 비교해 보도록 하겠습니다. 역할은 비슷하지만 선언 방식이 각각 Class, Function으로 스타일이 서로 다르고 Redux의 경우 ACTION 타입을 정의하고, ACTION을 생성하는 행위들이 추가로 들어가야 된다는 차이가 있습니다. 코드상으로는 Mobx의 Class 선언 방식이 서버개발자들에게 익숙해 보이는 모양새 입니다.Reducer - ReduxRedux에서 실제 비즈니스 로직을 담당하는 곳이라고 이해하면 될 듯 합니다.  Redux에서 Action정의, Action생성 , Reducer생성 등이 각각 개별 파일에 하는 것이 기본 예제인데 구지? 라는 의문이 생겼고 그래서 그런지 ducks pattern 이라는 Action 정의, 생성 Reducer 생성을 하나의 파일에 하는 pattern이 있습니다. (Redux를 하다보면 계속 뭐가 나옵니다. 이런 점이 Redux가 아니라 React가 어렵다는 오래를 불러 일으킵니다.)ACTION TYPE 정의// RiderActionType.js// ACTION 타입을 정의 한다. 정의한 액션 타입으로 액션을 생성하고// 추후 React Component에서 action을 디스패치하면 해당하는 액션타입에// 매핑된 리듀서가 호출된디..... 뭔가 번잡const FIND_ALL = \"rider/FIND_ALL\";const REMOVE_RIDER = \"rider/REMOVE_RIDER\";const ACTIVE_RIDERs = \"rider/ACTIVE_RISERS\";코드 8. action을 정의ACTION을 생성// RiderAction.js// 정의된 ACTION 타입을 가지고 ACTION을 생성한다.export function findAll(data) {  return {    type: type.FIND_ALL,    payload: {      data    }  };}export function removeRider(index) {  return {    type: type.REMOVE_RIDER,    payload: {      index    }  };}export function activeRider() {  return {    type: type.REMOVE_RIDER  };}코드 9. action을 생성정의된 Action이 Dispatch 되었을 때 수행될 로직이 있는 Reducer// RiderReducer.js// 정의된 액션션에 해당하는 비즈니스로직을 구현한다..const initialState = {  riderList: []s};function riderReducer(state = initialState, action) {  switch (action.type) {    case types.FIND_ALL:      return {        ...state,        riderList: action.payload.data      };    case types.REMOVE_RIDER:      return {        ...state,        riderList: state.riderList.splice(action.payload.index, 1)      };    case types.ACTIVE_RIDERS:      return {        ...state,        activeRiders: state.riderList.filter(rider =&gt; rider.status === \"ACTIVE\")      };  }}코드 10. Reducer.Getter(Mobx getter와 유사한)에 해당하는 reselect를 이용한 로직import { createSelector } from \"reselect\";const getRiderList = rider =&gt; rider.riderList;const activeRiders = createSelector(  [getRiderList],  riderList =&gt; riderList.filter(rider =&gt; rider.status === \"ACTIVE\"));export default {  getRiderList,  activeRiders};코드 11. getter역할을 하는 reselect.React Component에서 Redux와의 연결class RiderContainer extends React.Component {  constructor(props) {    super(props);  }  componentDidMount() {    const { riderAction } = this.props;    console.info(\"onSubmitSearchRider\", values);    riderAction.findAll(values);  }  render() {    const { riderList } = this.props.riderStore;    return ;  }}// Component와 Redux에 연결하기 위한 구문이 Component 아래에존재하는데. mobx는 @inject 데코레이트 하나면 연결되는데// Redux는 명시적인 연결로직이 필요하다. mapStateToProps,mapDispatchToProps, bindActionCreators// 의 이해와 사용 법을 알아야 하고 계속 이야기하는 javascript 문법자유도 때문에 예제들의 형식도 제각각이라 무척이나// 학습하는데 가독성을 많이 떨어 뜨린다..// 간단한 예제이지만 데이터와 메소드가 많아지면 복잡도는 무척이나 높아진다.export default connect(  // mapStateToProps  state =&gt; {    const rider = state.[\"rider\"]);    return {      findAll: SearchRiderSelector.getRiderList(rider),      activeRiders: SearchRiderSelector.activeRiders(rider),    };  },  // mapDispatchToProps  dispatch =&gt; ({    riderAction: bindActionCreators(SearchRiderAction.searchRider, dispatch),  }))(RiderContainer);코드 12. React Componet와 Redux의 연결.  개인적으로 느낀 아쉬운 점을 나열해 보자면      어떤 행위를 하기위한. 하나의 메소드를 정의 하기위하여 3가지 즉 ACTION 타입정의, ACTION생성, REDUCER 생성 해줘야 하는 것이 조금 번잡 스럽다는 느낌을 받았다.    실제 비즈니스 로직이 들어가는 부분의 예제가 swich case문으로 되어 있어 생소한 느낌이 많이 아쉬었다. (실제로 redux를 사용해서 개발 할때는 사실 메소드를 분리해서 했다.)    Javascript의 문법적 자유도가 높은 특징 때문에 다양한 방식으로 선언된 예제들을 보면 혼란이 가중되고 코드 가독성이 떨어지는 느낌을 받았다.    그런 불편 때문에 보일러 플레이트를 줄여주는 단순한 기능을 하는 라이브러리나, Util이 많이 존재하는데 Action을 생성 해주는 createActions, Action과 Reducer를 매핑해주는 handleActions Component와 Redux연결을 위한 mapStateToProps, mapDispatchToProps, bindActionCreators getter로직의 성능을 위해서 reselect(mobx @computed 처럼 값이 변경되었다 하더라도 동일한 값이면 불필요하게 다시 렌더링하지 않는다)등등 이런 라이브러리등을 선택하고 학습하는 것 또한 Redux러닝 커브를 높이는데 한 몫을 하는 것 같다  Store - MobxMobx의 Store는 Java Spring의 Service와 유사한 역할을 하며 내부 상태가 존재한다는 것이 차이점이라고 할 수 있습니다. Mobx의 상태(State)는 @observable(관찰가능한)로 지정하여 React Component에서 렌더링될 state로 사용합니다. React Component에서 사용할 Mobx Store의 Dependency Injection은 @inject 데코레이터 하나로 끝나는데 Redux에서는 mapStateToProps, mapDispatchToProps, 등의 함수로 연결 해줘야하는 번잡스러운 보일러플레이트 코드에 비해서 너무나도 간결하고 가독성도 뛰어납니다.@Autobindclass RiderStore {  @observable  riderList = [];  constructor(rootStore) {    this.rootStore = rootStore;  }  @asyncAction  async *findAll(params) {    const { data, status } = yield riderRepository.findAll(params);    this.riderList = data.map(rider =&gt; new RiderModel(rider));  }  @action  removeRider(index) {    this.riderList.splice(index, 1);  }  @computed  get activeRiders() {    return this.riderList.filter(rider =&gt; rider.status === \"ACTIVE\");  }}코드 13. Mobx Store.React Component에서 Mobx Store를 Inject하는 방식// inject 데코레이터로 riderStore를 inject 한다. reactcomponent의 props으로 접근할 수 있다.// observer는 mobx가 @observable로 지정된 state를 적절히rerendering시킨다@inject(\"riderStore\")@observerclass RiderListContainer extends React.Component {  fetchRiderList() {    const { riderStore } = this.props;    riderStore.findAll({ page: 0 });  }  render() {    const { riderList } = this.props.riderStore;    return ;  }}코드 14. React Component에서 Mobx Store를 Injection.Repository Layer - class(Mobx) VS redux-thunk 또는 redux-saga(Redux)Api 호출같은 비동기 Action의 경우 Redux에서는 redux-thunk라는 라이브러리를 주로 사용 하다가 최근에는 redux-saga라는 라이브러리로 옮겨가는 추세입다. 특히나 redux-saga는 es6 generator를 사용하여 callback 메소드 없이 사용할 수 있는 장점 때문에 옮겨 가는 추세이긴 하지만 사용방법 자체는 러닝커브도 있는 편이고 익숙하지 않는 형태입니다. 그에 반에 Mobx는 Ajax call 하는 메소드를 Class로 정의 해놓고 Store에서 async/await, 또는 generator 를 사용하여 callback 없이 사용하면 됩니다.  별도의 추가 라이브러리를 사용할 필요가 없으며 문법적인 깔끔함을 유지하기 위해서 @asyncAction데코레이터, flow 같은 함수도 제공하기 때문에 제법 깔끔한 코드로 작성이 된다.Redux-Saga - Redux비동기 Action을 처리하기위한 라이브러리인 Redux-Saga를 사용하여 비동기 Action을 구현 합니다. ES6 Generator를 사용하기 때문에 Callback Method 없이 구성이 가능한 장점이 있습니다. Redux-Saga 역시 Action이기 때문에 Action Type, Action을 생성해 주어야 합니다.  Redux-Thunk 에서 Redux-Saga로 넘어가는 추세로 보이는데 혹자는 Redux 보다 Redux-Saga의 러닝커브가 더 높다고 이야기합니다. (Redux에 딸려오는 식구들이 왜 이렇게 많은지…)ACTION TYPE 정의// RiderActionType.js// ACTION 타입을 정의 한다. redux-saga의 어떤 행위도 ACTION정의하고 ACTION을 dispatch하는 형태는 마찬가지다const FETCH_RIDER_LIST = \"rider/FETCH_RIDER_LIST\";코드 15. Redux-Saga Action Type 정의ACTION 생성// RiderAction.js// 정의된 ACTION 타입을 가지고 ACTION을 생성한다.export function fetchRiderList(data) {  return {    type: type.FETCH_RIDER_LIST,    meta: { method: \"get\", url: \"/v1/api/riders\" },    payload: {      data    }  };}코드 16. Redux-Saga Action 생성.Redux-Saga Async Method// RiderSaga.js/** * call, put, all, takeEvery 같은 redux-saga에서 제공하는 api를 학습해야 이해 할 수 있다. */function* fetchRiderList({ payload, meta }) {  const { data, status } = yield call(Axios.request, {    ...meta,    params: payload  });  if (status === 200) {    yield put(actions.rider.fetchSuccess(data));  } else {    yield put(actions.rider.fetchFail(data));  }}/** * types.FETCH_REQEUST &lt;- 이 ACTION이 dispatch되는 것을 감지하고 있다가 dispatch 되면 * getRiderListSuccess  task를 실행한다 */export default function* watchSearchRiderSaga() {  yield all([takeEvery(actions.searchRider.fetchRequest, fetchRiderList)]);}코드 17. Redux-Saga Async Method 생성.Redux-Saga에서 받아온 API 데이터를 처리할 Reducer// RiderReducer.js// riderList JSON을 처리할 reducer를 정의하고 redux-saga에서비동기 API를 호출 후// 받아온 데이터를 fetch할 ACTION을 dispatch한다(중간 단계가 너무많다... 익숙하지 않은 스타일로..)const initialState = {  riderList: []};function riderReducer(state = initialState, action) {  switch (action.type) {    case types.FETCH_SUCCESS:      return {        ...state,        riderList: action.payload.data      };    case types.FETCH_FAIL:      return {        ...state,        isError: true      };  }}코드 18. Redux-Saga 에서 받아온 데이터를 처리할 Reducer.API 호출을 담당하는 Class - MobxMobx에서는. API호출을 담당하는 Repository 성격의 Class를 만들고 Mobx Store에서 async 또는 generator를 사용해서 간단하게 callback 메소드 없는 패턴으로 구현되기 때문에 가독성도 좋습니다. Redux 처럼 Redux-Saga, Redux-Thunk 같은 추가 라이브러리는 필요하지 않습니다.class RiderRepository {  URL = \"/v1/api/riders\";  constructor(attr) {    Object.assign(this, attr);  }  findAll(params) {    return axios.get(this.URL, { params });  }  findOne(riderAccountId) {    return axios.get(`${this.URL}/${riderAccountId}`);  }}// 싱글톤으로 리턴export default new RiderRepository();코드 19. Mobx Repository Layer.Mobx Store에서는 Callback Method 없이 사용@Autobindclass RiderStore {  @observable  riderList = [];  constructor(rootStore) {    this.rootStore = rootStore;  }  // promise를 반환하는 riderReposiotry.findAll 메소드를 @asyncAction추가하고 generator를 사용하면  // 콜백없이 마치 sync한 로직처럼 코드를 작성할 수 있어 가독성이 높다.  @asyncAction  async *findAll(params) {    const { data, status } = yield riderRepository.findAll(params);    this.riderList = data.map(rider =&gt; new RiderModel(rider));  }  @action  removeRider(index) {    this.riderList.splice(index, 1);  }  @computed  get activeRiders() {    return this.riderList.filter(rider =&gt; rider.status === \"ACTIVE\");  }}코드 20. Mobx Store에서 Repository 를 사용하는 예.Model Layer - class(Mobx) VS Redux는 object 리터럴Redux에서는 State를 Model layer로 구성하는 아키텍쳐를 권유하는 개념이 아닌 듯 합니다. 학습을 하다보면 Redux는 함수형프로그래밍, 불변성, 사이드 이펙트에 대한 이야기가 자주 나오는데, 설계적으로 나쁜 접근은 아닌듯 하나(오로지 개인적인 생각일 뿐입니다.) 쉽지는 않습니다… Mobx에서는 객체지향적인 아키텍쳐를 권유 하고 있고 State를 객체리터럴을 사용해서 단순하게 구성하는 것 보다는 Model Class를 선언해서 도메인 자신의 로직은 자기가 가지고 있도록 하여 비즈니스로직이 철저하게 분리되도록 권장하고 있습니다.Redux 불변성 StateRedux에서는 따로 Model Layer를 구성 하는 형태는 아니고 보편적인 객체 리터럴 형태를 그대로 사용 하고 있습니다. 그리고 불변성 유지를 위해 스프레드 분법을 사용해 변경된 데이터와 변경되지 않은 데이터를 가지고 적절히 잘 합쳐서 새 객체를 생성 합니다.// 초기 값을 지정해 놓은 state, 그냥 단순한 객체 리터럴이다 자신의값을 처리하는 비즈니스 로직을 가진 메소드는// 없다 그냥 값만 있을 뿐const initialState = {  isLoading: false,  isOpent: false,  riderList: []};// 리듀서에서는 불변성 유지를 위해서 기존 state를 변경하는 것이 아닌 새변경한 값으로 객체를 생성한 state를 리턴한다// 변경하지 않는 값들은 스프레드로(...) 객체를 풀어서 넣어주고 변경할값들은 변경해서 원래 state와 같은 모양으로 만든다function riderReducer(state = initialState, action) {  switch (action.type) {    case types.FETCH_SUCCESS:      return {        ...state,        riderList: action.payload.data      };    case types.FETCH_FAIL:      return {        ...state,        isError: true      };  }}코드 21. Redux 불변성 State.Redux 불변성 state를 편하게 하기 위한 ImmutableJs라이브러리를 사용한 예// immutablejs의 fromJS api를 사용하여 불변성 객체로 만든다.const initialState = fromJS{  isLoading: false,  isOpent: false,  riderList: []};// set api로 riderList의 값을 변경해주고 return하면 기존 값을변경 리턴하는 것이 아니고 기존값은 놔두고 새로운 변경된 state를return한다// 비교적 스프레드 문법을 이용한 방법 보다 직관적이다function riderReducer(state = initialState, action) {  switch (action.type) {    case types.FETCH_SUCCESS:      return state.set('riderList', action.payload);    case types.FETCH_FAIL:      returnstate.set('isError', false);  }}코드 22. Redux에서 ImmutableJS 적용Model Class - MobxJava Spring에서 DTO 선언하는 것과 별반 다르지 않습니다. 차이점이라면 Javascript 특성상 프로퍼티를 미리 추가 하지 않고 동적으로 추가할 수 있어서 그냥 동적으로 추가 한것 뿐 도메인 클래스 선언이 크게 차이나 보이지 않습니다. 도메인 자신의 값과 자신의 값을 핸들링하는 메소드를 가지고 있는 형태로 구성됩니다.@Autobindclass RiderModel {  constructor(data) {    // Object.assign과 유사한 mobx가 제공하는 api를 사용하여 @observable(관찰가능한 state, rendering 되는) state로 만들어    // RiderModel에 멤머 property로 추가해준다.    extendObservable(this, data);  }  // 라이더명과 지점명을 합친 getter  // @computed는 값이 변경되도 이전 값과 값이 같으면 불필요한 렌더링을 하지 않는다.  @computed  get riderWithAgency() {    return `${this.riderName}(${this.agencyName})`;  }  @action  changeRiderName(riderName) {    this.riderName = riderName;  }}코드 23. Mobx Model Layer서버에서 가져온 데이터를 RiderModel클래스로 생성  마치 모양세가 Java Spring Service에서 Repository에서 가져온 Entity를 stream을 이용해서 DTO로 변환하는 과정과 별반 다를게 없다. Spring 개발자라면 Redux에 비해서 친숙 하게 다가 올 수 밖에 없는 것 같다.@Autobindclass RiderStore {  @observable  riderList = [];  constructor(rootStore) {    this.rootStore = rootStore;  }  @asyncAction  async *findAll(params) {    const { data, status } = yield riderRepository.findAll(params);    this.riderList = data.map(rider =&gt; new RiderModel(rider));  }}export default RiderStore;코드 24. Mobx Model 생성Mobx와 Java Spring의 유사성 비교Service Layer - Mobx Store, Spring ServiceMobx의 Layer와 Spring Layer의 비교 입니다. 언어적인 특성이 다르기 때문에 약간의 차이는 존재하지만 구현 해놓은 모양새는 크게 다르지 않고 비슷한 형태를 가지고 있습니다.Spring Service@Transactional@Servicepublic class RiderServiceeImpl implements RiderService {    @Autowired    private RiderRepository riderRepository;    @Override    public List findAll(RiderSearchRequest request) {        return riderRepository.findAll(reqeust).stream()                .map(RiderDto::of)                .collect(Collectors.toList());    }    @Override    public List activeRiders() {          return riderRepository.findAll(reqeust).stream()                .filter(v -&gt; v.isActive())                .map(RiderDto::of)                .collect(Collectors.toList());    }}​코드 25. Spring ServiceMobx Store@Autobindclass RiderStore {  @observable  riderList = [];  constructor(rootStore) {    this.rootStore = rootStore;  }  @asyncAction  async *findAll(params) {    const { data, status } = yield riderRepository.findAll(params);    this.riderList = data.map(rider =&gt; new RiderModel(rider));  }  @computed  get activeRiders() {    // rider.isActive는 아래 소스 예제에서 Rider Model Class에서 선언된 메소드를 호출 하여 사용한다.    // Rider Model의 비즈니스 로직은 자기가 담당한다.    return this.riderList.filter(rider =&gt; rider.isActive);  }}코드 26. Mobx StoreRepository LayerSpring Repositorypublic class RiderRepositoryImpl extendsQueryDslRepositorySupport implementsRiderRepositoryCustom {    private QRider rider = QRider.rider;    public RiderStartCashOnHandRepositoryImpl() {        super(Rider.class);    }    @Override    public List findAll(RiderSearchRequest request) {        return from(rider)                .where(rider.riderName.eq(request.getRiderName()))                .fetch();    }}코드 27. Spring RepositoryMobx Repository classclass RiderRepository {  URL = \"/v1/api/riders\";  constructor(attr) {    Object.assign(this, attr);  }  findAll(params) {    return axios.get(this.URL, { params });  }}코드 28. Mobx Repository LayerModel LayerJava DTO@Getterpublic class RiderDto {    private Long id;    private String riderName;    private Status status;    private String agencyName;    private RiderDto() {}    public static RiderDto of(Rider rider) {        RiderDto instance = new RiderDto();        instance.id = rider.getId();        instance.riderName = rider.getRiderName();        instance.status = rider.getStatus();        instancee.agencyName = rider.getAgencyName()        return instance;    }    public String riderWithAgency(){        return String.format(\"%s(%s)\", this.riderName, this.agencyName);    }    public boolean isActive(){        return this.status == Status.ACTIVE    }}코드 29. Java DTOMobx Model Class@Autobindclass RiderModel {  /**  생성자에서 서버로 부터 받아온 JSON에 서 property와 value 추가 해버를 것 이므로  property를 미리 선안 안해도 관계는 없다.  id;  riderName;  status;  agencyName;  */  constructor(data) {    extendObservable(this, data);  }  @computed  get riderWithAgency() {    return `${this.riderName}(${this.agencyName})`;  }  // 내부 처리시 상태값을 확인하는 메소드임으로  // ReactComponent에서 redering 할일이 없는 값이라면 구지 @computed를 붙일 필요는 없다  get isActive() {    this.status === \"ACTIVE\";  }}코드 30. Mobx Model ClassReact로 Project를 구성 할 때 하는 고민들올해 중순 즈음 우리 팀의 다음 Front-End Framework를 어떤 것을 사용할지에 대한 니즈가 있었고 그 임무가 나에게 떨어졌습니다. 면밀힌 조사를 통하여 React로 해보기 로 했고, 실제 실무에서 사용하기 위해서는 어느 정도 까지 기반이 갖춰져 있는 수준까지 개발이 필요했기 때문에 같은 팀 구인본님과 함께 React + Redux 조합의 P.O.C를 진행 했었습니다. 그리고 최근 Redux 보다 Mobx가 장점이 많다는 것을 알게 되었고 개인적으로 휴가와 주말을 거의 집근처 카페에서 보내며 새로 React + Mobx + Material-UI 조합으로 tutorial 수준이 아닌 실제 사이트 수준의 개발을 진행 했습니다.  단순히 아웃풋을 빨리 뽑아내는데 집중한 것이 아니라 NPM에 넘쳐나는 React 관련 라이브러리들과 패턴을 관련 블로그나 문서들을 통하여 비교 조사하고 적용 해보면서 최상의 패턴과 라이브러리를 조합하는데 더 집중 하였습니다.Mobx와 Material-UI를 적용한 배달현황 그림 5. mobx와 material-ui를 배달현황Mobx와 Material-UI를 적용한 라이더관리 그림 5. mobx와 material-ui를 라이더 관리이를 통하여 마주한 고민과 더불어 실제 개발 해보면서 느낀 것 들과 약간의 정보 그런 이야기를 한번 해보고자 합니다.  아마도 처름 React를 시작 하시는 분들이라면 이런 고민들을 마주 하게 될 가능성이 높다효율적인 Directory 구조보통 어느 프로젝트나 디렉토리를 구분할 때 파일 종류별로 아니면 페이지별(관련이 높은 파일들)로 디렉토리를 구성해 놓는 2가지 방식을 많이 사용할 텐데 별 것 아니지만 초반에 고민이 되이서 리서치를 해본결과 우선 기본적으로는 페이지별로 디렉토리를 나누어 관리하고 공통적인 React Component는 atomic design라는 UI design 개념을 도입하여 프로젝트 폴더 구조로 가는것이 Component 기반인 React에서 아주 효율적인 구조라고 판단 되서 적용 해보았습니다.  프로젝트의 폴더구조는 정답이 없어서 취향에 맞게 선택 하시면 될듯 합니다.Atomic Design 적용 예간략한 특징은 다음과 같이 Atoms(원자), Molecules(분자), Organisms(유기체), Templates, Pages 분류로 React Component의 종류와 규모에 맞게 적절히 분류해서 생성하여 관리합니다.Atomic Design 단계 구분 그림 5. Atomic Design 단계구분Atomic Design 적용한 폴더 구조 그림 5. Atomic Design 폴더 구조React Component의 유형 구분기본적으로 React로 개발시 2가지 형태의 Component를 생성 할 수 있습니다. React Component를 상속받은 Class로 Component를 작성하는 방법과 React Component를 상속받지않은 순수 함수 형태로 작성하고 Props만 받아서 구현하는 방법이 있는데 두 형태의 차이는 상속받은 Class는 내부적으로 state(변경하는 가능한 값), props(변경하지 못하는 값), react lifecycle method등등으로 구성되어 있고 두번째 형태는 내부에 state와 lifecycle 메소드가 없고 Props만 받아서 구현하는 함수 형태입니다. 그럼 이 두가지를 어떤 경우에 적절히 사용해야 할지 애매한 상황이 생기는데 현재 facebook react 팀에 있고 redux를 개발한 Dan Abramov는 두가지 경우로 구분하고 사용하기를 추천 하고 있습니다. 원문링크 위 개념을 바탕으로 실제 개발시에 저의 경우는 대략 3가지 정도의 유형으로 구분 해서 사용하고 있습닏다.  React는 기본적으로 명확하게 두 영역을 구분해서 설계된 것이 아니기 때문에 Tutorial에서는 구분해서 코드를 설명하지는 않는다. 하지만 이런 식으로 두 영역을 명확하게 구분하여 개발하는 것이 좀더 구조적으로 유용하기 때문에 구분하는 것을 권장하고 있다.Component 유형구분 그림 5. React Component의 유형Container Component React Component 를 상속한 RiderSearchContainer는 State와 Method를 적절히 중간에서 연결해 주는 Controller와 같은 역할만 수행하고 HTML 렌더링은 RiderListTemplate 같은 Presentational 영역을 담당하는 Component가 담당한다.@inject('riderStore')@observerclass RiderSearchContainer extends React.Component {  // 검색버튼 클릭 시 수행 될 메소드(RiderSearchFromTemplate에서 사용)  fetchRiderList() {    const { riderStore } = this.props;    riderStore.findAll({ page: 0 });  }  // 상세보기 클릭 시 수행 될 메소드(RiderListTemplate에서 사용)  fineOneRider(e) {    const { riderStore } = this.props;    const { riderAccountId } = e.currentTarget.dataset;    riderStore.findOne(riderAccountId);  }    render() {    const { riderList } = this.props.riderStore;    return (     \t    );  }}코드 31. Container ComponentPresentational ComponentReact Component 를 상속하지 않은 순수한 Function으로 Component를 작성하고 내부에 state를 생성할 수 없고 RiderSearchContainer가 Parameter로 넘긴 State와 Method를 받아서 state는 렌터링 하고 method는 사용하는 역할만 수행한다.function RiderListTemplate(props) {  const { riders, riderDetail } = props;  return (    &lt;ul&gt;      &lt;For each=\"rider\" of={riders}&gt;        &lt;li data-rider-account-id={rider.accountId}&gt;{rider.id}&lt;/li&gt;        &lt;li&gt;{rider.name}&lt;/li&gt;        &lt;li&gt;{rider.type}&lt;/li&gt;      &lt;/For&gt;    &lt;/ul&gt;  );}코드 32. Presontational ComponentComponent공통으로 사용할 지점 리스트를 서버에서 가져와 SelectBox를 구성한 Component이다. 내부 비즈니스 로직은 별로 없고, 서버로부터 지점 리스트를 가져와 option들을 생성하는 로직만 존재하고 Presentational을 따로 구분하여 개발 할 정도로 View영역 HTML 코드가 많지 않아 이런 경우에는 구지 Layer를 나누지 않고 그야말로 Component로 구성해서 사용했습니다.  Vue나 Angular 의 directive와 거의 같다고 보면 이해가 빠를 것 같다.class AgencySelectBoxComponent extends React.Component {  constructor(props) {    super(props);    this.state = {      agencies: [],    };    this.getAgencyList();  }  async getAgencyList() {    const { data, status } = await axios.get('/v1/api/agencies');    if (status === 200) {      this.setState({ agencies: data.agencies });    }  }  render() {    const { agencies } = this.state;    return (      &lt;select name=\"agencyId\"&gt;        &lt;For each=\"agency\" of={agencies}&gt;          &lt;option key={agency.id} value={agency.id}&gt;            {agency.name}          &lt;/option&gt;        &lt;/For&gt;      &lt;/select&gt;    );  }}코드 33. ComponentReact용으로 재구성된 UI 라이브러리 선택React용으로 재구성된 여러 UI 라이브러가 있고 Front-End 특성상 css style만 관련이 있는 것이 아니라 UI 표현과 동작이 React 코드와 밀접하게 상호 작용을 하고 특히 Redux나 Mobx와 함께 사용하는 경우 관련 라이브러리들 (Form Validation 라이브러리, Router 라이브러리 등등)과 밀접하게 연관이 있기 때문에 각 라이브러리간의 궁합과 이슈들이 어느정도 해결되어 안정적으로 관리되는 라이브러리 인지가 매우 중요한 요소입니다.  Angular 1.x 때 경험에 비춰 보면 Angular용 Bootstrap 라이브러리의 Popover를 사용 했을 때 Popover를 클릭하면 화면 모서리에서 생성되어 클릭지점으로 Popover가 이동되어 위치되어 버리는 버그가 있었고 버그가 픽스된 버전은 Angular 1의 마지막 버전과 Dependency가 있어서 Angular의 버전을 올려야 했다. Angular 마지막 버전과 사용하던 버전에서 변경된 Feature들이 많아 프로젝트의 모든 코드(Popover이슈와 직접적인 연관이 없는)를 수정할 수 밖에 없었다… 이와 유사한 경우가 생겨버리면 프로젝트를 뒤엎는 수준의 리펙토링이 필요하거나 다른 라이브러리로 재개발을 하는 최악의 상황이 발생 할 수 도 있다.적용해본 UI 라이브러는 각각 Reactstrap(bootstrap4), React-Bootstrap(Bootstrap3), Material-UI(Google Material Design)이고 사용해본 소감을 정리 해보고자 합니다.Reactstrap(Bootstrap4)장점최신 bootstrap 4를 react용으로 사용하도록 개발 된 라이브러리 이며 bootstrap 4의 최신 style을 적용할 수 있다.단점React-Bootstrap(bootstrap3)보다 미해결된 이슈들이 남아 있었고 Redux-Form(form validation라이브러리)과 함께 사용시 몇 가지 이슈로 인하여 component를 커스텀 해야하는 경우가 있는 경우가 있는 것이 단점이다.  사용 시점이 2018년 5월 즈음이라 적용하고자 한다면 현재 상황을 살펴보는 것을 당부 드린다.React-Bootstrap(Bootstrap3)장점이슈들이 많이 해결되고 어느정도 성숙된 라이브러리  다른 라이브러리들(react-router-bootstrap,redux-form..)이 react-bootrap을 기본으로하고 개발된 경우가 많아reactstrap보다 이슈가 적었다.단점Bootstrap 4가 나온 상황에서 style이 좀 예전 것이라는 점Material-UI개인적으로 Mobx로 개발을 진행 했을 때 Material-UI도 같이 적용 했습니다. 사실 처음에 우려되는 점이 다른 라이브러들과의 궁합을 걱정했지만 이제 정식으로 3대 버전까지 개발되었으며 Mobx-React-Form(form validation 라이브러리 with mobx)이 Material-UI를 지원하기 때문에 input의 유효성 검사와 그에 따른 UI의 변화와 오류 메시지 표시등이 별다른 custom 작업없이 Style이 틀어지거나 하지 않고 자연스럽게 작동했고, 사용율도 Bootstrap 기반의 라이브러리들보다 훨씬 높은 수치를 나타내고 있습니다.최근 NPM 경향 그림 5. npm trend ui 라이브러리장점  Web, Mobile, Desktop에 까지 광범위하게 사용되고 있는 Google Material Design의 깔끔한 style을 적용할 수 있다.      테마변경의 경우 css, sass를 새로 변경 rebuild하는 것이 아니라 아주 간편하게 코드상으로 변경할 수 있어서 Dark Mode 및 색상테마를 사용자가 직접 설정해서 변경 할수 있도록 기능으로도 제공 할 수 도 있다. 그림 5. material-ui dark mode    css를 적용하는 방식이 아닌 [jss]15 방식으로 style을 해당 페이지에서 사용하는 스타일만 따로 격리된 javascript객체로 관리가능 하고 동적으로 style 변경 적용이 직관적이다  우리가 모르는 사이 많이 적용되어 있던 Google Material Design이라 제공하는 컴포넌트로 항샹된 UX로 적용할 수 도 있다.단점  bootstrap에 많이 적응된 사람이라면 Material-UI 적용을 위해서는 약간의 학습이 요구된다.  처음 학습기간을 투자 한 이후로는 그다음에는 눈에 익어서 단계별 학습이 더 요구 되지는 않았다.Redux와 함께 주로 사용되는 라이브러리들Redux만 npm에서 다운받으면 되는 줄 알았는데 이게 다뭐야 하시는 분들이 분명히 계실 것 이라고 생각됩니다. 리서치 하다보면 꼬리에 꼬리를 무는 수많은 추가 라이브러리들과 그 것들이 뭐하는 라이브러리인지 파악하는 일도 상당한 리소스가 투여되는 경험이였습니다. 일단 Redux를 사용 할 것이라면 2018년 5월 기준으로 보편 아래 나열한 키워드의 라이브러리들을 기본적으로 사용하면 됩니다.Redux와 관련 라이브러리그림 5. Redux와 관련 라이브러리들  물론 추가적인 조사는 필요합니다. 다른 라이브러리가 나왔을 수도 있기 때문에..Redux와 연동 하는 Form Validation 라이브러리들Form Validation 없이 한땀 한땀 Dom을 Select하여 값을 정규식과 비교해서 일치하지 않는 경우 Submit를 중지하고 UI 컴포넌트에 css class를 변경하고 오류메시지를 추가하고 하는 작업은 정말 지겹고 많은 라인의 보일러플레이트 코드를 양산합니다. input 항목이 많으면 코드량도 만만치 않아서 Form Validation 라이브러리의 사용은 개인적으로 꼭 필요하다고 생각하는 편입니다. 실제로 적용 해본 라이브러리는 Redux-Form, React-Redux-Form 두가지 이고 나머지 라이브러리들의 문서를 면밀히 검도 해본 리서치 결과 입니다. Redux와 함께 적용을 고려 해보시는 분들이라면 참고 하시면 좋을 듯 합니다.Redux-Form보편적으로 Redux와 함게 가장 많이 사용하는 라이브러리, 기능과 성숙도가 높으나 러닝커브가 조금 있습니다.  결론적으로는 Redux-Form 개발하다가 React-Redux-Form을 따로 적용 해보았고 2% 부족함을 느껴 결론적으로는 Redux-Form을 사용했습니다.(Redux로 개발 시)React-Redux-Form일단 문서가 깔끔하고 redux-form에 비하여 깔끔한 설정 때문에 코드를 구현 해보았습니다. 하지만 최종적로 몇가지 기능의 코드 패턴이 매우 번잡스러워 결국은 Redux-Form으로 돌아 왔습니다.편의성 3/5문서 4/5커스텀 스타일 : 가능코드구성 복잡도 : 3/5Redux-Form 과 비교장점Redux 와 연결 작업 코드 구분은 Redux-Form에 비해 약간 깔끔, 기본적으로 Field에 설정하는 prop들이 Redux-Form에 비해 약간 간결한 느낌이였습니다. 문서는 Redux-Form보다 훨씬 잘되어 있다고 느겼습니다.단점Validation 구현 아주 깔끔하지 않고 번잡 스러움 (함수로 바로 구현 하거나 , 오류 메시지 부분도 따로 명시적으로 구현), Redux-Form이 더 깔끔, redux-form 은 validation 관련 boolean 과 메시지를 prop으로 제공해줘서 그냥 명시하면되는데 React-Redux-Form은 validation 이후 error 메시지, error class 처리를 하기 위한 자유도가 낮고 구현 하려면 번잡스럽게 구현(제일 큰단점), redux store에 저장된 form state 접근이 redux-form 이 제공하는 것 보다 엄청 복잡, state에 form의 값만 있는게 아니라 엄청 많은 값들이 들어 가 있는데 그걸 보고 작업자가 직접 추려야 ,됨 반면 redux-form은 다양한 selector를 제공해서 원하는 값을 딱 추려서 가져올수 있습니다.총평React-Redux-Form이 Redux-Form을 불편한 기능을 해결해 줄 것을 기대 하였으나 redux와 연결, fileld의 설청 prop들 몇가지 선언 구문은 깔끔해 졌지만 validation 처리를 깔끔하게 처리하는 기본 방법이 제공 되지 않는 것이 제일 큰 단점으로 작용하고 오히려 자동화된 기능이 redux-form보다 더 부족함다는 느낌을 받았습니다. (많은 기대를 했는데 ㅠㅠ).Formik가벼운 라이브러리라고 표방하지만 validation이 각필드에 정의 되는 방식이 아니라 모든 필드의 validation을 한꺼번에 따로 설정하는 방식이라 너저분한 방식의 느낌이 강함하고 문서가 가독성이 떨어지는 스타일로 제공되고 있습니다.편의성 3/5문서 2/5커스텀 스타일 : 가능코드구성 복잡도 : 4/5redux-form 과 비교 : 장점이 낮음Formsy-ReactValidation을 각필드에 선언 할수 있지만 그외 error 메시지 표시, 필수여부 onClick onChange, onSumit같은 조작들은 한땀 한땀 해줘야 하는 방식이라 library에서 제공하는 것이 많이 없음, 문서가 github 문서 뿐입니다.편의성 2/5문서 2/5커스텀 스타일 : 가능코드구성 복잡도 : 3/5redux-form 과 비교 : 장점이 낮음React-FormValidation을 각필드에 구성하는 방식이지만, 나머지 event 및 오류 표시는 직접 해야됨 코스 스타일 복잡도도 그렇게 낮은 편은 아닙니다.편의성 2/5문서 3/5커스텀 스타일 : 가능코드구성 복잡도 : 3/5Redux-Form 과 비교 : 장점이 낮음Mobx 연동 하는 Form Validation 라이브러리Mobx 와 연동하여 사용하는 Form Validation 라이브러리는 Mobx-React-Form이 가장 보편적인데 Material-UI와 연동에서도 별도의 커스텀 작업이 필요 없이 깔끔하게 연동되었고 Form 에 포함된 Field들의 Validation Rule의 정의 와 Validation이 성공과 실패 했을 때 처리 등등을 하나의 클래스로 완전히 격리 시켜 구현 하는 형태로 코드의 분리가 아주 괜찮고 Mobx Store에서 Form을 핸들링할 수 있는 API도 제공해서 깔끔하게 구현이 가능했습니다.(다른 라이브러리의 필요성을 아직까지는 못느꼈다.)Mobx Model 라이브러리들Mobx에서 Model Layer를 구현 하는데 순수 Class형태로 구현이 가능 하지만 Model 라이브러리를 사용하면 라이브러리에서 제공하는 기능들을 사용할 수 있는데 대부분의 라이브러리가 기능이 너무 많은 경우와 결정적 기능이 없는 경우 그리고 선언방식이 제각각이라 결론적으로는 적용하지 않았습니다. 하지만 한번쯤 살펴볼 만한 가치는 있는 듯 하여 아래는 평가항목을 기준으로 하여 그동안 리서치 및 적용 테스트 결과를 정리 했습니다.  순전히 주관적인 평가 임을 미리 밝혀 둡니다.평가항목  모델 선언 방식이 직관적인가?          객체 선언 및 다루는 코드스타일이 기본 JAVASCRIPT Class선언에 크게 벗어나지 않는 방식      서버로부터 가져온 json 데이터를 객체로 생성하고 메소드를 추가 하는 방식이 편리하고 직관적인가?        객체와 컬렉션을 다루는 편의 method가 제공 되나?          컬렉션을 find, filter, save 등등 기존 array의 map, filter, some을 대체 가능한가?        fetch, delete, fetchAll 처럼 제공되는 method 만으로 간편하게 rest api 통신을 통한 객체(데이터) 업데이트 가능한가?  serializer 제공 되는가?          json -&gt; observable 가능한 객체로 변환 및 -&gt; json으로 변환 가능한 기능이 제공되는가      Mobx-State-Tree선언 방식이 class 문법이 아니고 객체 리터럴 방식 a = {} 으로 action, observable 을 선언하는 방식이라 직관성이 떨어지고 기존 react component 선언이 class 문법을 주로 사용하는데 이질감이 느껴집니다.특징 - 모델객체를 생성할 때 객체차제 타입을 지정할 수 있는 기능을 제공함.직관성 - 1/5객체-컬렉션 편의 메소드 - Xrest-api method - XJson-Mobx모델라이브러리 이긴하나 원래값을 되돌리는 목적으로 만들어 진 듯 하며 찾고자하는 모델라이브러리의 목적에 부합하지 않았습니다.직관성 - 1객체-컬렉션 편의 메소드 - Xrest-api method - XMobx-Rest - 직접테스트완료모델생성과 rest api method 및 객체 관리 자체 편의 메소드가 제공됨 유력한 후보였으나 테스트로 사용해본결과 Model List 구조에서 array가 observable 안되는 경우가 있었습니다.직관성 - 4/5객체-컬렉션 편의 메소드 - 4/5Rest Api Method - 4/5Libx - 직접 테스트 완료모델 선언 방식은 직관적임, 모델간에 관계를 맺을 수도 있음, 모델 객체를 자체를 편의 메소드도 제공됨 다만 rest-api method는 없음 다른 객체와 관계 맺는 것이 조금 직관성이 떨어짐, 객체를 생성하고 다루는 방식이 별도의 제공되는 메소드를 이용해야지만 의도한대로 동작해서 혼란스럽고 개발시에 많은 삽질을 요구할 듯 합니다. collection을 지정된 모델에 매핑 할때 object.assign 즉 기존 모델 class에 attribute를 추가하는게 아니라 완전히 대체 해버립니다. 그래서 Model class 에 메소드나 기본 property를 선언 해놓고 api 호출한 데이터의 property를 추가하고 싶을 경우에는 사용 할 수가 없었습니다.직관성 - 4/5객체-컬렉션 편의 메소드 - 4/5Rest Api Method - XMobx-Collection-Store모델선언방식이 이상함 클래스안에 프로퍼티를 선언하는게 아니고 클래스를 생성해놓고 이후에 프로퍼티를 추가하는 형태 (직관성이 떨어짐) rest-api method가 포함된건 mobx-jsonapi-store를 사용해야합니다.  같은 라이브러린데 rest-api 로 호출한 객체를 생성하는 거라서 따로 써야됨직관성 - 1/5객체-컬렉션 편의 메소드 - 3/5Rest Api Method - XMobx-Model모델 선언 시 프로퍼티를 선언하는 방식이 static 으로 선언하게 되어 있습니다. 관계도 설정할 수 있는데 좀 번잡스러운 느낌, rest-api method 제공되는데 제일 번잡스럽습니다.직관성 - 1/5객체-컬렉션 편의 메소드 - 1/5Rest Api Method - XMobx-Spine모델선언은 직관적이나 관계형성 serialize, 객체 관리 편의 메소드가 미제공, rest-api method는 제공되나 store에 선언하는 방식임 전제적으로 좀 빈약합니다.직관성 - 2/5객체-컬렉션 편의 메소드 - X Rest Api Method - 1/5Mmlpx모델선언 직관적임, 특이점은 DI 방식을 적용 @inject 데코레이션으로 다른 mobx 스토어나 mobx model 객체를 Inject 할 수 있습니다.(spring과 유사함) 그러나 객체나 컬렉션 자체 편의 메소드는 없고, rest-api method 없음, 특징으로는 snapshot기능이 있어서 변경되기 전 데이터로 돌리기 하는 기능이 있는 있습니다.직관성 - 4/5객체-컬렉션 편의 메소드 - Xrest-api method - X이글을 마치며주관적 경험을 통해 느낀점이지만 Mobx는 Redux에 비해서 낮은 러닝 커브와 높은 가독성이 확실한 장점으로 다가 왔습니다. React State관리 라이브러리를 선택할 때 조금이나마 도움이 되었으면 하는 바램과 함께 글을 마칩니다.",
        "url": "/tech/2020/05/08/react-mobx/"
    }
    ,
    
    "tech-2020-05-08-real-time-service": {
        "title": "[Socket.io][websocket] 실시간 서비스 경험기(배달운영시스템 BROS1.0)",
            "author": "kimchanjung",
            "category": "",
            "content": "배달의민족 배민라이더스의 배달처리시스템 개발기와 socket.io(websocket)를 이용한 실시간 시스템 구현 방법을 자세히 알아 봅니다.경험기들어가기 앞서 이 글은 신기술 사용기 또는 소개가 아닌 실시간 서비스 즉 배민라이더스 BROS 1.0 을 개발 하면서 겪어왔던 다소 특별한 개발 및 운영 경험기 입니다. BROS 2.0이 나온 상황에서 1.0을 이야기 하는 것이 다소 순서가 맞지 않지만 그 때 당시 경험기를 남겨놓지 못 한 것을 이번 기회에 남겨 보고자 합니다.용어설명BROS 1.0BROS는 배민라이더스의 주문을 접수(콜센터접수)를 시작으로 배달건을 라이더가 고객에게 신속하고 안전하게 배달하기 위한 통합 운영 관제 시스템입니다.REAL-TIME 또는 실시간 서비스여기서 Real Time 또는 실시간서비스란 websocket으로 통신하는 서버를 이용하여 웹페이지 및 모바일 앱에서 실시간으로 데이터를 주고 받고 갱신하는 시스템을 말합니다.양방향바인딩AngularJS의 양방향 바인딩을 뜻 하며 뷰의 데이터가 변하면 모델이 자동으로 변경되고 반대로 모델이 변하면 뷰도 자동으로 변경되는 특징을 말합니다.Digest LoopAngularJS에서 모델 변화를 감지하는 역할을 하여 양방향 데이터 바인딩을 적용하는 역할을 합니다. AngularJs1.0의 성능적인 면에서 단점으로 작용하기도 하지만 개별 모델의 one-time bind 설정을 통하여 양방향 바인딩이 필요없는 모델을 제외 할 수 있습니다.Websocket웹브라우저는 http 프로토콜로 요청/응답으로 동작하는데 TCP/IP socket 처럼 connection이 유지되어 서로 실시간으로 통신을 할수 없습니다. 그래서 등장한것이 wswebsocket 프로토콜입니다.  websocket을 사용하면 웹브라우저에서도 socket 통신처럼 실시간으로 데이터를 주고 받을 수 있습니다. 최근에는 대부분의 브라우저가 websocket 프로토콜을 지원하지만 IE 같은 경우는 version 10 부터 지원을 하고 있습니다.Socket.ioNodeJS 기반으로 실시간 이벤트 서버를 개발 할 수 있는 오픈소스 라이브러리 입니다. 특징으로는 멀티 디바이스(web, android, ios, windows)를  지원하며 websocket을 지원하지 않는 Browser도 지원합니다.시스템구성  PHP API server  AngularJS(1.0) front-end  Socket.Io (NodeJs websocket open source library)  Redis  Sql server(MS)실시간 서비스가 필요했던 이유배민라이더스의 음식 주문은 평균 1시간 내외로 주문의 접수, 처리 및 배송이 완료 되어야 합니다. 즉 주문이 발생한 경우 콜센터직원은 바로 주문의 발생을 알아야 하며, 주문접수가 처리 되면 라이더는 즉시 배달건의 존재를 알아야 합니다. 또한 배달의 상태(대기 - 배차 - 픽업 - 전달)와 라이더의 실시간 위치가 업데이트 되어야 관제자와 라이더들은 원할한 관제 및 배달업무를 수행 할 수 있습니다. 또한 기존 polling 방식의 배민 콜센터 주문접수(현재는 fade out)는 주문건이 증가함에 따라 DB Select가 급증하여 서비스가 위험했던 적이 있었기  때문에 BROS개발 당시 실시간성을 유지하면서 DB Select를 줄이기 위해서 필수로 실시간 이벤트 서버 도입을 해야 했습니다.그림 1. 주문 처리 activity 다이어그램AngularJS 양방향 바인딩과 Socket.io를 이용한 실시간 데이터 동기화주문과 배달의 생성 상태변경이 있을 때 마다 socket.io 실시간 이벤트를 전송하고 수신 시 api를 호출하여 배달리스트를 갱신하는 방식은 데이터의 변경이 있는 경우만 database를 select하지만 피크시간대에는 이벤트가 증가하므로 database select가 급증하게 됩니다. angularjs model 변경은 angularjs가 알아서 뷰에 반영하기 때문에 실시간 이벤트를 송수신 할 때 마다 배달리스트를 호출 하지 않고 배달데이터를 생성 삭제 수정 한 후 실시간 이벤트 메시지로 angularjs model에 반영 하도록 하면 뷰는 자동으로 실시간 반영 됩니다. 또한 개발자는 뷰를 업데이트하는 비즈니스로직을 신경쓸 필요가 없고 데이터를 뷰에 나타나는 로직만 구성해 놓으면 됩니다.그림 2. AngularJs 모델 데이터 반영1.Controller - 실시간 이벤트 수신angular.module('bros').controller('bros.dlvrymgmt.common.DlvryMgmtCommCtrl', [  'bros.dlvrymgmt.common.realTimeDlvryService',  'bros.dlvrymgmt.common.Delivery','SktIo', '$scope',    function(realTimeDlvryService, Delivery, SktIo, $scope) {      \t// 배달데이터 객체를 모델에 binding 이제 뷰와 모델은 양방향 바인딩이 된다!!      \t$scope.delivery = Delivery        /**[소켓이벤트수신] 배차 생성 (상태는 대기와 동일)*/        SktIo.on('delivery:create', function (err, delivery) {            realTimeDlvryService.onCreate(err, delivery);        });        /**[소켓이벤트수신] 배차대기*/        SktIo.on('delivery:waiting', function (err, delivery) {            realTimeDlvryService.onWaiting(err, delivery);        });       ........코드 1. 이벤트 수신 Controller2.Service - 수신받은 데이터를 배달 객체에 반영angular.module('bros').factory('bros.dlvrymgmt.common.realTimeDlvryService', [    'bros.dlvrymgmt.common.Delivery','$resource',    function(DlvryMgmtCommModel, Delivery){        var realTimeDlvryService = {};      \t/**신규배달 처리*/      \trealTimeDlvryService.onCreate = function (err, delivery) {            Delivery.of(delivery);        };        /* 배차대기 처리*/        realTimeDlvryService.onWaiting = function (err, delivery) {            Delivery.setResource(delivery);        };      \treturn realTimeDlvryService;}]);코드 2. 수신이벤트 처리 Service3.Model - 배달 모델 객체를 변경angular.module('bros').service('bros.dlvrymgmt.common.Delivery', ['$filter',    function($filter) {        var Delivery = this;        var instance = {};        /**객체 초기화*/        Delivery.init = function () {            return angular.copy(instance, Delivery);        };        /**배달객체생성*/        Delivery.of = function (delivery) {            angular.extend(Delivery, delivery);        };        /**배달데이터 변경 반영*/        Delivery.setResource = function(delivery) {            $filter('setResource')(Delivery.items, delivery);        };        angular.copy(this, instance);    }]);코드 3. 수신받은 데이터 모델에 반영  데이터의 생성, 업데이트, 삭제를 Database에 반영하고 곧바로 Socket.io 서버의 실시간 이벤트 메시지로 데이터를 전송 Angular Model에  반영, 뷰는 모델의 변경에 자동 갱신 되기 때문에 client수에 관계없이 사실상 Database를 주기적으로 select하는 행위는 거의 일어나지 않으며  배달데이터는 실시간으로 관제 및 라이더에게 반영된다.배달현황 화면그림 3. BORS 실시간 배달현황 화면라이더 관제 및 배차 화면그림 3. BORS 실시간 라이더 배차 화면맞닥뜨려야했던 이슈들AngularJS와 Socket.io 서버를 이용하여 DB select를 최소화 하고 주문, 배달 및 라이더 위치를 실시간으로 관제하고 배차업무를 할 수 있도록 시스템을 구성하고 실시간으로 눈앞에 데이터들이 화면 갱신 없이 변경이 되고 있었지만 가만히 화면만 바라보고 있을 때는 큰 문제가 없는 듯 하였습니다.“그러나 browser는 열일 하고 있는 중……”Browser의 성능실시간으로 화면이 렌더링 되는 것은 사실 아무런 문제가 없었습니다. 하지만 피크시간인 저녁시간에 배달 건수가 급격히 늘어나기 시작하면서 배차를 위해 라이더리스트 다이얼로그를 클릭한다던지 하는 이벤트를 발생 시켰을 때 0.5초 정도 움찔하는 Delay가 발생하였습니다. 사용자 입장에서는 꽤나 신경이 거슬리는 이슈였습니다.  요구사항으로 배달완료된 배달건도 리스트에 남기고 당일 모든 배달건(많을 때는 1000건)을 현황에 리스팅 해달라는 요구가 있었습니다. 물론 타협으로 최근 4시간 배달건만 리스팅 하기로 하였지만 피크시간대에는 수백건의 배달을 페이징없이(실시간리스트라 페이징은…) 리스팅 되고 있었습니다.일반적인 초기 화면 진입 이후 뷰의 렌더링이 거의 없는 정적인 페이지와 달리 BROS의 배달/라이더 현황 페이지들 JAVASCRIPT가 실시간으로 이벤트를 수신받고 모델에 반영하고 뷰를 렌더링하고…… 실 새 없이 일을 하고 있었습니다. 그래서 성능최적화 작업에 들어갔습니다.모든 loop를 native for로 변경forEach, angular.foreach등으로 된 loop를 제거하고 순수 javascript의  역행 루프reversed loop로 변경하였습니다. 배열의 개수가 적을 때는 크게 상관 없지만 수백 수천개가 되면 그때는 이야기가 다릅니다.// length 지역 변수에 미리 선언(매번확인하지 않는다), 루프 순서를 역으로 for (var i = delivery.length-1; i &gt;= 0; i--) {  \t// for문 내부에 배열을 지역변수에 할당    var deliveryItem = delivery[i]    deliveryItem.deliveryStatus = \"pickup\";};코드 4. 역행 루프  for (var i = delivery.length-1; i &gt;= 0; i–) 루프 순서를 역으로 하면  조건문을 0 즉, false로 평가하게 하여 속성검색(조건문 비교)을 최소화하는 효과를 얻는다.  for (var i = delivery.length;i &gt;= 0; 배열의 크가룰 마리 할당 해놓아 배열을 크기를 매번 확인하지 않는다.  var **deliveryItem = delivery[i]** 배열을 미리 지역변수에 할당 해놓고 deliveryStatus 연산시 참조 하면  delivery[i].status, delivery[i].shopName 처럼 매번 배열을 검색하지 않는다.setTimeout을 사용하여 로직을 큐로 넘긴다.javascript는 단일 쓰레드로 동작하며. 먼저 수행된 작업이 끝날 때 까지 다음작업은 대기하게 된다. 무거운 작업이 있다면 당연히 사용자는 Delay를 느끼게된다. 이러한 점을 해결하기위해 setTimeout을 이용하여 작업을 실행하면 javascript engine에서 UI 작업 큐로 작업은 넘겨 지게 되고 event loop가 큐의 쌓여 있는 task를 처리 하게 됨으로써 좀더 blocking이 감소하여 좀더 성능향상을 시킬 수 있다. JAVASCRIPT Event Loop 링크 setTimeout(function () {   Rider.updatePosition(position); },0)  코드 5. setTimeout 사용Angular ng-repeat loop 사용시  조합 index key를 사용.ng-repeat은 콜렉션을 looping하여 뷰에 리스팅 하는 angularjs의 커스텀 attribute입니다. 리스팅된 데이터는 digest loop가 양방양 데이터 바인딩을 위하여 관리하는 모델 데이터 들이며 데이터 개수가 많을 수록 digest loop의 성능이 떨어지게 됩니다. 그래서 리스트의 각 항목 업소명, 배달상태, 배달주소.. 등등의 데이터는 onetime binding으로 digest loop를 가볍게 하고 배달번호+수정일시가 조합된 index key의  변경 감지만으로 뷰를 자동 갱신하게 됩니다. &lt;tr ng-repeat=\"deliveryItem in delivery | track by (deliveryItem.deliverySeq+deliveryItem.modDate)\"&gt;    &lt;td ng-bind=\"::deliveryItem.shopName\"&gt;&lt;/td&gt;    &lt;td ng-bind=\"::deliveryItem.status\"&gt;&lt;/td&gt;    &lt;td ng-bind=\"::deliveryItem.riderName\"&gt;&lt;/td&gt; &lt;/tr&gt;  코드 6. 조합 index key          나머지 모델데이터는 onetime binding 처리  App 처럼 화면에 나타나는 리스트만 렌더링v-repeat이라는 angularjs용 오픈소스 모듈을 사용하여 scroll up &amp; down 할때 화면에 나타나는 tr을 렌더링하고 사라지는 tr은 제거 되도록 처리 하여 리스트가 개수가 수백 수천이 되더라도  화면에 보이는 데이터 모델만 존재 하게 되어 실질적으로 digest loop가 관리하는 모델의 개수가 현저하게 줄어드는 효과를 낼 수 있었고 실제로 성능 향상에 제일 큰도움이 되었습니다.Web Worker 사용을 고려 하였으나 결국은 미적용…javascript 실행을 메인쓰레드가 아닌 백그라운드쓰레드에서 처리하게 할 수 있게 하여 무거운 작업의 경우 백그라운드 쓰레드가 처리하도록 하여 기존 단일쓰레드에 비해서 성능향상을 이점을 얻을 수 있습니다.angularjs의 digest loop를  web worker가 처리 하도록 하고 싶었으나 digest loop를 건드리는 일은 angularjs framework core를 건드리는 일이 되어 버리므로 결국 적용을 포기하였습니다 (가장 아쉬운 부분이기도 합니다.)실시간 이벤트 서버의 안정성사용료를 지불하고 바로 사용할 수 있는 유료 서비스들이 존재합니다. 대표적으로 pubnub, pusher 같은 서비스가 대표적이며 websocket서버를 직접 개발할 필요없이  사용 할 수 있는 장점이 있습니다. 반면에 장애나 이슈 발생시 즉각적인 처리가 어렵다는 단점도 분명 존재합니다. 실제로 BROS 2.0도 유료 서비스를 사용하다. 장애나 오류 발생시 즉각적인 대응이 어려워 결국은 websocket 서버를 개발하여 사용하고 있습니다.“유료서비스를 사용할 것인가 직접 만들것 인가는 여건과 상황에 따라 판단은 달라 질 수 있습니다.”실시간 이벤트 유실websocket server는 client와 서버 간에 http protocol로  커넥션을 초기에 맺고 wswebsocketprotocol로 upgrade한 후 서로에게 heartbeat를 주기적으로 발생시켜 커넥션이 유지되고 있는지 체크하며 네트워크를 유지합니다.socket.io를 사용하여 websocket 서버를 개발 했지만 비즈니스로직 문제가 아닌 다양한  network 상황 때문에 이벤트 유실이 발생 했습니다. 발생하는 건수는 매우 적은 수준이였지만 BROS 서비스의 특성상 1건이라도 누락이 발생하면 배달업무에 차질이 생기기 때문에  필수적으로  이벤트 유실에 대한 보완이 필요했습니다 . (유료 서비스도 마찬가지로 발생하는 이슈)이벤트 유실을 보완하기 위해 RabbitMq같은 메시지 큐를 사용하여 이벤트를 발송하는 것도 고려 하였으나 BROS 서비스의 특성상 시간이 지난 이벤트를 수신 받게 되거나 한참이 지난후 한꺼번에 미수신된 이벤트를 수신받게 되면 잘못된 데이터가 반영될 수도 있는 문제가 발생하게 되고 그 문제해결을 위해 복잡한 로직을 추가하게 되면 오히려 파생되는 문제가 더 생길 것으로 판단하였고 되도록이면 근본적인 해결책을 찾기로 하였습니다.브로드 캐스팅cron job을 사용하여 2분에 1번씩 batch proccess 한곳에서 만 배달 데이터를 select 하여 database  부하를 줄이면서socket.io 실시간 이벤트로 브로드캐스팅을 하도록 하고 client는 수신받은 데이터로 유실이 발생한 배달 리스트를 fetch 하는 것으로 이벤트 누락에 대한 데이터 미변경을 보완 하였고 적용 이후에는 사용성에 대한 문제가 보고 되지 않았습니다.(더 좋은 방법도 분명 있을 겁니다.)그림 4. 이벤트 유실을 보완하기 위한 BroadcastingWebsocket 서버 다운상황에 대비어느 순간이나 서버가 다운되면 안되지만 만약에 다운이 된다면 심각한 장애를 초래하게 됩니다. 실시간 서비스를 개발한다면 항상 염두해 두어야 하는 이슈 입니다. BROS1.0은 socket.io server가 disconnect가 되면 바로 api 직접 호출로 변경이 되고설정해둔 주기만큼 reconnection 시도 하도록 되어 있으며 reconnection이 성공하면 api 직접호출은 중단키시고 실시간 이벤트수신으로  swiching 되도록 개발 되어 있습니다. 더좋은 방법은 메소드들을 추상화 하고 2개이상의 실시간 이벤트 서버를 switching 할 수 있으면 더욱 안정적인 시스템이 될 수 있을 것이란 생각도 해봅니다.실시간 이벤트 서버socket.io이제 실시간 서비스를 위해 필수 적으로 필요한 websocket서버에 대한 이야기를 해보고자 합니다. 앞서 잠시 언급 하였지만 서버자체를 구축할 필요없이 유료로 이용할 수 있는 서비스들이 많이 존재합니다. 유료서비스의 장점은 개발과 운영에 대한 리소스가 들지않고  사용할 수 있다는 장점이 있습니다. 하지만 이슈 발생시 빠른 대처가 어렵다는 단점도 분명 존재하구요. 직접 서버를 개발하거나 유료 서비스를 이용하거나 하는 선택은 여러가지 상황에 따라 판단해야 할 듯 싶습니다. 그리고 서버를 직접 개발 하고 안정적인 상태로 유지하기 까지 생각보다 기술 적인  learning curve  높은 편이며 서버가 안정적인 상태까지 올라오기 위해서는 실제로 운영을 해봐야 한다는 어려움도 존재합니다. Socket.io 서버를 개발 하면서 겪었던 여러가지 경험에 대해서 이야기 하려고 합니다. 이야기할 내용은 Socket.io 서버에만 국한된 이야기라기 보다 websocket 서버를 개발한다면 아마도 동일하게 겪어야 될 경험이라고 생각됩니다.용어설명Namespace &amp; Room &amp; Eventsocket.io에서 트래픽을 격리하여 구분하는 단위로 사용됩니다 event는 명칭 그대로 송/수신하는 이벤트의 이름입니다. 트래픽격리 구분없이 이벤트를 송/수신하면 이벤트 리스너를 등록하여 이벤트를 처리하는 코드가 없더라도 접속한 모든 client에 전송 및 수신을 하게 됩니다. 불필요한 트래픽이 발생하게 되고 서버 자체의 성능도 저하되기 때문에 적절한 설계로 구분해아합니다.표 1. Socket.io 트래픽 격리 구분  다른 서비스에서는 room이란 용어 대신 channel이라는 용어를 많이 사용합니다.Public &amp; Private &amp; Broadcastingsocket.io에서 이벤트를 송/수신하는 방식을 말합니다.표 2. Socket.io 이벤트 송수신 방식ClusterNodeJS는 기본적으로 싱글 프로세스로 동작하며 서버 CPU Core 수 만큼 proccess 생성하여 Multi Proccess로 구동하기 위해서는 Cluster를 이용하여 Proccess를 생성하게 됩니다.  multi thread는 thread간 데이터를 공유되지만 multi processing은 데이터공유가 되지 않는 특징이 있다.  그래서 특별한 처리들을 구현해야 한다.Master &amp; WorkerNodeJS Cluster 를 이용하여 Proccess를 생성하면 실제 일을 수행하는 proccess를 Worker 라고 하며 worker들을 제어하는 역할을 하는 proccess를 Master라고 부른다.Socket.io를 선택한 이유socket.io는 앞서 말한것 처럼 websocket을 지원하지 않는 브라우저도 지원합니다. websocket을 지원하지 않는 브라우저에서는  flashsocket, htmlfile, xhr-polling, jsonp-polling등의 적절한 방식으로 전환되어 통신합니다. 최근에는 버전업이 되면서 websocket, polling만 지원하는 것으로 변경 되었습니다.  flashsocket같은 경우는 브라우저에 flash가 설지되어 있지않으면 작동을 하지 않는 문제가 있었고 안정성이 떨어지는 방식은 지원에서 제외 되었습니다.NodeJs 특징인 Single Thread 기반의 Non-Blocking I/O으로 성능적인 이점이 있습니다 (callback 지옥이라는 단점도 있지만..)자 이제 개발 해보자…..socket.io 홈페이지에 문서를 보니 아래 처럼 간단한 것 같은 ….. 금방 만들수 있겠다…  socket.io document는 detail함이 좀 부족한 느낌이다. 그리고 버전업이 되면서 deprecated 메소드나 설정 값들이 많아 혼란 스러워 socket.io object들을 실제로 console.log로 찍어서 객체를 확인 하면서 개발 해야 했다 휴……// 접속되면io.on('connection', (socket) =&gt; {  // 이벤트를 수신받고\t  socket.on('say to someone', (id, msg) =&gt; {    // 보내면 되는 구나..    socket.to(id).emit('my message', msg);  });});코드 7.  Server측 코드//수신 받고socket.on('news', (data) =&gt; {  //데이터 처리});// 보내고socket.emit('hello', 'world');코드 7.   Client측 코드  원래 호수에 있는 오리를 보면 편하게 둥둥 떠있는 것 처럼 보인다. 하지만 물속은 난리다…..물론 기본 설정이나 여러가지를 구현해야 하지만 큰 로직은 수신/송신이라 할 것이 많이 없을 줄 알았다.(websocket 서버를 쌩으로 구현하는 예제들도 기본예제들이긴 하지만..) 하지만 실제로 실무 서비스에 사용하려고 하니 여러가지 고려 대상이 생각보다 많았다. 이제부터는 실제로 개발 하면서 겪었던 과정을 설명 하려고 한다.트래픽의 격리와 전송방식을 잘 구현 해주어야 한다(꼬옥~)BROS는 각 지역 마다 센터로 구분 되어서 일을 하기 때문에 이벤트의 송수신은 센터 끼리 해야 된다. 그리고 같은 센터라도 배달데이터 송/수신을위한 Room과 채팅을 위한 Room은 구분 되어야 한다. 전체 센터의 배달 현황을 봐야 할 경우도 있다. 같은센터의 Room이지만 배달 상태를 전달완료로 변경하기 위해서는 Event명을 지정하여 송/수신 할 수 있어야 한다. 특정 Client에게만 선택해서 이벤트를 전송하기 위해서는 private로 전송 해야 하며 채팅의 메시지는 public이 되어야 한다.그래서 서버는 namespace/room/event 트래픽격리 구분과  public/private/broadcasting 이벤트 전송 방식을 실무에서 사용할 서버라면 필수로 구현해야 한다.Scale out에 대한 대비여기서 부터 맨붕이 왔다. 일반 웹서버처럼 세션관리만 신경쓰면 Server를 스케일아웃 하더라도 사람이 신경쓸 것이 별로 없는 상황이 아니였다. nodejs는 싱글 프로세스라  멀티프로세스를 생성하고 서로 완벽한 Clustering을 해주어야 했다. 추후 서버 자체의 Scale out이 되었을 경우에도 대비해야 하므로 Clustering을 구성하는 것은 꼭 필요했다. 단순히 세션에 대한 문제 뿐만 아니라 1번 서버 &gt; 1번 프로세스에 접속된 Client가 이벤트를 전송하면 나머지 서버 &gt; 나머지 프로세스들에 접속된 클라이언트로 이벤트를 전송하기 위해서 프로세스 끼리는 데이터가 연결되어 전/수송이 되게 작업이 되어야 했다.Clustringnodejs는 싱글 프로세스라 node cluster로 core 수만큼 프로세스를 생성해야 했다. 중요한 것은 멀티 쓰레드 방식이 아닌 멀티 프로세스방식이라 데이터 공유가 되지 않는 문제가 있었고 데이터 공유에 대한 처리가 필요했다.if (cluster.isMaster) {     //CPU의 갯수만큼 워커 생성    os.cpus().forEach(function (cpu) {        cluster.fork();    });    //워커가 죽으면,    cluster.on('exit', function(worker, code, signal) {        if (code == 200) {            //워커를 살리고 살리고~~            cluster.fork();        }    });    //생성한 워커가 보내는 메시지 처리    worker.on('message', function (\"야 김찬정이가 접속했단다!\") {        //생성한 워커에게 메시지 보내기    \tworker.send(\"워커들아 김찬정이가 접속했다는 구나!\");    });}if (cluster.isWorker) {    //마스터에게 메시지 보내기    process.send(\"야! 여기 김찬정이가 접속했다 다른 워커에게 좀 알려줘라 마스터야! 1명 접속 추가!!\");       //마스터가 보낸 메시지 처리    process.on('message', function(\"김찬정이가 접속했네!\") {        // 김찬정이가 접속 했으니 카운트도 추가하고~ Redis에 계정이랑 조인한 룸정보도 저장하고....        // 어휴... 번거롭기 짝이.....    });}코드 8. nodejs cluster위 코드 8 처럼 인위적으로 cpu 수만큼 woker를 생성 하고 워커들 끼리 통신 하기 위해서는  Master에게 메시지를 보내고 다시 나머지 Worker에게  데이터를 전송한다. (“아.. 뭔가 framework이 알아서 해주는게 아니라 사람이 코드로 저렇게 해줘야 하다니… 시람은 언제나 실수를….”)Clustering 시 데이터 공유는 Redis Pub/Subworker 끼리 이벤트를 전/송수신 하는 매개체로 redis pub/sub 를 이용했다. worker 1에 접속된 client가 이벤트를 전송하면 나머지 worker들에게  redis pub/sub을 통해 이벤트를 전송하고 수신받아 자신에게 접속된 client들에게 최종적으로 이벤트 메시지를 전송한다.그림 5. 클러스터링 구성도Worker의 Sticky Session 처리스케일 아웃 된 서버에 client가 접속할 때 마다 서버를 달리하여 접속하게 되면 세션문제를 마주하게 된다. 그래서 일관성있게 지정된 서버에만 접속 되도록 Sticky Session을 보통 L4같은 로드밸런서 장비가 해주게 되는데. 물리적인 서버는 로드밸런서가 처리해 준다고 하지만 문제는 node cluster로 생성한 worker들이다. 1대의 물리 서버에 worker들이 멀티프로세스로 동작하는 것은 사실 서버가 여러대 돌아가는 것이나 마찬가지 상황! worker들의 Sticky Session 처리도 오픈소스 모듈을 사용에 처리해주었다.(NodeJs 같은 특별한 경우가 아니면 필요 없을 수도….)wswebsocket가 아닌 http 이벤트 송신 api도 필요!Client는 Server와 websocket으로 connection을 유지하고 서로 통신하지만 http로 이벤트를 전송할 수 있는 기능도 필 수로  필요합니다.  client가 websocket으로 연결되어 있을 필요는 없고 event 발송만 하면 되는 경우도 필요하고 수신은 websocket으로 송신은 restful api 처리 끝단에 http로 이벤트를 전송하는 방식으로 시스템을 구성 할 수도 있기 때문에 http 이벤트 전송 api도 구현 해야할 필요가 있습니다. 실제로 BROS 에서 콜센터 주문접수처리 하기 위해서 주문의 상세 화면을 보고 있는 경우 고객이 배민앱에서 주문 취소를 하게 되면 주문취소 api 끝단에 http로 주문 취소 이벤트를 송신했고 콜센터 주문접수 화면에서는 바로 고객주문 취소 안내를 표시 했습니다.// POST - http://webmsg.woowa.in/ridersorda로 요청이 들어오면app.get('/ridersorda', function (req, res, next) {  next();}, function (req, res) {  // POST로 전송된 값들을 가져오고  var nameSpace = req.param('nameSpace');  var roomName = req.param('roomName');  var rcvEvtNm = req.param('rcvEvtNm');  var rcvData = req.param('rcvData');    // websocket 이벤트로 전송  io.of(nameSpace).to(roomName).emit(rcvEvtNm, rcvData);    // http response 설정을 해주고 끝!  res.set('Content-Type', 'application/json; charset=utf-8');  res.status(200).send(\"{'status':'ok','message':'성공'}\");  res.end();});코드 9. 이벤트 송신 http api서버를 띄어 놓긴 했다만 관리는 어떻게하나…서버를 만들어서 띄어 놓긴 했지만 서버에 대한 관리가 필요했다.(이런 부분때문에 유료 서비스를 사용하는 것이..) 일단 서버에 접속된 Namespace/Room별 접속한 클라이언트 현황이 필요 했고. 서버의 cpu/memory 등의 정보등이 필요했다. 그리고 서버에서 오류가 발생했거나 멈췄을 경우 즉각적인 Notification이 필요했다.서버 현황 데이터들은 Redis에 저장 관리앞서 말한 것 처럼 접속한 Client의 수와 이름 과 Room 리스트 데이터들은 각각의 worker 프로세스에서 공유 되지 못하고 따로 관리가 되기 때문에 이런 관리 데이터들은 1곳에 저장하고 조회 할 필요성이 생겼다. 또한 채팅 기능에서 서로 간 대화 메시지들이 보관되어야 할 저장소도 필요했다. Clustering 구성시에 Redis를 사용하고 있었기 때문에 Redis를 활용하여 데이터들을 저장하고 사용했고 Client들이 접속 및 Room에 join/out 하거 할때 Redis에 정보를 update했고 실시간 이벤트로 모니터링 페이지에 전송했다.그림 6. 소켓 서버 현황 페이지오류가 발생하면 이메일로 바로 오류 내용 전송사실 이부분은 유료 APM 서비스를 사용한다면 바로 해결될 부분이지만 (개발 당시는 사용하지 않았다.. 역쉬 돈이 쵝오!) 그렇지 않는 경우 필수로 오류상황에 대한 피드팩을 즉각적으로 받아야 할 필요가 있다. socket.io server를 개발 할 당시에는 winston 모듈을 사용하여 error 레벨의 로그가 남겨지거나 exception이 발생 했을 경우 설정해놓은 이메일로 바로 전송 되도록 했다.Socket 서버에서 발행 했던 이슈들개발하면서 다양한 문제들을 접했는데 client 수가 낮은 데도 cpu 100%로 서버마비를 겪은 적도 있고 redis는 메모리 저장소이지만 메모리데이터를 파일에 백업을 하는데 백업옵션에 문제가 생겨오류가 발생 했던 일, IE 브라우저에서 접속한 Client가 창이 닫혔을 경우 disconnected를 서버가 인지하지 못한 경우등등을 이야기 하고자 한다.서버 CPU 100%클라이언트가 많지 않은 상황이였는데 서버접속이 되지 않았다. 서버가 죽은 것은 아니였지만 이상하게 CPU 100% 상태였고 원인은 바로 NodeJs 특징인 Single Thread 기반의 Non-Blocking I/O 에서 비동기 이벤트 loop의 가장 적인 sync한 로직 처리 때문에 발생했다. 로직을 sync 하게 처리하게 되면 로직이 완료 될 때가지 block이 발생하게 되고 다음 처리 로직은 대기하게 된다(비동기 처리의 자세한 내용은 링크클릭) 비동기 처리를 한 이유는 Redis에서 namespace/room/clientAccount 등의 정보를 저장해놓고 가져올 때 처리한 로직 때문이였다. nodejs 비동기 이기 때문에 for loop가 일반적인 동작순서로 수행되지 않는다.a = [1, 2, 3, 4, 5]; for (var i=0; i&lt;a.length; i++) {    someFunction(function(){    \tconsole.log(i)                   });}// 예상결과// 1,2,3// 실제결과// 3,3,3 이건 뭥미?코드 10. nodejs loop 동작이러한 특징을 해결하기 위해 async 모듈을 사용하여 for loop를 sync 하게 처리 하도록 했지만 결국 문제를 일으키고 말았다. async.waterfall([ function(waterfallCB) {   // 1.모든 클라이언트를 가져오고   redisClient.keys('SocketIo^All_Client^*', function(err, nspsarr) {                                              \t\tasync.forEachOf(nspsarr, function (nspsVal, nspsKey, forEachOfCB) {                                                          redisClient.hgetall('SocketIo^All_Client^'+room, function(err, object) {                      forEachOfCB();         });     }, function (err) {\t     waterfallCB(err);       });      });}, function(waterfallCB) {  // 2.모든 접속 계정을 가져오고  redisClient.hlen('SocketIo^Account', function(err, count) {      allsocketInfo.connectCnt = count;      waterfallCB(count);   }); }, function(waterfallCB) {  // 3. 모든 socket id를 가져온다음  redisClient.keys('SocketIo^SocketId^*', function(err, socketIds) {      allsocketInfo.accountCnt = socketIds.length;      waterfallCB(count);   }); }] ,function(err, data) {  // 적절하게 조합한 데이터를 만든 후 리턴  allsocketInfo.clientInfo = data;  allsocketInfo.roomCnt = allsocketInfo.roomList.length  callback(err, allsocketInfo);});코드 11. 중첩 loop sync 하게 처리하기 위해 async라는 모듈 사용redis에 저장된 서버 현황 데이터를 가져와서 적절하게 조합하기 위해 for loop 가 여러번 사용 되었는데 async라는 모듈을 사용하면  loop가 수행된 후 결과를 순차적으로 전달함으로 써 sync 하게 처리 할 수 있었지만 사용률이 증가하면서 성능문제가 발행했고 문제의 해결은  되도록 async모듈을 사용한 loop를 처리하지 않는다.(sync하게 처리하여 block상황을 만들지 않는다)  redis의 데이터 구조를 단순화 한다.redis는 string, list, set, hash 등의 key/value 구조의 데이터 타입을 지원하므로 RDB 스타일의 복잡한 계층구조로 데이터를 저장하게 되면 데이터를 가져와 조합하기 위해서 복잡한 처리를 하게 되므로 처음 부터 제공되는 데이터 타입에 잘 맞추어 데이터를 설계하고 저장하면 불필요한 for loop문을 줄일 수 있다.Redis 파일저장 오류socket 서버의 namespace/room/account/socketid 관리 데이터들은 서버의 현황 데이터기 때문에 사실상 file로 백업 될 필요가 없지만 Chatting시 채팅에 입장 후 재입장 시 대화 내용을 다시 보여 줘야 했기 때문에 redis가 재부팅 되거 나 하는 경우에도 영구적으로 기록 되어 있어야 했다.그림 7. 채팅기능redis에서 파일 저장 시  여러가지 옵션들이 있는데 stop-writes-on-bgsave-error 옵션이 yes로 되어 있는경우 파일로 저장하다가 오류가 발생하면 redis의 메모리에 데이터 저장 자체가 안되게 되서 오류를 발생 시킨다 no 변경하게 되면 메모리에 저장하는 행위는 파일 저장 오류과 관계없이 계속 수행하게 된다.이처럼 redis의 옵션에 따른 예상치 못한 오류때문에 socket server에 오류가 발생 하였고 옵션변경으로 문제를 해결했지만 redis 서버자체의 옵션에 대한 정보도 알아놓을 필요가 있다.IE에서 disconnect를 인식 하지 못하는 문제IE에서 Browser 창을 닫는 경우 서버에서 client가 disconnect된 것을 인식 하지 못해 서버측에서 해당 client의 disconnect 처리를 하지 못 하였고 서버 측 disconnect 이벤트에 구현 되어 있던 데이터 처리가 제대로 되지 않아 서버 현황데이터에서 client가 살아 있는 것으로 표시 되었다. client sdk에서 세팅값을 추가하면 해결되는 문제 였다. 여기서 꼭 짚고 넘어가야 할 부분이 있다. 유로 서비스 또는 오픈소스 라이브러리들은 기본적으로 client sdk를 제공하는데 물론 오픈소스 라이브러리는 서버를 개발 해야 하지만 기본적으로 둘다 안정적으로 connection 관리를 해주고  서버주소, 옵션값 connection, reconnection, connection interval, error 핸들링, 이벤트 전송/수신 등등의 메소드를 제공합니다. 개발자는 제공하는 메소드들만 잘 사용하면 됩니다.javascript WebSocket 객체가 onopen, onclose, onerror, onmessage 등의 기본 메소드들을 제공하지만  WebSocket 객체로 client를 쌩으로 개발 하게 된다면 connection 관리가 불안하거나 장애를 경험하면서  안정적이 되어 가는 과정을 겪을 수 있을 수도 있습니다. 선택은 각자의 몫이지만 실시간 이벤트 서버를 사용해야 한다면 최대한 안정성이 높은 유료서비스를 선택 하고 차선은 오픈소스라이브러리를 사용하여 개발 “쌩”으로 개발 하는 것은 다시한번 고려 해보아야 됩니다…끝으로..실시간 서비스를 개발 하게 된다면 중요하게 고려해야될 부분은 Browser의 성능이다 일반적인 웹페이지에서는 그렇게 와닫는 문제는 아니지만 실시간 서비스는 반드시  Browser의 성능과 마주하게 된다. 그리고 실시간 이벤트 서버를 직접 개발 할 것인가 유료서비스를 사용할 것 인가를 결정하는 것이다 서로 장단점을 충분히 고려 해서 최대한 안정적인 방향으로 결정해야한다 그렇지 않으면 “배달건이 안보여요~”라는 피드백을 자주 들을 것이다 ㅠㅠBROS 1.0을 개발 하면서 처음 마주하는 framework와 기술들을 사용하면서 어려움도 있었지만 무척 흥분된 상태로 일했었다. 퇴근 하면 거의 매일 코딩했고 주말에도 거의 대부분 코딩했다.  회사를 다니면서 실무를 하면 현실적으로 이런 경험을 하기는 쉽지 않지만 몇가지 상황이 충족이 되었기 때문이였던 것 같다.  일단 오프라인(라이더센터와 사업적인)이슈들에 더 집중 되면서 다음 개발 이슈들에 대한 기간적인 여유가 약간 있었고, 처음 접해보는 신기술?(그때 당시에는)로 개발 하면서 흥미가 높았다. 또한 개발에 집중 할 수 있도록 챙김이님의 배려의 가 있었기 때문이 였다. (늦게 나마 다시한번 회사와 동료들에게 감사 드립닷~~)",
        "url": "/tech/2020/05/08/real-time-service/"
    }
    ,
    
    "algorithm-2020-05-08-stock-prices-42584": {
        "title": "주식가격 (42584) - 프로그래머스 [코테][알고리즘]",
            "author": "kimchanjung",
            "category": "",
            "content": "프로그래머스 programers 주식가격 (42584)문제의 풀이와 해설을 합니다.[프로그래머스] 코딩테스트 연습 &gt; 스택/큐 &gt; 주식가격 (42584)문제바로가기이중 for 문을 사용한 풀이법 뿐이라 stack을 사용한 방법으로 해결, 시간 복잡도가 훨씬 줄어드는 방법.문제 조건1, 2, 3, 2, 3 의 주식 값 배열이 주어 졌을 경우, 주식 값이 떨어지지 않는 날을 각각 배열에 담아 반환1, 2, 3, 2, 3 &lt;= 주식 값4, 3, 1, 1, 0 &lt;= 주식 값이 떨어지지 않는 날1 =&gt; 떨이지는 날이 없으므로 2, 3, 2, 3 =&gt; 총 4일간 유지2 =&gt; 역시 떨어지는 날이 없으므로  3, 2, 3 =&gt;총 3일간 유지3 =&gt; 다음 날이 2 이므로 주식 값이 떨어지므로 =&gt; 총 1일간 유지 (이부분이 헷갈릴 수 있음)        2,3 =&gt; 1일이고        2,1  =&gt; 1일 임        2,3,4 =&gt; 2일 이고        2,2,1  =&gt; 2일 임        즉 다음 날이 주식 값이 떨어지는 날도 1일로 포함 하는 조건 인데(헷갈리는 요소)2 =&gt; 다음 날이 3이고 더이상 없으므로 =&gt; 총 1일간 유지3 =&gt; 다음 날이 없으므로 =&gt; 0일간 유지Stack을 이용한 방법1, 2, 3, 2, 3 뒤에서 부터 루프를 시작한다 =&gt; 3, 2, 3, 2, 1 =&gt; 마지막은 항상 0일 이므로 뒤에서 마지막을 제외하고 시작  즉 2, 3, 2, 1 를 루프 돌린다.  Stack에는 두 값을 저장한다 =&gt; 주식값, 떨어지지 않는 날 수.  Stack이 비어 있지 않고, Stack의 마지막 값 &gt;= 현재 주식값 인경우 =&gt; 꺼낸다.  꺼낸 값에서 주식이 떨이지지 않는 날을 합산한다.  Stack에 주식값, Stack 에서 합산된 주식이 떨어지지 않는 날 + 1 =&gt; 저장한다.단계별 데이터 상황 설명2, 3, 2, 1주식값 = 2 , stack = empty, 주식 유지 날 = 0+1 =&gt; stack 저장 값 = (2, 1) (조건에 의해 stack pop 하지 않음)주식값 = 3 , stack = (2,1), 주식 유지 날 = 0+1 =&gt; stack 저장 값 = (3,2)(2, 1) (조건에 의해 stack pop 하지 않음)주식값 = 2,  stack = (3,1)(2,1), 주식 유지 날 = (1+1)+1 =&gt; stack 저장값 = (3,3) (조건에 의해 stack에 값을 pop 하여 주식 유지 날을 합산 하고 +1 하여 저장함)주식값 = 1,  stack = (3,3), 주식 유지 날 = (3) + 1=&gt; stack에 저장 값 (1,4) 조건에 의해 stack에 값을 pop 하여 주식 유지 날을 합산 하고 +1 하여 저장함)각 개별 주식 가격 유지 날 수 는  1, 2, 3, 2, 3 &lt;= 주식 값4, 3, 1, 1, 0 &lt;= 주식 값이 떨어지지 않는 날소스코드public static int[] solution(int[] prices) {    Stack&lt;Integer[]&gt; stack = new Stack&lt;&gt;();    int[] ret = new int[prices.length];    for (int i = prices.length - 2; i &gt;= 0; i--) {        int day = 0;        while (!stack.isEmpty() &amp;&amp; stack.peek()[0] &gt;= prices[i]) {            day += stack.pop()[1];        }        ret[i] = stack.push(new Integer[]{prices[i], day + 1})[1];    }        return ret;}",
        "url": "/algorithm/2020/05/08/stock-prices-42584/"
    }
    ,
    
    "algorithm-2020-05-08-way-to-school-42898": {
        "title": "등굣길 (42898) - 프로그래머스 [코테][알고리즘]",
            "author": "kimchanjung",
            "category": "",
            "content": "프로그래머스 programers 등굣길 (42898)문제의 풀이와 해설을 합니다.[프로그래머스] 코딩테스트 연습 &gt; 동적계획법(Dynamic Programming) &gt; 등굣길 (9305)문제바로가기이 문제의 핵심은 도달 가능한 지점의 개수 = 왼쪽개수 + 위쪽개수 가 핵심 1(1,1) 1(1,2) 1(2,1) 2(2,2)그리드에서 (2,2) 위치 도달 개수는  왼쪽(2,1) 도달개수 1  위쪽(1,2) 도달개수 1  도착지점의 도달 개수는 결국 왼쪽에서 들어오는 길, 위쪽에서 들어 오는길 2가지 이므로결국 왼쪽+위쪽 의 개수가 된다.  웅덩이는 지나갈 수 없으므로 0이 되는 것점화식으로 표현하면  point(n. m) = point(n, m -1) + point(n-1, m)해결책  그리드 배열의 인덱스는 0 부터 이나, 문제에서는 1 부터 이므로 배열[n+1][m+1] 선언한다.  웅덩이는 선언된 그리드 배열에 -1 값으로 표시한다(처리 시 0은 아직 개수가 계산되지 않은 지점, -1은 웅덩이를 구별하기 위함)  출발 지점 그리드[1][1] = 1로 설정한다.  재귀를 사용하여 점화식을 그대로 표현 하여 구현한다.  재귀에서 이미 point(1,1) 보다 이전 위치의 값은 은 0을 리턴, 처리된 값이 있다면 그값을 리턴, 웅덩이라면 0을 리턴 하도록 처리주의웅덩이 배열 값 [1,2] =&gt; [row, col] 이 아니라 반대 입니다. 이것 때문에  로직은 맞으나 테스트를 통과 못하여 한참을 찾았네요..ㅠ즉 그리드에 웅덩이 값을 선언 할때 grid[2][1] = -1 이렇게 들어 가야합니다.소스코드class Solution {    private static int[][] matrix;        public static int solution(int m, int n, int[][] puddles) {        matrix = new int[n+1][m+1];        Arrays.stream(puddles).forEach(v -&gt; matrix[v[1]][v[0]] = -1);        matrix[1][1] = 1;        return recursive(n,m);    }    private static int recursive(int row, int col) {        if (row &lt; 1 || col &lt; 1 || matrix[row][col] &lt; 0) return 0;        if (matrix[row][col] &gt; 0) return matrix[row][col];        return matrix[row][col] = (recursive(row, col - 1) + recursive(row - 1, col)) % 1000000007;    }}",
        "url": "/algorithm/2020/05/08/way-to-school-42898/"
    }
    ,
    
    "algorithm-2020-05-08-integer-triangle-43105": {
        "title": "정수삼각형 (43105) - 프로그래머스 [코테][알고리즘]",
            "author": "kimchanjung",
            "category": "",
            "content": "프로그래머스 programers 정수삼각형 (43105)문제의 풀이와 해설을 합니다.[프로그래머스] 코딩테스트 연습 &gt; 동적계획법(Dynamic Programming) &gt; 정수 삼각형 (43105)문제바로가기트리탐색의 후위순회를 예를 들어 설명하면  1 (1+3 = 4)2   3탐색 순서는 2 -&gt; 3 -&gt; 1 됩니다.해결방법  자식 노드 2 와 3중에 큰 값과 1을 더한 값을 저장합니다. 즉 1의 두 자식 노드 중 큰 값과 자기 자신을 계속 적으로 더해 나가는 방법을 사용합니다. 점화식으로 표현하면 아래와 같습니다.          부모합산 = 부모 + max(오른쪽자식, 왼쪽자식)        재귀를 사용하여 해결한 코드public int preOrder(부모노드){    if (노드의 번호가 초과하면 ) return 0;    if (합산값이 이미 있다면) return 합산[부모노드];       return 합산[부모] = 부모 + max( preOrder(왼쪽자식),   preOrder(오른쪽자식))}소스코드class Solution {    private static int[][] nodes;    private static int[][] nodesSum;    public static int solution(int[][] triangle) {        nodes = triangle;        nodesSum = new int[triangle.length][triangle.length];        return preOrder(0, 0);    }    private static int preOrder(int row, int col) {        if (nodes.length == row) return 0;        if (nodesSum[row][col] &gt; 0) return nodesSum[row][col];        return nodesSum[row][col] = nodes[row][col] + Math.max(preOrder(row + 1, col), preOrder(row + 1, col + 1));    }}",
        "url": "/algorithm/2020/05/08/integer-triangle-43105/"
    }
    ,
    
    "algorithm-2020-05-08-tile-deco-43104": {
        "title": "타일장식물 (43104) - 프로그래머스 [코테][알고리즘]",
            "author": "kimchanjung",
            "category": "",
            "content": "프로그래머스 programers 타일장식물 (43104)문제의 풀이와 해설을 합니다.[프로그래머스] 코딩테스트 연습 &gt; 동적계획법(Dynamic Programming) &gt; 타일장식물 (43104)문제바로가기이문제는 피보나치 수열 문제|      |  3  || 5    |1| 2 ||      |1|   |처음 제공되는 정사각형 타일의 한변의 크기는 아래와 같이 제공된다.  [1, 1, 2, 3, 5, 8, …]위 정사각형 한변의 크기는 피보나치 수열 인데 위 숫자가 해결해야될 수열이 아니라 n 차에서 4변의 합이 수열이다 약간 꼬아 놓은 문제  [1, 1, 2,  3,  5,  8]위 와 같은 한변의 크기를 가진 정사각형의 둘레의 합은 결국 아래와 같고  [4, 6, 10, 16, 26, 42]위 정사각형 둘레 값을 수열로 풀어야한다.해결책수열의 점화식을 도출 해보면  a1 = 4 (1+1+1+1)a2 = 6 (2+2+1+1) a3 = a2 + a1 (2+2+3+3 = 10)…결국 도출된 수열의 점화식은 아래와 같다.  an = a(n-2)+a(n-1)소스코드도출된 점화식을 재귀로 그대로 표현하면class Solution {    private static long[] memo = new long[80];    public static long solution(int n) {        if (n == 1) return 4;        if (n == 2) return 6;        if (memo[n] &gt; 0) return memo[n];        return memo[n] = solution(n - 1) + solution(n - 2);    }}",
        "url": "/algorithm/2020/05/08/tile-deco-43104/"
    }
    ,
    
    "algorithm-2020-05-08-network-43162": {
        "title": "네트워크 (43162) - 프로그래머스 [코테][알고리즘]",
            "author": "kimchanjung",
            "category": "",
            "content": "프로그래머스 programers 네트워크 (43162) 문제의 풀이와 해설을 합니다.[프로그래머스] 코딩테스트 연습 &gt; 깊이/너비 우선 탐색(DFS/BFS) &gt; 네트워크 (43162)이 문제는 서로연결된 그래프 그룹이 몇개 인지 찾는 문제문제바로가기TEST CASE 1    1  /2       3  그래프 그룹 1 - 2 = 1개  그래프 그룹      3 = 1개TEST CASE 2    1  /2   -   3  그래프 그룹 1 - 2  - 3 =  1개해결방법 (TEST CASE 1기준)각 노드 1, 2, 3을 출발점으로 DFS 탐색을 한다.  1번을 시작으로  =&gt; 1[방문] -&gt; 2[방문] 종료 =  1개다음 노드 2번을 출발점으로 DFS 탐색  2번은 1번노드 DFS시 방문한 노드 이므로 제외한다(카운트하지 않는다.)3번 노드 출발점으로 DFS탐색  3번노드는 1번 출발점으로 탐색시 연결되어 있지 않아 미방문상태 이므로 DFS 탐색 (카운트 포함)결론 적으로 1 2 3 을 개별 출발점으로 DFS 하더라도 1-2연결됨으로써 카운트는 1번 3은 1,2와 연결되지 않은 개별 그래프 이므로 DFS를 수행하게 됨으로써 카운트 1번  1-2-3 의 경우는 모두 연결되어 있으므로 1,2,3, 개별 노드를 출발점으로 DFS 하더라도 미방문시에만 DFS하도록 되어 있어 결론은 1번이 된다.소스코드class Solution {    private static int[][] nodes;    private static boolean[] visited;    public static int solution(int n, int[][] computers) {        nodes = computers;        visited = new boolean[n];        return IntStream.range(0, n).map(i -&gt; visited[i] ? 0 : dfs(i)).sum();    }    private static int dfs(int node) {        if (visited[node]) return 1;        visited[node] = true;        return IntStream.range(0,nodes[node].length)                .map(i -&gt; nodes[node][i] == 1 ? dfs(i) : 0)                .max().getAsInt();    }}",
        "url": "/algorithm/2020/05/08/network-43162/"
    }
    ,
    
    "algorithm-2020-05-08-coin-change": {
        "title": "Coin Change  - LeetCode [코테/알고리즘]",
            "author": "kimchanjung",
            "category": "",
            "content": "리트코드 LeetCode Coin Change문제의 풀이와 해설을 합니다.[LeetCode] LeetCode - Coin Change문제바로가기문제설명1원, 2원, 5원 짜리 동전을 가지고 있는 경우 11원을 만드는 경우 최소 동전의 개수를 구하는 문제  주어진 동전의 종류 = [1, 2, 5] 총 개수는 = 5+5+1 = 3개이 문제를 이해 하기 위해서는 유명한 피보나치 수열 이용한 계단 문제를 먼저 이해 해야한다.  계단의 개수 = 3개계단은 1칸, 2칸 씩만 올라 갈수 있다. 3개의 계단 까지 오르는 방법의 수는   첫번째 계단 = 1가지 (1칸 올라 갈수 있다)   두번째 계단 = 2가지 ([1,1], [2] =&gt; 1칸씩 올라가는 방법 1가지, 2칸을 한꺼번에 올라가는 방법 1가지)   새번째 계단 = 3가지 ([1,1,1], [1,2], [2,1])            첫번째 계단까지 1가지 + 두번째 계단 까지 2가지를 합한 3가지 방법이 된다.  점화식으로 표현하면  a1 = 1a2 = 2a3 = a2 + a1…a(n) = a(n-1)+ a(n-2) 가 도출 된다.다시 원래 문제로 돌아 오면11원을 만들기 위해 최소의 동전 개수를 구하기 위해 1원 부터 시작 해본다.1원 = 1개 (1원)2원 = 1개 (1원+1원, 2원) 최소 동전 개수3원 = 2개 (1원+1원+1원, 1원+2원) 최소 동전 개수4원 = 2개 (1원+1원+1원+1원, 1원+1원+2원, 2원+2원) 최소 동전 개수 5원 = 1개      (5원 - 1원 = 4원을 만들 수 있는 최소 개수 = 2개)     (5원 - 2원 = 3원을 만들 수 있는 최소 개수 = 2개)     (5원 - 5원 = 0원을 만들 수 있는 최소 개수 = 0개) 셋 중 최소 개수에 + 1을 하는데, 그 이유는 1,2,5 동전으로 5원을 만들기 위해서1은 4원이 필요하고 =&gt; 4원을 만드는데 최소 개수 + 1원(1개) = 2개(2원 + 2원) + 1개 5원 2은 3원이 필요하고 =&gt; 3원을 만드는데 최소 개수 + 2원(1개) = 2개(2원 + 1원) + 1개 5원5원 0원이 필요하고 =&gt; 5원을 만드는데 최소 개수 + 5원(1개) = 0개(0원     ) + 1개 5원그래서 5원을 만드는데 각 1,2,5 원 자기 자신을 제외한 돈을 만드는 개수를 가져와 그중 최소 개수에 + 1을 하게 되는 것이다점화식으로 표현하면  a(n) = min( a(n-1), a(n-2), a(n-5) ) + 1min( a(n-1), a(n-2), a(n-5) ) 부분 즉 동전 종류가 고정으로 주어지지 않으므로 코드로 표현하면// 동전 개수가 동적이므로 동전 개수만큼 해당 동전별 최소 개수를 모두 가져와 최소 개수를 도출한다.for(int i = 0; i &lt; coins.length; i++) {    min = min(min, a(n-conin[i])}소스코드도출된 점화식을 재귀로 그대로 표현하면public class CoinChange {    public static int coinChange(int[] coins, int amount) {        int[] amounts = new int[amount + 1];        int recur = recur(coins, amounts, amount);        // 문제에서 특별히 주어진 동전종류로 원하는 금액을 만들 수 없는 경우 -1을         // 리턴 해야 하므로 아래 처림 처리        return recur &gt; amount ? -1 : recur;    }    public static int recur(int[] coins, int[] amounts, int amount) {        // 동전을 만들 수 없는 경우는 제외 하므로        // 1원 = 1원만 필요하고 2원을 필요하지 않기 때문에 max값을 리턴하여 최소 개수계산에 제외 된다.        if (amount &lt; 0) return Integer.MAX_VALUE - 1;        if (amount == 0) return 0;        if (amounts[amount] &gt; 0) return amounts[amount]; // 불필요한 계산을 피하기위한 memorization        int min = Integer.MAX_VALUE - 1;        // 점화식이 표현 된 부분        for (int i = 0; i &lt; coins.length; i++) {            min = Math.min(min, recur(coins, amounts, amount - coins[i]) + 1);        }        return amounts[amount] = min;    }}",
        "url": "/algorithm/2020/05/08/Coin-Change/"
    }
    ,
    
    "algorithm-2020-05-08-longest-substring-without-repeating-characters-copy": {
        "title": "Longest Substring Without Repeating Characters - LeetCode [코테/알고리즘]",
            "author": "kimchanjung",
            "category": "",
            "content": "코테 코딩테스트 알고리즘 리트코드 LeetCode Longest Substring Without Repeating Characters 문제의 풀이와 해설을 합니다문제바로가기이 문제는 주어진 문자열에 중복이 없는 부분 문자열의 길이를 찾는 문제abcabcbb =&gt; abcbbbbb =&gt; bpwwkew =&gt; wke해결책문자열의 첫번째 문자열 부터 시작 하여 하나씩 증가 시켜고 다음 문자열이 포함되는지 체크한다.중복없는 문자열의 길이중 가장 긴 값을 리턴한다.abcabcbba &lt;- b  // 포함 하지 않으면 다음 문자열까지 잘라서 비교한다.ab &lt;- c // 포함 하지 않으면 다음 문자열까지 잘라서 비교한다.abc &lt;- a // a가 포함 되었다. 비교문자를 자르는 시작을 a 다음 인 b 부터 시작한다bca &lt;- b // b가 포함 되었다. 비교문자를 자르는 시작을 c 다음 인 c 부터 시작한다cab &lt;- c // c가 포함 되었다. 비교문자를 자르는 시작을 c 다음 인 a 부터 시작한다..소스코드도출된 점화식을 재귀로 그대로 표현하면public class LongestSubstringWithoutRepeatingCharacters {    public static int lengthOfLongestSubstring(String s) {        int start = 0, max = 0;        s = s + \" \";        for (int i = 1; i &lt; s.length(); i++) {            String str = s.substring(start, i);                max = Math.max(str.length(), max);            /**             * 문자가 비교할 문자열에 포함이 되어 있다면             * 비교할 문자열의 시작위치를 포함된 문자열의 마지막 인덱스 다음 값으로 한다.             * abcabcbb 에서              * ---abcb- abc에 b가 포함 되었는데 잘라낸 문자열 abc에서 b의 인덱스는 1이 된다             * 우리가 원하는건 abcabcbb에서              *             ----b---              *                 4    4번 index값을 찾아서 다음 비교를 시작 해야하므로              * 처음부터 현재까지 즉 abcabcbb 중에서 abcabc 까지에서  b 중 마지막에 있는 b의 index를 찾아낸다              * 그래야 abcabcbb              *      -----cb 와 b를 다시 검사 할 수 있다.            */                if (str.indexOf(s.charAt(i)) &gt; -1) {                start = s.substring(0, i).lastIndexOf(s.charAt(i)) + 1;            }        }        return max;    }}",
        "url": "/algorithm/2020/05/08/Longest-Substring-Without-Repeating-Characters-copy/"
    }
    ,
    
    "algorithm-2020-05-08-sherlock-and-anagrams": {
        "title": "Sherlock and anagrams - hackerank [코테/알고리즘]",
            "author": "kimchanjung",
            "category": "",
            "content": "해커랭크 hackerank Sherlock and anagrams 문제의 풀이와 해설을 합니다.특정 문자열의 개별 문자를 쌍으로 구성하는 경우 가능한 케이스의 개수를 찾는 문제문제바로가기문제 조건  주어진 문자열 자체의 순서는 변경할 수 없다          “abcd” -&gt; “bacd” 이렇게 변경 할수 없다.        개별 문자열은 순서는 상관없다          “ifailuhkqq”“ifa” == “fai”는 같은 것으로 본다 =&gt; [“ifa”, “fai”] 아나그램 조합이 허용된다.        문자열 “abba”의 경우 가능한 케이스는[a,a] [ab, ba] [b,b] [abb, bba]  =&gt; 4가지  문자열 “ifailuhkqq” 경우는[i,i] [g,g] [ifa, fai] =&gt; 처럼 3가지다  [ifa, fai] =&gt; 순서는 다르지만 각각 i, f, a 포함 되었으므로 같은 아나그램으로 본다.  문자열 “kkkk” 경우는[k,k] [k,k] [k,k] [k,k][1,2] [2,3] [3,4] [1,4] 처럼 개별 자리의 문자로 인식한다즉 [k,k]가 있다고 [k,k] 케이스가 또있네 라고 햇갈릴수 있는데각각 개별 자리의 문자를 독립적으로 본다해결책문자열 “aaa”가 있을 때 각각 문자열a, aa, aaa를 아래와 같이 저장한다.  map에 key = 문자, value = 각 문자열의 개수(1,2,3,…n 수열의 차수로 사용될 것이다.)문자열 “aaaa” 경우 개별 문자열의 개수 아래와 같다.a    = 4개 aa   = 3개 aaa  = 2개aaaa = 1개문자열 “aaaa” 개별 문자열 개수가 도출 된 이유를 설명하면1   2   3   4 (문자열 순번)a   a   a   a문자                                개수(n차)  조합개수a    = a(1), a(2), a(3), a(4)    = 4개     = 6개aa   = aa(1,2), aa(2,3), aa(3,4) = 3개     = 3개aaa  = aaa(1,2,3), aaa(2,3,4)    = 2개     = 1개aaaa = aaaa(1,2,3,4)             = 1개     = 0개 (아나그램으로 조합할 수가 없다 1개만 존재하므로)이렇게 도출된 개수를 수열로 보면aaaa  aaa   aa     a (각문자) 1     2     3     4 (n차) 0     1     3     6 (조합개수) = 총 10개(정답)조합개수 1, 3, 6을 가만히 보면1 2 3 (n차)1 3 6 =&gt; 계차 수열임 2 3  =&gt; 공차가 1인 등차수열을 가지는   1   =&gt; 공차(1)더 자세히 보면 공차가 1인 등차수열을 가지는 계차수열이기도 하지만각각의 일반항이 n차 자연수의 합과 같다는 것을 알수 있다.1     2     3   (n 차)1     3     6   (n일 때 일반항의 개수(자연수의 합))1    1+2  1+2+3 (n이 1일 때 일반항 1, n이 2일 때 일반항 3(1+2 =&gt; 자연수의 합공식) )자연수의 합 공식은  n(n+1) / 2자연수의 합공식을 이용하여 각 일반항을 모두 더해주면 정답이 나오는데n 차수가 다르다.원래는 차수 1부터 순차적으로 증가할 때 각 n차의 일반항의 개수가 아래와 같은데1  2  3 (n차)1  3  6 (조합개수) = 총 10개(정답)이 경우 차수가 +1씩 크다1  2  3  4 (n차)0  1  3  6 (조합개수) = 총 10개(정답)그래서 자연수 합 공식에서 n =2 일때 1이 되어야 하므로 n-1을 해주어야 한다.자연수 합 공식 n(n+1) / 2 에서 n을 -1 씩 하게 되면  (n-1){(n-1)+1} / 2되고 전개 해서 풀이하면 결국  n(n-1) / 2와 같은 식이 도출된다.n(n-1)/2 공식을 적용하여 aaa 3일때 각 조합은a   = 3개 이고 공식 적용하면 = 3aa  = 2개 이고 공식적용 = 1aaa = 1개라 공식적용 = 01+3 = 모두 더하면 4가 된다.소스코드public class SherlockAndAnagrams {    public static int sherlockAndAnagrams(String s) {        HashMap&lt;String, Integer&gt; dic = new HashMap&lt;&gt;();        for (int i = 0; i &lt; s.length(); i++) {            for (int j = i + 1; j &lt; s.length() + 1; j++) {                String str = s.substring(i, j).chars()                        .sorted()                        .mapToObj(String::valueOf)                        .collect(Collectors.joining());                dic.merge(str, 1, (c, d) -&gt; c + 1);            }        }                return dic.values().stream()                .mapToInt(n -&gt; n * (n - 1) / 2)                .sum();    }}",
        "url": "/algorithm/2020/05/08/sherlock-and-anagrams/"
    }
    ,
    
    "tech-2020-05-06-spring-microservice-summary": {
        "title": "[마이크로서비스] 스프링 마이크로서비스 요약 정리 (spring microservice, msa)",
            "author": "kimchanjung",
            "category": "",
            "content": "스프링마이크로서비스의 책내용중 마이크로서비스를 개발함에 있어 가장 중요한 개념과 원칙들 설계방법 부분을 예제 와 함께 정리[마이크로서비스] 스프링 마이크로서비스 정리스프링 마이크로서비스 책 내용을 모두 요약 한 것이 아니라 개인 적으로 중요하다고 생각되는 개념만 정리 한 것임을 미리 밝혀 둡니다.마이크로서비스의 원칙  마이크로서비스를 설계하는 원칙들은 좋은 마이크로서비스를 설계하고 구현하는데 필수적 이다.서비스하나에 책임도 하나객체지향에 등장하는 개념인 SOLID 원칙중 하나인 단일책임원칙과 마찬가지로 하나의 마이크로서비스는 하나의 책임을 가져야한다. 그렇게 됨으로써 각 서비스간 낮은 결합도를 유지 할 수 있다.  하나의 책임이라는 의미가 중요한 듯 하다 하나의 기능이 아니라 하나의 책임 즉 배달과 주문이 있다고 한다면 배달은 배달과 관련된 기능만 수행한다. 배달 마이크로 서비스가 주문의 상태를 변경하거나 하는 기능이 포함되면 안된다는 의미다.  이 것은 객제관점에서 보아도 배달객체가 주문객제를 직접 변경하는 것 매우 부자연스럽다. 객체 관점에서도 필요할 때는 주문 객체에서 제공되는 주문상태 변경 메소드를 호출하여 주문객체에게 주문상태 변경해달라고 요청하는 모습처럼 마이크로 서비스도 하나의 객체단위로 보는 관점이 필요 하다고 본다.마이크로서비스는 자율적책 내용은 구구절절한데 한마디로 하나의 단독 서비스 처럼 돌아갸야 된다는 이야기다. 웹서비스라면 하나의 웹서비스가 독립적으로 구동되는 형태로 생각하면 이해가 빠를 듯 하다.마이크로서비스의 경계 설정  마이크로 서비스의 경계 설정에 있어 만병 통치약은 없다마이크로서비스의 경계 설정 시 피해야 할 조건  마이크로서비스간 낮은 응집도와 결합도를 유지 해야한다  너무 많은 정보교환  너무 많은 동기적 요청, 응답  순환 의존 관계  트랜잭션 범위가 여러 마이크로서비스에 걸치지 않게 해야함적절한 마이크로서비스 경계 설정 조건자율적인 기능      외부 기능에 대한 의존도가 낮다  배포 단위의 크기      기능이 많은 서비스는 배포규모가 커진다    배포단위의 크기를 감당 가능한 수준으로 유지  분리하기 적합한 기능 또는 서브도메인      마이크로서비스 전환시 자원소모량, 소유 비용, 비즈니스 유용성, 유연성 등이 분석 기준이 된다    마이크로서비스로의 분리가 유용한 선택인지, 분석기준을 통하여 판단한다    검색 요청이 전체 리소스에 많은 부분을 차지하는 시스템이라면 분리 시 여러가지로 유리 하다  하나의 제품으로 생각을 해본다      경계 지어진 마이크로서비스가 하나의 제품으로 구성될 수 있는지의 관점에서 평가 해보자  동기와 비동기 선택기준  어느 하나의 방식만으로 시스템을 개발하는 것은 불가능, 장단점을 따져서 두방식을 적절히 조합 해야한다동기      사용자가 즉시 응답을 받아야 하는 서비스    마이크로서비스간 의존성을 높이는 단점  비동기      즉시 응답 받지 않아도 되는 서비스예) 이메일, 문자 발송, 포인트 서비스, 재고 갱신  마이크로 서비스의 과제마이크로 서비스와 대규모 데이터  주문 마이크로 서비스와 고객 마이크로서비스가 있다고 할 경우 고객별 주문 리스트를 가져와야할 경우에 대한 문제와 고려해 볼 방법들  결론 적으로 주문 - 고객을 조인쿼리로 가져올 수 없다는 문제에 대한 해결 방법필요한 데이터를 미리 생성  즉 고객 별 주문 리스트를 가져오고 싶으면 각각의 마이크로 서비스에서 가져와 필요한 곳에 데이터를 생성(복제본) 해놓는 방법      단점은 데이터 중복문제          이 방법 없이 조인쿼리를 사용할 수 없는 상황에서 두 마이크로 서비스의 데이터를 리스트로 가져오는 방법은 경험상 정말 비즈니스 로직이 복잡해진다.              이런 페이지들이 많다면 개발리소스도 훨씬 많이 들어가고, 어떤 경우는 특정 검색조건에 따라 리스트를 가져올 수 없는 경우도 발생한다.              내 경험상 데이터 중복 문제가 단점이라고 이 방법 없이 여러 마이크로 서비스의 데이터를 조인 없이 조인과 같은 결과를 내는 방법으로 개발을 하는 것은 정말 실수 하는 것이라고 조심스럽게 말해본다.        복제본 데이터를 어떻게 구성할 것인가는 마이크로서비스를 어떻게 구성 했느냐에 따라 달라지므로 상황에 맞게 구성          통합적인 통계 관련 데이터를 제공 하는 서비스가 있다고 한다면 각 마이크로 서비스로 부터 지속적으로 데이터의 생성 변화를 입수하여 데이터 웨어하우스 같은 형태로 관리한다.      입수 방식은 이벤트 소싱(event pub/sub) 방식이 대표적, 메시지 큐 같은 여러 서비스를 활용, rabbitMQ, kafka 등등      의존 관계 관리  서비스 경계를 적절하게 설정해서 의존성을 낮춘다.  의존성을 가능한 느슨하게 설계해서 변경에 대한 영향을 낮춘다.  비동기 통신 방식을 통해 서비스간 상호작용이 일어나도록 설계.  서킷 브레이커 같은 패턴을 사용하여 의존성 문제의 전파를 차단.  의존 관계 그래프 같은 시각화를 통하여 의존 관계를 모니터링.  사실 위 조건들이 마이크로 서비스 설계시 가장 어려운 문제 인 듯 하다.모놀리식 서비스 와 마이크로 서비스 동기와 비동기 등이 어느 한쪽을 선택하면 이익을 얻는 대신 반드시 손해를 보게되는 trade-off 관계 이기 때문이다.마이크로서비스로의 전환 계획  실제 책에서 예제로 나오는 항공사 예약 시스템 대신 본인이 주로 다뤄 왔단 배달 도메인을 예로 설명 합니다.전환 관점에서 제기되는 몇가지 중요한 질문  마이크로서비스 경계 식별  마이그레이션을 위한 마이크로서비스 우선순위 지정  전화 단계에서의 데이터 동기화 처리  이전 UI와 새로운 UI를 다루기 위한 사용자 인터페이스 통합  새로운 시스템에서의 참조 데이터 처리  비즈니스 범위기 제대로 유지될 수 있게 보장하는 테스트 전략  마이크로 서비스의 기능. 프레임워크 등과 같은 마이크로서비스 개발을 위한 전제 조건 확인첫번째 - 마이크로서비스의 경계 식별  가장 먼저 해야 할 일은 모놀리식 서비스에서 마이크로서비스로 전환 하고자 하는 도메인의 경계를 식별하는 것  모놀리식 서비스를 분해 해본다는 관점으로 접근두번째 - 의존 관계 분석  첫번째 단계에서 뽑아낸 마이크로서비스 후보들 간의 의존성을 분석한다.  분석한 의존성을 바탕으로 의존 관계 그래프를 그려본다.세번째 - 면밀한 의존 관계 분석이벤트 소싱에 유리한 케이스      배달 운영에 관한 각종 현황 정보 조회 및 모니터링 가능한 배달운영관리 시스템과 배달을 분리 할 수 있다.    위 그림 처림 배달 운영 시스템이 배달을 직접 가져오는 대신 배달의 생성 및 상태 변경을 배달 모듈이 이벤트를 발행하고, 배달운영관리 시스템은 배달의 변경사항을 구독한다.    이런 시나리오는 배달, 라이더, 배달팁 모듈들에서 변경사항 이벤트를 발행하고, 배달 운영 관리 시스템음 각 모듈의 변경사항을 구독하여 관리하는 방식으로 여러 모듈들에게 적용할 수 있다.  이벤트 소싱에 불리한 케이스(1)      라이더에게 지급할 배달팁 정산을 위해서 정산 시스템 배달 목록을 가져오는데  월단위, 주단위, 일단위 정산이 일반적이므로 모든 배달 데이터는 사실상 필요가 없다    이벤트 소싱으로 구성 된다면 정산 시스템은 항상 모든 배달건의 상태 변경에 대한 이벤트를 구독 받아 처리 해야하므로 불필요한 자원 낭비가 될 수 있다.    차라리 정산 주기에 따라 1번씩 해당 하는 정산 기간의 배달 데이터를 공급 배달 모듈로 부터 공급 받는 것이 결과적으로 유리하다.  이벤트 소싱에 불리한 케이스(2)      고객응대 시스템에서 발생하는 배달건의 고객응대 건수는 발생하는 배달 건수에 비해 현저하게 적은 건수를 가진다. (배달이 100건이라고 한다면 배달불만 접수는 10건이라고 한다면)    이런 경우 고객응대 시스템에서 배달건마다 발생하는 모든 이벤트를 구독받아 배달 데이터를 유지하고 있는 것은 사실상 리소스 낭비에 해당한다.    배달건에 대한 고객 불만 사항이 발생 할때 차라리 직접 배달을 가져오는 편이 유리하다.  동기화 되어야 할 서비스들 사이에서의 이벤트소싱  배달 현황 및 각종 정보를 관리하고 실시간 모니터링하는 서비스가 있다고 한다면 지속적으로 각각의 마이크로서비스로 분리된 시스템에서(배달, 라이더, 배달로) 주기적으로 데이터를 직접 가져오는 방식이 될 것이다.  위 그림과 같은 직접 적인 방식에서 아래 그림과 같은 이벤트 소싱 방식으로 전환 할 수 있다.  위 그림과 같은 이벤트 소싱 방식으로의 전환이 각 시스템간 의존성을 낮춘다.동기화 되어야 할 서비스들 사이에서의 이벤트소싱 문제점      배달을 라이더에게 배차했을 경우 배차 대기 목록 서비스에서 배달상태변경 이벤트를 비동기 이벤트로 구독받아 변경사항을 반영하고 있다.    라이더는 배차대기 목록을 보고 자신이 배달하고 싶은 배달건을 가져온다.    이런 시나리오에서는 배차대기 배달목록이 비동기로 유지될 경우 배달 상태가 불일치하는 경우가 발생할 수 도 있다.    이런경우 라이더는 이미 다른 라이더에게 배차가된 배달건을 가져올 수도 있다.  마이크로서비스간 유효성을 확인 해야하는 경우배차의 경우 배달건을 배차 할 수 있는 배달건인지 유효성을 다음과 같이 확인 할 것이다.      이 배달건은 미배차 배달 건인가?    이 배달건은 금일 발생한 배달 건인가?    이 배달건은 해당 배달권역의 배달건 인가?    기타 등등  이런 경우는 아래 그림과 같이 복잡한 유효성을 확인 하는 것 보다 적적한 유효성을 기존으로 미 배차 배달건 목록을 배달 마이크로시스템에서 관리하여 타 시스템에게 제공하는 편이 유리할 것이다.마이그레이션을 위한 마이크로서비스 우선순위 지정타이틀이 애매한데 풀어서 이야기 하자면 모놀리식 시스템에서 마이크로서비스로 분리하여 전환하고자 초기 설계 이후 도출된 각 마이크로서비스들 중 어떤 서비스를 먼저 전환 해야하는지에 대한 이야기로 이해하면 될 듯 하다. 우선순위를 매기는 기준에 대한 설명.의존관계의존관계가 없거나 적은 서비스는 마이크로서비스로의 전환이 쉬운 반면, 의존관계가 매우 복잡하고 높은 서비스는 위험성과 전환 과정이 어렵다.트랜잭션 크기(요청이 많고 적음)트랜잭션의 크기가 큰 시스템을 마이크로서비스로 전환하는 것은 기존 레거시 시스템의 부하를 줄여주기 때문에 유지보수 관점에서 보았을 때 큰 가치가 있다. 그러나 위험부담이 크다는 단점도 있다.  어떤 위험부담이 있는지에 대한 내용이 책에 없다…..리소스 이용율서버자원을 많이 사용하는 서비스를 마이크로서비스로 전환하는 것은 기존 레거시시스템에 남아 있는 기능들이 더 잘 작동할 수 있다.  개념은 트랜잭션 크기 이야기와 일맥상통한다.복잡도덜 복잡한 시스템이 마이크로서비스로의 전환이 쉽다(당연한 이야기 아닌가??)사업적 중요도저자는 사업적 중요도가 높은 서비스를 마이크로서비스로의 전환하는 것이 좋다고하는데 이유설명이 없어서 아쉽다. 아마도 먼저언급한 여러가지 유용한 이점들이 사업적 중요도가 높은 서비스에게 적용되기 때문이라는 이유 일 듯 싶다.변경속도개발적인 변경이 빈번하게 이루어지는 서비스가 그렇지 않은 서비스보다 마이크로서비스로의 전환에 있어 우선순위가 높다.  역시나 책내용에  근거가 없다…혁신책 내용을 풀이하자면 서비스가 혁신적으로 변경되는 서비스들을 마이크로서비스로 전환하여 운영하는 것이 더 유리하다는 이야기다 서비스를 혁신적으로 변경해야할 때 기존 레거시 시스템에서 혁신적으로 변경하는 것이 더 어렵다고 이야기 하고 있다.마이크로서비스로의 전환 중 레거시시스템과의 데이터 동기화책 내용을 대략 풀이 하자면 전체 모놀리식 시스템을 한번에 모두 마이크로서비스로 전환하는 시나리오는 현실적으로 어렵기도 하고, 레거시 시스템에서 하나씩 분리하여 점진적으로 마이크로서비스로 전환하는 과정에서 레거시 시스템과 마이크로 시스템간의 데이터 동기화를 어떻게 할 것인가에 대한 이야기다.예를 들어보자면      배달과 라이더가 같은 시스템에 함께 존재 하였는데 라이더관리 시스템으로 분리    분리된 라이더 관리 시스템에서는 라이더 정보를 등록,수정,삭제 관리한다.    기존 레거시 시스템에서는 라이더정보 등록,수정,삭제는 제거 되고 라이더 관리 시스템에서 처리하고 있다.    하지만 기존 레거시 시스템에서는 라이더와 배달건을 조회하는 목록 페이지가 여전히 존재한다.    이 경우 여전히 레거시 시스템의 DB에서 라이더 정보를 가져오는 로직이 남아 있기 때문에 라이더 관리 시스템으로 이전 되기 전까지는 두 시스템 사이에 라이더 데이터는 동기화 되어야한다.  해결책이벤트 소싱을 이용해서 해결, 즉 라이더 관리 시스템에서 라이더 정보의 생성, 수정, 삭제 이벤트를 발행하고 기존 레거시 시스템은 구독하여 로컬 DB에 반영하도록 한다.  [사족] 그런데 나중에 모두 라이더 관리 마이크로서비스로 전환 되더라도 대규모 데이터를 조인 없이 가져와야될 상황이라면 어짜피 이벤트소싱으로 구성해야되는 것은 마찬가지 이다.참조 데이터 관리책에서 이야기하는 참조 데이터가 어떤 데이터를 의미하는지 명확한 설명이 없어서 조금 애매한 부분이다. 마이크로서비스단위의 큰 도메인 데이터가 아니라(배달, 주문, 라이더 같은) 여러 마이크로서비스에서 필요에 의해 참조해야는 데이터 들이 아닌가 추측해본다.예를 들자면 배달, 라이더 둘다 필요한 배달팁 정책 같은 데이터를 의미하는 것 일 수도 있다.배달을 생성 할때 배달팁을 참조하여 배달가격을 책정하기에 필요하다. 이런 경우 마이크로서비스에서 기존레거시를 직접 호출하는 것은 기존 레거시 시스템에 트랜잭션이 몰릴수 있기 때문에 지양하라고 한다.해결책이벤트소싱 방식참조 데이터를 처리하는 마이크로서비스를 따로 만들어 각 마이크로 서비스에 제공하는 방식을 추천하는데 이벤트소싱 방식은 동기화 문제가 있을 수 있다. 배달팁이 변경 되고 비동기 이벤트를 발행하고 배달 마이크로서비스에서 배달 생성시 아직 변경된 이벤트를 수신 받지 못한 상태에서 변경전 배달료로 배달이 생성될 수도 있다는 이야기다.인메모리 데이터 그리드참조 데이터 마이크로서비스는 참조데이터의 변경사항을 인메모리 데이터 그리드에 반영 처리하고 각 마이크로서비스들은 인메모리 데이터 그리드를 참조한다. 이 방법은 데이터 동기화에 대한 문제를 해결한다.  인메모리 데이터 그리드는 데이터를 메모리로 관리한다는 점에서 REDIS인가? 하고 생각 할 수 있지만 REDIS와는 또 다른 개념이 적용된 메모리 저장소 인 듯 하다. 자세한 개념은 구글링을 통해서 찾아보면 도움이 될 듯 하다.마무리스프링 마이크로서비스의 책 내용중 마이크로서비스를 설계 하기 위해서 가장 중요한 원칙과 설계방법 장단점 등의 내용만 정리해 보았습니다.",
        "url": "/tech/2020/05/06/spring-microservice-summary/"
    }
    ,
    
    "programming-2020-05-06-kotlin-basic-syntax-summary": {
        "title": "코틀린 기본 문법 요약 정리 강좌 - [kotlin/cheat sheet]",
            "author": "kimchanjung",
            "category": "",
            "content": "코틀린의 기본문법을 치트형식의 예제코드와 설명을 포함한 깔끔하게 요약정리한 문법정리입니다.코틀린 기본 문법kotlin 기본 문법을 간략하게 파악 해보기 위한 요약 정리 입니다. kotlin 문법의 모든 내용을 다루지는 않지만 간략하게 훝어 보는 용도로 포스팅합니다.변수변수 선언val name:String = \"김찬정\" // 읽기만 가능var age:String = 20 // 읽기/쓰기 가능var address = \"서울\" // 타입생략이 가능name = \"홍길동\" // 컴파일 오류age = 20 // 가능Null 허용 변수와 Null을 허용하지 않는 변수 선언// null 값 허용 변수 선언var name: String? = null// null 값을 허용하지 않는 변수에 null을 선언 할 수 없다.var age: Int = nullNull 체크val name: String? = null// name 이 null이 아니면 length 를 반환// java 에서  Integer nameLength = name != null? name.length() : null; 같음val nameLength = name?.length// name 이 null 이면 NullPointerException 발생 시킨다.val nameLength = name!!.length// 타입케스팅이 불가능한 경우 예외를 발생시키지 않고 null 반환한다.val age: Int? = name as? Int?흐름제어IF 표현식// String msg = msgType == 1 ? \"안녕\" : \"잘가\"; 와 같다val msg = if (msgType == 1) \"안녕\" else \"잘가\"// 함수 선언 시 if를 아래와 같이 사용가능 하다 fun getMsg(msgType: Int) = if (msgType == 1) \"안녕\" else \"잘가\"WHEN 표현식val inputType = 2val msgType = \"2\"fun checkType(type: Int) = if (type == 1) 1 else -1when (inputType) {    1 -&gt; println(\"1\")    2, 3 -&gt; println(\"2 or 3\")    else -&gt; println(\"not\")}// 조건에 함수를 적용할 수도 있다.when (inputType) {    checkType(inputType) -&gt; println(\"OK\")    else -&gt; println(\"NOT OK\")}// 조건에 범위 연산자 사용도 가능하다.// 1~100 에 포함된다면 val result = when (inputType) {    in 1..100 -&gt; \"1..100 OK\"    else -&gt; \"NOT OK\"}// 분기처리할 때 확인 대상이 되는 변수를 다르게 줄 수도 있다.when {    inputString == \"4\" -&gt; println(\"4 OK\")    msgType == \"2\" -&gt; println(\"msgType = 2\")}FOR 반복문val item = arrayOf(1, 2, 3)val list = listOf(1, 2, 3)for (index in item.indices) {    println(index)}for (index in list.indices) {    println(index)}// 1부터 100 까지 반복for (i in 1..100) {    print(\"$i \")} // 1부터 99까지 반복for (i in 1 until 100) {    print(\"$i \")} // 2 부터 10 까지 반복,  2씩 증가for (i in 2..10 step 2) {    print(\"$i \")} // 10 부터 1 까지 감소for (i in 10 downTo 1) {    print(\"$i \")} WHILE 반복문val item = Array(5) { v -&gt; v + 1 }var index = 0while (index &lt; item.size) {    println(item[index])    index++}함수함수 선언// 기본적인 함수 선언 방식// fun basicFunc(name: String): Int &lt;= Int는 리턴 타입이다fun basicFunc(name: String): Int {    return name.toInt()}// 한줄에 선언 하는 방식// 한줄 선언 식에서는 리턴타입 생략 가능하다.fun simpleFunc(name: String) = name.toInt()기본 매개변수// name: String = \"김찬정\" &lt;= 매개변수에 기본 값을 선언, 함수 호출시 // 매개변수를 주지 않으면 name은 디폴트 값인 \"김찬정\"으로 선언된다.fun simpleFunc(name: String = \"김찬정\", age: Int): String {    return name} 명명된 매개변수 - Named Parametersfun simpleFunc(name: String , age: Int = 10) = namevar name = simpleFunc(\"김찬정\", 10)var name = simpleFunc(name = \"김잔정\", age = 10)var name = simpleFunc(age = 10)var name = simpleFunc(age = 10, name = \"김찬정\")  함수의 파라메터를 선언된 순서가 아닌 호출시 지정해서 줄 수 있다.함수 호출 시 가변인자// newList(vararg ts: T) =&gt; java에서 newList(String... name)와 같다fun &lt;T&gt; newList(vararg ts: T): List&lt;T&gt; {    val result = ArrayList&lt;T&gt;()    for (t in ts)        result.add(t)    return result}val newList = newList(1, 2, 3)// '*' 스프레드 연산자이며  item배열의 요소를 풀어서 넘긴다.val item = Array(5) { v -&gt; v + 1 }val newList2 = newList(*item) 확장함수val arrayOf = arrayOf(1, 2, 3)// Array 클래스의 length 메소드를 override 한다.fun &lt;T&gt; Array&lt;T&gt;.length(): Int {    return 1}// Array 크래스에 새로운 메소드를 추가한다.fun &lt;T&gt; Array&lt;T&gt;.addMethod(index1: Int, index2: Int): Int {    return 1}val addMethod = arrayOf.addMethod(1, 3) // 1이 리턴된다.val length = arrayOf.length() // 1이 리턴된다.  확장함수는 특정클래스로 부터 상속받지 않고 해당클래스의 기능을 확장 한다.중위함수(infix)// 중의 함수 선언은 infix 키워드를 붙여 선언한다.infix fun Int.multiply(value: Int): Int {    return this * value}println(9 multiply 1) // 9 출력println(9.multiply(1)) // 9 출력println(3 + 2 multiply 2) // 10 출력, + 연산자 우선순위가 더 높다   중위함수 선언 조건      클래스의 멤버 함수이거 나 확장 함수이어야 한다.    매개변수가 한 개여야 한다.    infix 키워드로 함수가 정의되어야 한다.  클래스클래스 선언 - Kotlin// 멤버 프로퍼티(변수)와 생성자를 동시에 선언class SimpleClass(val name: String, var address: String, var age: Int = 41)  kotlin 클래스의 기본생성자는 클래스명 바로 옆 “()” 구문이다. 기본 생성자의 매개변수 선언을 val name: String 하면 멤버 프로퍼티(변수)선언과 기본생성자 매개변수 선언을 동시에 한 것이다.클래스 선언 - Javapublic class SimpleClass {    private String name;    private String address;    private Integer age    public SimpleClass(String name, String address, Integer age) {        this.name = name;        this.address = address        this.age = age    }    public String getName() {        return name;    }    public String getAddress() {        return address;    }    public Integer getAge() {        return age;    }    public void setName(String name) {        this.name = name;    }    public void setAddress(String address) {        this.address = address;    }    public void setAge(Integer age) {        this.age = age;    }}  Kotlin 클래스 선언이 위 Java 코드와 동일하다.클래스 멤버 프로퍼티와 생성자 파라메터 동시 선언// var name: String &lt;= var/val 를 붙이면 // 생성자 매개변수 선언과 동시에 멤버 프로퍼티(변수)를 선언한 것과 같다class BasicClass(var name: String, var address: String) {    // var name:String &lt;= 한 것 과 같다    ...}클래스 멤버 프로퍼티와 생성자 파라메터 각각 선언// name: String &lt;= var/val 를 붙이지 않으면 생성자 매개변수만 선언 한 것 이다.// 그래서 멤버 프로퍼티(변수)를 꼭 선언 해야한다.class BasicClass(name: String, address: String) {    var name:String    var address:String    ...}  위 경우에는 반드시 기본생성자의 초기화 init블럭이 있어야 한다.클래스 기본생성자의 초기화 init 블럭class BasicClass(var name: String, var address: String) 처럼 프로퍼티 선언과 생성자 매개변수 동시 선언 하지 않으면 아래 예제 처럼 멤버 프로퍼티 선언과 함께 init블럭을 통하여 멤버프로퍼티의 초기화도 해주어야 한다.class BasicClass(name: String, address: String, age: Int) {    // 프로퍼티선언과 동시에 생성자 파라메터로 값 설정이 가능하며 초기화 구문 까지 포함 된 것이다.    var name: String = name     var address: String    var age: Int    init {        this.address = address        this.age = age    }}  name 프로퍼티는 var name: String = name  선언과 동시에 초기화 구문 까지 함께 기술 하였기 때문에 init 블럭에서 초기화 구분이 제외 되었다.코틀린 init을  Java로 표현public class BasicClass {    private String name;    private String address;    private Integer age    public BasicClass(String name, String address, Intger age) {        this.name = name;        this.address = address;        this.age = age;    }}  클래스 기본생성자의 초기화 init 블럭을 Java 코드로 표현하면 위와 같다.클래스와 접근제한자            접근 제한자      클래스 멤버일 때      최상위 수준으로 선언되었을 때                  public(기본값)      어디서든 사용 가능      어디서든 사용 가능              internal      같은 모듈에서만 사용 가능      같은 모듈에서만 사용 가능              protected      서브 클래스에서만 사용 가능      해당 없음              private      클래스 내부에서만 사용 가능      코틀린 파일 내부에서만 사용 가능      코들린의 프로퍼티란?코틀린에서 프로퍼티란 클래스의 멤버 변수를 말하는데 코틀린에서 멤버 변수는 단순히 var name:String 으로 선언 되어 변수만 선언된 것 같지만 setter/getter를 따로 선언 하지 않아도 기본적으로 생성되며 변수 + setter + getter 프로퍼티라고 부른다.하지만 person.name 처럼 사용하면 person.getName() 처럼 getter를 사용하지 않는 것 처럼 보이지만 사실은 person.name 값을 가져오면 내부적으로 getter를 사용 한 것이다.클래스의 프로퍼티와 override getter/setterclass BasicClass(name: String, address: String, age: Int) {    var name: String     var address: String        get() = \"$field 특별시\"        set(address) {            field = \"$address 특별시\"        }    var age: Int    init {        this.name = name         this.address = address        this.age = age    }}val basicClass = BasicClass(\"김찬정\", \"서울\", 10)println(basicClass.address) // 서울 특별시 로 출력 됨basicClass.address = \"서울\" // 서울 특별시 로 변경됨  기본적으로 getter/setter가 제공되지만 예제 처럼 override 한 것이다. basicClass.getAddress(), basicClass.setAddress(“서울”) 처럼 사용해야 될 것 같지만 변수를 바로 다루는 듯 사용하며 실제로 getter/setter가 동작 한다.코들린의 public 프로퍼티의 변수는 public인가?// 아래 처럼 선언하면 class BasicClass(name:String) {    var name:String // public 생략됨    private var age: Int // 프로퍼티를 private로 선언하면}  코틀린의 접근제한자는 기본적으로 멤버 프로퍼티(변수+getter+setter)에 대한접근 제한 자이다. public var name:String 은 name라는 변수는 private로 직접 접근이 불가능하며 기본으로 제공되는 getter/setter에 의해서 접근이 되는 것이고 getter/setter가 제공됨으로써 name프로퍼티는 public인 것 이다. 아래 예제를 보자 JAVA 코드로 변환 하면 실제로는 아래와 같다public class BasicClass {    private String name;    private Integer age;    public String getName() {        return this.name;    }    public void setName(String name) {        this.name = name;    }}  private var age: Int 프로퍼티를 private로 선언했기 때문에 Java 코드로 본다면  getter/setter가 제공 되지 않아 외부에서 접근 자체가 불가한 것이다.생성자 오버로딩(여러개의 생성자)class OverLoadingConstructor(name: String) {    // init 블럭 그리고 constructor에 초기화 구문이 둘다 들어가 있으므로 초기화 필요 없다.    var name: String    lateinit var address: String    // primitive type 프로퍼티는 사용 불가능 하기 때문에 0값으로 라도 초기화 해야한다.    var age: Int = 0    init {        this.name = name    }    constructor(name: String, address: String, age: Int) : this(name) {        this.name = name        this.address = address        this.age = age    }}// 다음과 같이 생성자가 제공된다.val overLoadingConstructor = OverLoadingConstructor(\"김찬정\")val overLoadingConstructor2 = OverLoadingConstructor(\"김찬정\", \"서울\", 20)  lazyinit 이란 멤버프로퍼티의 값 초기화를 지연하는 키워드이며 다음과 같은 특징이 있다.      var(mutable) 프로퍼티만 사용 가능    non-null 프로퍼티만 사용 가능    커스텀 getter/setter가 없는 프로퍼티만 사용 가능    primitive type 프로퍼티는 사용 불가능    클래스 생성자에서 사용 불가능    로컬 변수로 사용 불가능  Init 블럭 없는 생성자 오버로딩class OverLoadingConstructorWithoutInit {    var name: String    var address: String = \"\"    var age: Int = 0    constructor(name: String) {        this.name = name    }    constructor(name: String, address: String, age: Int) {        this.name = name        this.address = address        this.age = age    }}// 다음과 같이 생성자가 제공된다.val overLoadingConstructor = OverLoadingConstructor(\"김찬정\")val overLoadingConstructor2 = OverLoadingConstructor(\"김찬정\", \"서울\", 20)  클래스 선언시 클래스명 옆에 기본생성자를 선언하지 않고 constructor를 선언한다. 그렇게 되면 init 블럭도 필요없어진다.정적 팩토리 메소드class PrivateDefaultConstructor private constructor() {    lateinit var name: String    // object 키워드로 인하여 of 메소드는 static 으로 생성된다.    companion object {        // 선언된 프로퍼티도 static으로 선언된다        var address = \"서울\"        fun of(name: String): PrivateDefaultConstructor {            val instance = PrivateDefaultConstructor()            instance.name = name            return instance        }    }}// 정적팩토리 메소드로 객체 생성이 가능하다.  val of = PrivateDefaultConstructor.of(\"김찬정\")      기본생성자를 private로 접근제한하여 외부에 제공하지 않는다.    companion object 사용하여 static 메소드를 생성하여 객체를 생성하는 정적 팩토리를 제공한다.  JAVA 코드로 보자면 아래와 같다public class PrivateDefaultConstructor {    private String name;    private PrivateDefaultConstructor()    public PrivateDefaultConstructor of(String name) {      PrivateDefaultConstructor instance =  new PrivateDefaultConstructor();      instance.name = name      return name;    }}// 아래와 같이 정적팩토리 메소드로 객체 생성이 가능하다.val of = PrivateDefaultConstructor.of(\"김찬정\")JAVA 코드에서 호출을 위한 정적 팩토리 메소드 선언 방식// static field에는 const 또는 @JvmField 붙인다// static method에는 @JvmStatic 붙인다 class PrivateDefaultConstructorForJava private constructor() {    lateinit var name: String    companion object {        const val address = \"서울\"        @JvmField        val age = 20        @JvmStatic        fun of(name: String): PrivateDefaultConstructorForJava {            val instance = PrivateDefaultConstructorForJava()            instance.name = name            return instance        }        @JvmStatic        fun ofNew(name: String) = of(name)    }}  자바에서 코틀린 객체의 스태틱멤버를 호출 할때 PrivateDefaultConstructor.companion.address 로 접근 해야 하기 때문에 위 예제 처럼 선언 해야 Java 코드에서 PrivateDefaultConstructorForJava.address 로 접근 가능하다.멤버 프로퍼티의 캡슐화class BasicClass(name: String, address: String, age: Int) {    var name: String         private set    var address: String    var age: Int    init {        this.name = name        this.address = address        this.age = age    }}  코틀린 프로퍼티는 기본이 public(변수자체는 private이다)이므로 값은 외부에서 참조 가능 하지만, 변경은 불가하도록 하려면 기본 setter를 private로 지정 하면 된다. (private val name:String 으로 선언하면 외부에 아예 사용 차제가 안되게 때문에)클래스의 상속open class Parent(name: String, age: Int) {    var name: String    var age: Int    init {        this.name = name        this.age = age    }    fun isAdultParentMethod() = age &gt; 20    open fun getNameInEnglish(): String {        return \"kim\"    }}class Child(name: String, age: Int, address: String) : Parent(name, age) {    var address: String    init {        this.name = name        this.age = age        this.address    }    override fun getNameInEnglish(): String {        return \"child kim\"    }}  Java 와는 다르게 open 키워드가 붙은 클래스만 상속 할 수 있다.클래스 상속 - 기본생성자를 사용하지 않는 경우class Child2 : Parent {    var address: String    constructor(name: String, age: Int, address: String) : super(name, age) {        this.address = address    }}  super 키워드를 통하여 부모클래스를 초기화 해야한다.인터페이스 선언interface ImplementInterface {    interface ImplementInterface {    val number: Int    val name: String    fun getNameInEnglish(): String    fun isAdult(): Boolean}인터페이스 구현class ImplementInterfaceImpl(private var age: Int) : ImplementInterface {    override val number: Int        get() = 1    override val name: String = \"김찬정\"    override fun getNameInEnglish(): String {        return \"kim\"    }    override fun isAdult() = age &gt; 19}추상클래스 선언과 구현abstract class Car {    val name: String = \"자동차\"     abstract fun start()    fun stop() {}}class Sonata() : Car() {    override fun start() {} }추상클래스 선언 - 심화abstract class AbstractClass(name: String) {    open var name: String = \"\"    var age: Int = 0        set(value) {            field = value        }    init {        this.name = name + \"이다\"    }    fun isAdult() = age &gt; 19    abstract fun getNameInEnglish(): String}      open 키워드를 붙인 프로퍼티는 구현클래스에서 override 가능    추상클래스자체로 객체를 생성할 수 없지만 구현 클래스 객체 생성시 init 블럭이 수행 된다.  추상클래스 구현 - 심화class AbstractClassImpl(name: String, age: Int, address: String) : AbstractClass(name) {    override lateinit var name: String    var address: String = address    init {        this.name = name        this.age = ag    }    override fun getNameInEnglish(): String {        return \"kimchanjung\"    }}  구현 클래스에서 추상클래스의 멤버를 직접 오버라이딩 하거나 아니면 그대로 상속 받거나, init 블럭의 초기화 순서 등등은 실제로 수행 해보면서 순서를 살펴 보아야 파악이 가능하다.OBJECT 키워드object StaticClass {    var name = \"김찬정\"    var age = 20    fun getNameWithEnglishName() = \"$name (kimchanjung)\"    fun isAdult() = age &gt; 19}println(StaticClass.name)println(StaticClass.isAdult())  Java 에서 static 멤버 변수와 메소드가 있는 클래스로 보면 된다. 객체를 런타임시 새로 생성하는 것이 아니기 때문에 또한 싱글톤이다.중첩클래스와 내부클래스class OuterClass {    val outerName = \"아우터네임\"    companion object {        val staticOuterName = \"정적아우터네임\"    }    /**     * static 키워드가 붇지 않았지만 static 멤버 클래스다     * OuterClass.StaticNestedClass() 로 객체 생성한다.     * Outerclass의 멤버에 접근을 할 수 없다.     * static 멤버에는 접근이 가능함     *     */    class StaticNestedClass {        val nestedName = \"내부네임\"        fun getOuterName() = println(\"StaticNestedClass - $nestedName $staticOuterName\");    }    /**     * non static 멤버 클래스     * OuterClass().InnerClass()로 객체 생성     * OuterClass의 non-static 멤버도 접근 가능함     * 사실 이건 접근제어라기 보다 클래스가 static/non-static 차이에서 발생하는 자연스런 접근 제한     */    inner class InnerClass {        val nestedName = \"내부네임 \"        fun getOuterName() = println(\"InnerClass - $outerName $staticOuterName\");    }}// 중첩클래스의 객체 생성val staticNestedClass = OuterClass.StaticNestedClass()// 내부클래스의 객체 생성val innerClass = OuterClass().InnerClass()      중첩클래스는 외부클래스의 static 멤버로 존재하기 때문에 외부클래스.중첩클래스() 로 생성한다 (JAVA와 같다.)    내부클래스는 static 멤버로 존재하는 것이 아니기 때문에 외부클래스의 인스턴스를 생성후 내부클래스 인스턴스 생성이 가능하다.  데이터 클래스data class Entity(val id: Long, val name: String)  data 클래스는 아래 메소드를 기본제공      equals()    hashCode()    copy()    toString()    componentsN()  클래스 위임/* * by 키워드를 이용한 위임은 interface의 구현체만 위임 활 수 있다. * 일반 클래스를 위임하는 것은 안된다. */interface UserService {    fun findByName(name: String): String    fun findAll(): List&lt;String&gt;}class UserServiceImpl(var name: String) : UserService {    override fun findByName(name: String) = name;    override fun findAll() = listOf(name, \"kimchanjung\")}/** * 실제적으로는 UserService를 구현하는 것이 아니라 UserServiceImpl를 상속 없이 상속 하는 * 이라고 보면된다 open 키워드가 없어 상속 할 수 없는 UserServiceImpl 위임하여 * 상속의 효과를 누린다. * 또 하나의 장점은 모든 메소드를 구현 할 필요가 없고 필요한 메소드만 오버라이드 하면된다 */class ImplByUserService(private val us : UserService) : UserService by us {    override fun findAll() = listOf(name, \"kimchanjung\", \"mogomezwai\")}  클래스위임은 상속 불가능한 클래스를 상속과 같은 효과를 누리는 동시에 필요한 메소드만 오버라이드 가능한 장점이 있다.클래스 위임 장점의 예 - 인터페이스 구현class NewList&lt;T&gt;(override val size: Int, init: (index: Int) -&gt; T) : MutableList&lt;T&gt; {    private val list = ArrayList&lt;T&gt;(size)    init {        repeat(size) { index -&gt; list.add(init(index)) }    }    override fun contains(element: T): Boolean {        TODO(\"Not yet implemented\")    }    override fun containsAll(elements: Collection&lt;T&gt;): Boolean {        TODO(\"Not yet implemented\")    }    override fun get(index: Int): T {        return list.get(index)    }    ........}  일반적인 방식의 인터페이스구현은  MutableList interface 구현체 모든 메소드를 구현해야한다.클래스 위임 장점의 예 - 클래스 위임을 사용class NewList&lt;T&gt;(override val size: Int, private val ml: MutableList&lt;T&gt; = mutableListOf(), init: (index: Int) -&gt; T) : MutableList&lt;T&gt; by ml {    init {        repeat(size) { index -&gt; ml.add(init(index)) }    }    override fun add(element: T): Boolean {        return ml.add(element)    }}  위임을 사용한 경우는 모든 메소드를 오버라이드 할 필요 없다.ENUM 클래스 선언enum class EnumClass(var number: Int, var desc: String) {    WAIT(1, \"대기\"),    CONSIGN(2, \"배차완료중\"),    COMPLETE_PICKUP(3, \"픽업완료\"),    COMPLETE_DELIVERY(4, \"전달완료\");    fun getStatus() = \"$desc($number)\"}  기본생성자에 반드시 var number: Int var, val 를 붙여 멤버선언/매개변수 동시에 선언해야한다.ENUM 클래스를 WHEN 에서 활용fun selectStatus(status: EnumClass) = when (status) {    EnumClass.COMPLETE_DELIVERY -&gt; \"COMPLETE_DELIVERY\"    EnumClass.CONSIGN, EnumClass.COMPLETE_PICKUP -&gt; \"CONSIGN or COMPLETE_PICKUP\"    else -&gt; \"NOT\"}fun selectStatus(status1: EnumClass, status2: EnumClass) = when (setOf(status1, status2)) {    setOf(EnumClass.COMPLETE_DELIVERY) -&gt; \"COMPLETE_DELIVERY\"    setOf(EnumClass.CONSIGN, EnumClass.COMPLETE_PICKUP) -&gt; \"CONSIGN or COMPLETE_PICKUP\"    else -&gt; \"NOT\"}Sealed 클래스  Sealed 클래스는 Enum 클래스의 확장입니다.  Enum클래스를 사용할 때 불리한 점을 보완 할 수 있습니다.Sealed 클래스의 장점을 설명 하기 위하여 어떤 값을 상수나 오브젝트 형태로 사용하는 경우, Enum 클래스를 사용하는 경우 그리고 Sealed 클래스를 사용하는 경우를 예로 들어 설명합니다.일반 값 형태로 사용 하는 경우object DeliveryStatus {    val WAIT = 1    val CONSIGN = 2    val PICKUP = 3    val COMPLETE = 4 // 추후에 추가한 상태값}fun selectDeliveryStatus(deliveryStatus: Int): String {    return when (deliveryStatus) {        WAIT -&gt; \"대기($deliveryStatus)\"        CONSIGN -&gt; \"배차($deliveryStatus)\"        PICKUP -&gt; \"픽업($deliveryStatus)\"        /**         *  DeliveryStatus 에 COMPLETE를 추가 했으면 이 라인도 당연히 추가 했어야 하지만         *  추가 하지 않아도 컴파일 에러는 없기 때문에 개발자가 빼먹어 런타임에 의도치 않은 결과를 초래할 수 있다.         */        // COMPLETE -&gt; deliveryStatus        else -&gt; \"오류(0)\"    }}  보통 특정 상태 값을 선언할 때는 Enum 클래스를 사용하는 것이 보통이나 일반적인 형태로 선언 하고 이것을 사용 하는 코드에서 발생 할 수 있는 문제점은 다음과 같다      DeliveryStatus를 사용하는 비즈니스 로직 selectDeliveryStatus에서 새로 추가한 상태값 COMPLETE에 대한 처리를 해주지 않아도 컴파일이 된다.    이런경우 런타임 시 COMPLETE는 else 로 처리 되게 됨으로 개발자가 상태 값만 추가하고 비즈니스 로직처리를 빼먹는 사태가 발 생 할 수 있다.    DeliveryStatus 상태가 추가 될 때 마다 비즈니스로직에 관련 처리를 계속적으로 추가 해주어야한다.    when 구문에서도 else 구문 추가가 필수 적이다, 그 이유는 selectDeliveryStatus(DeliveryStatus.PICKUP) 로 메소드를 호출 하는 경우 when구문 입장에서는 int 값에 어떤 값이 들어올지 미리 알 수 없기 때문에 else 구문을 추가 하지 않으면 컴파일 오류가 발생한다.  ENUM 클래스를 사용 하는 경우enum class EnumDeliveryStatus(val code: Int, val codeName: String) {    WAIT(1, \"대기\"),    CONSIGN(2, \"배차\"),    PICKUP(3, \"픽업\"),    /**     * COMPLETE를 나중에 추가 했을 경우에 selectEnumDeliveryStatus에     * EnumDeliveryStatus.COMPLETE -&gt; deliveryStatus.code 이 구문을 추가 해주지 않으면     * 컴파일 오류 발생한다.     */    COMPLETE(4, \"완료\");    fun getCodeWithName() = \"$codeName($code)\"}/** * EnumDeliveryStatus 선언 당시 값이 명확히 정해 지므로 when 에서 else 처리도 불필요 해진다. */fun selectEnumDeliveryStatus(deliveryStatus: EnumDeliveryStatus): String {    return when (deliveryStatus) {        EnumDeliveryStatus.WAIT -&gt; \"${deliveryStatus.codeName.toString()}(${deliveryStatus.code.toString()})\"        EnumDeliveryStatus.CONSIGN -&gt; \"${deliveryStatus.codeName.toString()}(${deliveryStatus.code.toString()})\"        EnumDeliveryStatus.PICKUP -&gt; \"${deliveryStatus.codeName.toString()}(${deliveryStatus.code.toString()})\"        EnumDeliveryStatus.COMPLETE -&gt; \"${deliveryStatus.codeName.toString()}(${deliveryStatus.code.toString()})\"    }}  일반적으로 Enum 클래스를 사용 했을 경우을 살펴 보자      COMPLETE 상태가 추후에 추가되었을 경우 EnumDeliveryStatus 클래스를 사용하는 비즈니스로직에서COMPLETE 상태 처리에 대한 구문이 추가 되지 않으면 컴파일 오류가 발생하므로 개발자가 실수로 빠트리는 일은 없다.    Enum 클래스의 값은 선언 당시에 완전히 정해 지므로 런타임시 어떤 값이 들어올지 모르는 상황이 아니므로when 처리시 else 구문이 필요없게 된다.  Sealed 클래스를 사용 하는 경우/** * sealed class는 enum 클래스의 확장형이라고 설명하고 있는데 * Enum 클래스는 아래와 같이 멤퍼 프로퍼티나, 메소드를 다르게 줄 수 없지만 sealed 클래스는 가능하기 때문이다. */sealed class SealedDeliveryStatus {    class WAIT(var code: Int, var codeName: String) : SealedDeliveryStatus()    class CONSIGN(var code: Int, var codeName: String, val riderName: String) : SealedDeliveryStatus()    class PICKUP(var code: Int, var codeName: String) : SealedDeliveryStatus()    class COMPLETE(var code: Int, var codeName: String, var completeTime: String) : SealedDeliveryStatus(){        fun getCodeWithCompleteTime() = \"$code $completeTime\"    }}/** * 각 상태에 맞는 멤버프로퍼티/메소드를 다르게 리턴 하도록 처리 가능하다. */fun selectSealedDeliveryStatus(deliveryStatus: SealedDeliveryStatus): String {    return when (deliveryStatus) {        is WAIT -&gt; deliveryStatus.codeName        is CONSIGN -&gt; deliveryStatus.riderName        is PICKUP -&gt; deliveryStatus.code.toString()        is COMPLETE -&gt; deliveryStatus.getCodeWithCompleteTime()    }}Collections배열val arr = arrayOfNulls&lt;Int&gt;(10)val initArr = arrayOf(1, 2, 3)val initDiffTypeArr = arrayOf(1, \"2\", 3L)val initIntArr = intArrayOf(1, 2, 3)val initConstructorArr = Array(10) { 1 }val initLambdaArr = Array(10) { v -&gt; v + 1 }val initWithIncrement = (1..10).toList().toTypedArray()val initWithIncrementByStep = (1..10).step(2).toList().toTypedArray()val initWithIncrementByStep2 = IntRange(1, 10).step(2).toList().toTypedArray()     List// 불변 List 초기화 이후 수정 삭제 불가val listOf = listOf(1, 2, 3)val list = List(3) { v -&gt; v + 1 }// 수정 삭제 추가 가능val emptyMutableList = mutableListOf&lt;Int&gt;()val mutableListOf = mutableListOf(1, 2, 3)val mutableList = MutableList(2) { v -&gt; v + 1 }listOf.get(0)listOf[0]mutableListOf.add(3, 4)mutableListOf.remove(1)// even [2], odd [1,3] 각각 리스트를 구분 해서 반환함val (even, odd) = listOf.partition { it % 2 == 0 }Map// 불변val mapOf = mapOf(\"a\" to 1, \"b\" to 2)// 변경 가능val emptyMutableMap = mutableMapOf&lt;String, Int&gt;()mapOf.get(\"a\")mapOf[\"a\"]emptyMutableMap.put(\"c\", 3)람다식람다식 선언// 기본 함수 선언 방식fun sum(a: Int, b: Int): Int {    return a + b}// 기본 함수 선언 방식을 람다식으로 표현val sumLambda: (Int, Int) -&gt; Int = { a, b -&gt; a + b }// 코틀린 함수 선언 방식fun sum2(a: Int, b: Int) = a + b// 코틀린 함수 선언 방식을 람다식으로 표현val sum2Lambda = { a: Int, b: Int -&gt; a + b }콜렉션 람다식val listOf = List(10) { v -&gt; v + 1 }val newList = listOf.filter { it &gt; 2 }                .map { it + 10 }ETC연산자 오버로딩operator fun Int.plus(b: String) = \"$this$b\"println(10 + \"2\") // 102 출력      연산자를 overloading 할 수 있다, overriding 아닌 overloading 이다!!  연산자 확장class Position(var a: Int, var b: Int) {    operator fun plus(position: Position): Position {        return Position(a + position.a, b + position.b)    }}val position = Position(1, 2) + Position(3, 4)println(position.a) // 4 출력  클레스에 연산자를 확장하여 사용 할 수 있다.Collection get/set 확장class Position(var a: Int, var b: Int) {    operator fun set(position: Int, value: Int) {        when (position) {            0 -&gt; a = value            1 -&gt; b = value            else -&gt; throw IndexOutOfBoundsException(\"error\")        }    }    operator fun get(position: Int): Int = when (position) {        0 -&gt; a        1 -&gt; b        else -&gt; throw IndexOutOfBoundsException(\"error\")    }}val position = Position(1,2)position[1] = 10println(position[1]) // 10 출력  클래스에 콜렉션의 get/set을 확장 할 수 있다.Observable// var name: String by observable(\"김찬정\") { property, oldValue, newValue -&gt; println(\"newValue\") }name = \"김찬정님\"  name 값이 변할 때 println 호출 된다.Vetoablevar age: Int by vetoable(0) { property, oldValue, newValue -&gt; newValue &gt; oldValue }age = 10assertEquals(10, age)age = 5assertEquals(10, age)age = 20assertEquals(20, age)  age가 변경 될 때 마다 수행 되는데 true 일 때만 값이 변경 된다.Higher Order FunctionHigher Order Function은 매개변수로 다른 함수나 람다식을 인자로 받는 함수를 말한다fun calculator(a: Int, b: Int, exec: (value1: Int, value2: Int) -&gt; Int): Int {    return exec(a, b)}// 간략 하게 선언 가능fun calculator2(exec: () -&gt; Int) = exec()Higher Order Function의 inline/nolineinline fun calculator3(a: Int, exec: (value: Int) -&gt; Int, noinline exec2: (value: Int) -&gt; Int): Int {    return exec(a) + exec2(a)}      Higher Order 함수는 사용시(호출)에 파라메터로 전달되는 함수가사실상 new 해서 새로운 객체가 매번 생기는 방식으로 동작한다 비효울 적이다    이런 경우 inline 키워드를 사용하면 파라메터로 전달되는 모든 함수가 매번 new 생성 Higher Order 함수 내부에 있게 된다. 결론 적으로 매번 새로운 객체가 생성되는 것이 아니게 된다.    inline선언해서 모든 파라메터 함수가  매번 new 하지 않게 되었지만파라메터로 전달되는 함수 앞에 noinline을 선언하면  new 해서 생성되게 된다.  예외// try catch 블럭이 아니라 마치 if 처럼 동작한다fun simpleFunction(value: String): Int? {    val result: Int? = try {        parseInt(value)    } catch (e: NumberFormatException) {        null    }    return result}// 변수에 할당 하지 않고 바로 반환fun simpleFunction(value: String): Int? {    return try {        parseInt(value)    } catch (e: NumberFormatException) {        null    }}// name이 null 이면 예외 발생 시킨다.fun simpleFunction(name: String?): String {    return name ?: throw IllegalArgumentException(\"이름을 입력 하세요\")}      코틀린 예외는 cheked와 unchecked 구문없다. 모든 예외는 unchecked다    예외 처리 블럭이 if, when 처 표현식 처럼 동작한다. value가 숫자형이 아니면 null이 result 할당된다  Destructuring 을 위한 일반 class 선언// 일반 클래스는 componentN 메소드를 구현 해야 한다.class Person(val name: String, val age: Int) {    operator fun component1(): String = name    operator fun component2(): Int = age}val person = Person(\"Adam\", 100)val (name, age) = personassertEquals(\"김찬정\", name)assertEquals(20, age)Destructuring 을 위한 data class 선언// 데이터 클래스는 기본으로 componentN 제공한다.data class NewPerson(val age: Int, val name: String) val newPerson = NewPerson(20, \"김찬정\")// 프로퍼티 이름이 다른경우 선언 순서대로 리턴한다val (newName, newAge) = newPersonassertEquals(20, newName) // age가 먼저 선언 되었으므로 사실상 age값이 된다.assertEquals(\"김찬\", newAge)Destructuring 배열// 배열val coordinates = arrayOf(1, 2, 3)val (x, y, z) = coordinates",
        "url": "/programming/2020/05/06/kotlin-basic-syntax-summary/"
    }
    ,
    
    "etc-2020-01-15-java-collection": {
        "title": "JAVA - 자료구조, Collection 별 특징 정리",
            "author": "kimchanjung",
            "category": "",
            "content": "JAVA Collection별 특징과 시간 메소드별 시간 복잡도를 일목요연하게 정리한 내용입니다.JAVA - 자료구조, Collection 별 특징 정리Collection 특징 구분            구분      종류      중복허용      순서 존재      정렬여부      Thread-safe                  LIST      ArrayList   LinkedList  Vector      Yes YesYes      Yes YesYes      No  No   No      No   No  Yes              SET      HashSetLinkedHashSetTreeSet      No  No  No      No   YesYes      No No Yes      No   NoNo              MAP      HashMap  LinkedHashMap    Hashtable  TreeMap      No  No  No  No      No   Yes  No  Yes      Yes(Key)     No  No  Yes      No   No   Yes   No      자료 구조 특징 구분            종류      특징      중복허용      Null 허용                  List      원하는 순서로 Element 삽입가능  각 요소는 Index 번호를 부여 받는다.      Yes      -              Set      중복 Element 불가능  그러므로 쉽게 여부 중복확인 가능. 특정 순서(Order) 정할수 없음.      No      -              Queue      Output으로 나올 Element만 기본적으로 접근 가능하다      Yes      -              PriorityQueue      가장 우선순위가 높은 Element가 Head First가 된다      Yes      No              Deque      양 끝단에서 모두 삽입 / 삭제 가능      Yes      -              Map      Key / Value로 구성된다.      키 : No - 값 : Yes      키 : 하나의 (null) 키 허용) - 값 : Yes      LIST            Class Name      Add      Remove      Get      Contains                  ArrayList      O(1)      O(n)      O(1)      O(n)              LinkedList      O(1)      O(1)      O(n)      O(n)      SET            Class Name      Add      Contains      Next                  HashSet      O(1)      O(1)      O(h/n)              LinkedHashSet      O(1)      O(1)      O(1)              EnumSet      O(1)      O(1)      O(1)              TreeSet      O(log n)      O(log n)      O(log n)      QUEUE            Class Name      Offer      Peak      Poll      Size                  PriorityQueue      O(log n)      O(1)      O(log n)      O(1)              LinkedList      O(1)      O(1)      O(1)      O(1)              ArrayDequeue      O(1)      O(1)      O(1)      O(1)              DelayQueue      O(log n)      O(1)      O(log n)      O(1)      MAP            Class Name      Get      ContainsKey      Next                  HashMap      O(1)      O(1)      O(h/n)              LinkedHashMap      O(1)      O(1)      O(1)              WeakHashMap      O(1)      O(1)      O(h/n)              EnumMap      O(1)      O(1)      O(1)              TreeMap      O(log n)      O(log n)      O(log n)      ",
        "url": "/etc/2020/01/15/java-collection/"
    }
    ,
    
    "projects-2020-01-04-brms": {
        "title": "라이더운영시스템",
            "author": "kimchanjung",
            "category": "",
            "content": "배달의민족 배민라이더스의 라이더운영시스템 프로젝트의 소개라이더운영시스템  기존 배민라이더운영시스템에서 라이더관련 부분을 분리하여 MSA로 구성한 라이더관리 전용 시스템[그림 1] 메인화면관련 기술블로그  React에서 Mobx 경험기 (Redux와 비교기)  [마이크로서비스] 스프링 마이크로서비스 정리 (spring microservice, msa)프로젝트 기간  2019.02 ~ 2019.05프로젝트 참여도  프로젝트 인원 2 명  백엔드 전반적인 설계 및 프로젝트 BASE 코드 및 비즈니스 코드 작성  React 프론트는 대부분 90% 전담 개발주요 기능  라이더기본정보 및 운영, 정산에 필요한 정보 관리  배달운영시스템과 MSA로 분리 구성이 됨으로써 AWS SNS/SQS이용한 상호 연동 처리  SAP(ERP) 시스팀과 연동 처리적용된 기술셋Back-End  Java v1.8  Spring-Boot v2.1  JPA v2.1  MySql v5.1Front-End  React v16.8  Mobx v5.9  Material-UI v3.9  Webpack v4.29Etc  AWS - Elastic Beanstalk, SNS, SQS  Redis간략한 시스템 구성도[그림 2] 구성도시스템 구성 설명  각 서버는 Elastic Beanstalk으로 구성되며 내부 적으로 EC2인스턴스가 autoscaling으로 구성 되어 있음  MySql DB는 AWS-RDS를 사용, 마스터/슬레이브로 2중화 되어 운영  REDIS를 서버인증세션 저장 및 캐시의 용도로 사용  MSA로 분리된 라이더관리 시스템의 라이더관련 데이터를 AWS SNS/SQS를 이용, event-sourcing으로 이벤트를 발행하고 배달운영시스템(BROS) 및 타 시스템은 이벤드를 구독하여 동기화 처리를 할수 있도록 서버를 구성  사내 타 팀과 외부 업체와의 연동을 위해서 우리 시스템에 접근 하기위한 공개 API 서버를 운영함,효과      React + Mobx의 주말 개인 프로젝트로 Front-End의 60% 정도의 베이스코드를 완성하여 실제 개발 기간단축 및 팀내 차기 Front-End SPA 프레임워크 채택의 결정적 역할`을 함(vs Vue.js)    기존 배달운영시스템에 포함 되어 있던 라이더 관련 기능을 MSA로 별도의 시스템으로 분리 신규 개발    시스템간 강한 의존성을 제거  느낀점  MSA로 구성시 시스템간 단순 ACTION을 처리하는 것과는 다르게 DB 데이터를 완전히 분리하여 이벤트소싱으로 서로 동기화 하고 부가적인 연동 처리 (Email 발송, 회계시스템 연동 등등)등 다소 복잡한 구성을 MSA 로 처리한다는 것은 기술 문서나 기술동향에 정답이 있다기 보다 상황에 맞게 절절히 (비동기, 동기) 처리 해야함을 느낌  실무적인 경험이 더 중요한 분야 같음",
        "url": "/projects/2020/01/04/brms/"
    }
    ,
    
    "projects-2020-01-03-bros-v2": {
        "title": "배민라이더스운영시스템(2.0)",
            "author": "kimchanjung",
            "category": "",
            "content": "배달의민족 배민라이더스의 배민라이더스운영시스템(BROS 2.0) 프로젝트 소개입니다.배민라이더스운영시스템(2.0)  배민라이더스의 업무처리 및 관리를 위한 메인 시스템 대부분 배민라이더스운영시스템을 운영 하고 신규 기능을 개발한는 것이 주 업무[그림 1] 메인화면프로젝트 기간  2016.02 ~ 2019.01프로젝트 참여도  프로젝트 인원 6명  1차 신규 오픈 프로젝트에 참여함, 각자 분배된 분량의 백엔드 API 및 JS 프론트엔드 개발  추후 지속적인 운영과 신규 기능 추가 개발 업무  사실상 팀내 메인 운영 개발 시스템주요 기능  라이더의 실시간 주문처리현황 관제 및 운영을 제공  배달권역 설정, 배달료관련 설정 등등 운영에 필요한 설정 기능을 제공  라이더 배달료 정산에 필요한 각종 데이터 및 지표 제공  BROS 1.0에 더 추가된 각종 기능 셋 제공적용된 기술셋Back-End  Java v1.8  Spring-Boot v1.5  JPA v1.5  MySql v5.1Front-End  WoowahanJS(사내 Javascript SPA Framework)Etc  AWS - Elastic Beanstalk, SNS, SQS  Redis  Websocket간략한 시스템 구성도[그림 2] 구성도시스템 구성 설명  각 서버는 Elastic Beanstalk으로 구성되며 내부 적으로 EC2인스턴스가 autoscaling으로 구성 되어 있음  MySql DB는 AWS-RDS를 사용, 마스터/슬레이브로 2중화 되어 운영  REDIS를 서버인증세션 저장 및 캐시의 용도로 사용  웹소켓 서버는 redis pub/sub 사용하여 메시지가 여러대의 서버에 공유될 수 있도록 처리  라이더앱과 백오피스는 웹소켓서버를 통하여 실시간 배달상태변경 및 라이더의 배달현황/위치를 동기화 함  MSA로 분리된 라이더관리 시스템의 라이더관련 데이터를 AWS SNS/SQS를 이용, event-sourcing으로 동기화 처리를 담당하는 서버를 운영함  사내 타 팀과 외부 업체와의 연동을 위해서 우리 시스템에 접근 하기위한 공개 API 서버를 운영함,효과  AWS 인프라 위에서 개발된 팀내 최초 프로젝트로써 수직 상승하는 사업 니즈에 맞춰 flexible한 인프라 자원 운영이 가능해짐느낀점  본격적으로 팀내 코드 리뷰, 테스트코드, Pair Programming 문화가 정착 되기 시작한 프로젝트  팀내 개발 문화가 시스템 안정성을 높이는 결과를 가져왔음(무장애 300일)  장애 발생시 대외 신뢰성 추락, 금전적 피해를 감안해 보았을 때 안정성은 매우 중요한 가치라는 것을 증명해 보임(결과물을 빨리 내는 것에 대비하여)",
        "url": "/projects/2020/01/03/bros-v2/"
    }
    ,
    
    "projects-2020-01-02-socket-io-server": {
        "title": "실시간 메시징 서버(socket.io)",
            "author": "kimchanjung",
            "category": "",
            "content": "배달의민족 배민라이더스의 실시간 배달처리 시스템을 위한 실시간 메시징 서버(socket.io)개발 프로젝트의 소개입니다.실시간 메시징 서버(socket.io)  멀티플랫폼(web/ios/android)을 지원하는 실시간 메시징 서버[그림 1] 메인화면관련 기술블로그  실시간 서비스 경험기(배달운영시스템)프로젝트 기간  2015.08 ~ 2016.08프로젝트 참여도  프로젝트 인원 1명  전담하여 개발주요 기능  websocket 실시간 메시징을 지원하여 실시간 서비스 개발을 지원함  web/android/ios 등 멀티 플랫폼을 지원함  채팅 기능 구현 가능함  개별/채널/브로드캐스팅 등 다양한 이벤트송수신 그룹 지원  서버사용량/개설채널 및 클라이언트현황등의 서버모니터링 페이지 제공적용된 기술 및 라이브러리  Node.js  Socket.io  Redis pub/sub  socketio-sticky-session  Node.js Cluster간략한 시스템 구성도[그림 2] 구성도시스템 구성 설명  백오피스 서버는 API 서버와 angularjs 프론트엔드로 구성 되어 있음  라이더앱과 백오피스는 Socket.io로 개발된 websocket 서버를 통하여 실시간으로 배달 및 라이더 현황을 관리함  웹소켓 서버는 nodejs 기반 이라 싱글 프로세스로 동작하지만 서버자원을 효율적으로 사용하기 위하여 멀티프로세스로 프로그래밍하였음  멀티프로세스로 구동시 각각의 프로세스에 메시지를 공유하기 위해 Redis pub/sub를 사용  일반적으로 클라이언트가 서버 접속시 L4가 sticky session 처리를 해서 처음 접속한 서버로만 접속이 되지만 Node.js 멀티 프로세스의 경우 멀티 쓰레드가 아니므로 내부적으로 처음 접속한 프로세스에 클라이언트가 접속되도록 별도의 sticky session 처리를 해주었음효과      SaaS서비스인 pubnub을 사용하여 실시간 처리를 구현 하였지만 주말 개인 프로젝트로 시작하여 내재화에 성공함,    실시간 이벤트가 필요한 서비스에 기능을 제공, 이를 활용하여 실시간 서비스를 실현 함에도 DB 호출 트래픽을 현저하게 낮춤  느낀점  초기 개발 문서에 간략히 기술 된 이벤트 수신후 송신 부분만 구현 하면 되는 비교적 간단한 로직으로 생각(빙산의 일각)  Node.js는 싱글 프로세스, 서버의 CPU Core 수만큼 Multi-Processing을 코드로 구현 해야 함  Multi-Processing로 인하여 process간 상태(이벤트 메시지 데이터 및 관리 데이터)공유 이슈는 Redis pub/sub사용하여 해결.  Client의 접속이 처음 접속한 Process에만 통신 하도록 sticky-session을 적용하여 해결함.  서버현황데이터 제공을 위하여 Client, NameSpace, Room 현황 데이터를 Redis로 관리하던 중 간혹 동기식 처리로직으로 인하여 급격한 성능저하를 경험.  Redis에는 데이터구조를 되도록 단순하게 설계, 관리 필요성과, Node.js는 동기적으로 처리하는 로직은 지양 해야함을 크게 느낌  NameSpace, Room, EventType 별로 적절한 구조화 필요",
        "url": "/projects/2020/01/02/socket-io-server/"
    }
    ,
    
    "projects-2020-01-01-bros-v1": {
        "title": "배민라이더스운영시스템(1.0)",
            "author": "kimchanjung",
            "category": "",
            "content": "배달의민족 배민라이더의 배민라이더스운영시스템(1.0) 프로젝트 소개입니다.배민라이더스운영시스템(1.0)  배달접수와 실시간 배달처리 현황 및 라이더 관제기능을 지원하는 종합 운영 시스템[그림 1] 메인화면관련 기술블로그  실시간 서비스 경험기(배달운영시스템)프로젝트 기간  2015.02 ~ 2016.08프로젝트 참여도  프로젝트 인원 5명  배민라이더스운영시스템 사이트 Back-End API와 Angularjs Front-End 전담하여 개발  Websocket 서버를 전담하여 개발  나머지 인원은 라이더앱 및 라이더앱 API 개발과 결제시스템 개발함주요 기능  배달접수처리 기능  실시간 배달연황 및 라이더 현황 관제  배달료 정산을 위한 데이터 제공  채팅 기능 제공적용된 기술셋Back-End  PHP 5.6  CodeIgniter 3.1  Nodejs  Socket.io  sqlserverFront-End  AngularJS 1.8  Bootstrap 2.xEtc  Websocket  Redis  winston  socketio-sticky-session간략한 시스템 구성도[그림 2] 구성도시스템 구성 설명  백오피스 서버는 API 서버와 angularjs 프론트엔드로 구성 되어 있음  라이더앱과 백오피스는 Socket.io로 개발된 websocket 서버를 통하여 실시간으로 배달 및 라이더 현황을 관리함  웹소켓 서버는 nodejs 기반 이라 싱글 프로세스로 동작하지만 서버자원을 효율적으로 사용하기 위하여 멀티프로세스로 프로그래밍하였음  멀티프로세스로 구동시 각각의 프로세스에 메시지를 공유하기 위해 Redis pub/sub를 사용효과      실시간 이벤트 서버 도입으로 Polling 방식에 비하여 DB호출 횟수를 현저하게 낮춤에도 불구 실시간 서비스가 가능하게 됨.    AngularJs 특징인 양방향 데이터 바인딩 기능을 실시간 데이터 제공에 적극 활용    실시간 이벤트 서버 Socket.io(Node.js) 를 이용하여 데이터 생성, 변경, 삭제 시 실시간 이벤트로 데이터를 송수신 하여 AngularJS 모델에 반영하도록 하고 뷰의 갱신을 신경쓸 필요없는 구조.  느낀점  AngularJS + Socket.io 신기술의 장점을 활용하여 개발 해볼 수 있었던 기회 통해 출근이 기다려지는 기분을 경험.  실시간 서비스라는 다소 생소하고 복잡한 서비스 경험에 엄청난 개발욕구를 경험  실무를 통해서만 습득 할 수 있는 실시간 서비스만의 개발, 운영 이슈에 대한 깊이 있는 경험.",
        "url": "/projects/2020/01/01/bros-v1/"
    }
    
    
    };
</script>
<script src="/assets/js/lunr.js"></script>
<script src="/assets/js/search.js"></script>

            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <i class="fab fa-facebook-square"></i>
                <section class="copyright"><a href="https://kimchanjung.github.io/">mogomezwai</a> &copy; 2020</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    <a href="https://facebook.com/mogomezwai" target="_blank" rel="noopener">Facebook</a>
                    <a href="https://twitter.com/mogomezwai" target="_blank" rel="noopener">Twitter</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                    <img class="subscribe-overlay-logo" src="/assets/images/mogomezwai-logo.png" alt="mogomezwai" />
                
                <h1 class="subscribe-overlay-title">Search mogomezwai</h1>
                <p class="subscribe-overlay-description">Post를 검색 하세요.</p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search?query=" + url;
            }
        }
    </script>
</span>

            </div>
        </div>
    

    <!-- highlight.js -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script> -->

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!--script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script-->


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->
    
    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
    if (window.location.hostname != "localhost") {
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-165866221-1', 'auto');
        ga('send', 'pageview');
    }
 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
